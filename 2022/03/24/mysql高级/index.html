<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
        MySql高级 - YTTE Site
      </title>
        <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    
    <meta name="theme-color" content="#000000" />
    
    <meta http-equiv="window-target" content="_top" />
    
    
    <meta name="description" content="" />
    <meta name="generator" content="Hugo 0.95.0 with theme pure" />
    <title>MySql高级 - YTTE Site</title>
    
    
    <link rel="stylesheet" href="https://gb.ytte.top/css/style.min.d929005ce448e2f7ce0134853caf845b03d0d60a192e90f0e1e13b700d30e9ff.css">
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/monokai.min.css" async>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css" async>
    <meta property="og:title" content="MySql高级" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://gb.ytte.top/2022/03/24/mysql%E9%AB%98%E7%BA%A7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-24T16:49:54+08:00" />
<meta property="article:modified_time" content="2022-03-24T16:49:54+08:00" />

<meta itemprop="name" content="MySql高级">
<meta itemprop="description" content=""><meta itemprop="datePublished" content="2022-03-24T16:49:54+08:00" />
<meta itemprop="dateModified" content="2022-03-24T16:49:54+08:00" />
<meta itemprop="wordCount" content="28925">
<meta itemprop="keywords" content="mysql," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MySql高级"/>
<meta name="twitter:description" content=""/>

    <!--[if lte IE 9]>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
      <![endif]-->

    <!--[if lt IE 9]>
        <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
      <![endif]-->
  </head>

  
  

  <body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="https://github.com/YTTE-jx" target="_blank">
            <img class="img-circle img-rotate" src="https://gb.ytte.top/avatar.png" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">YTTE</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">努力奋斗，不负韶华。</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>Anhui, China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="Type something..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">Home</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/posts/">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">Archives</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/categories/">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">Categories</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/tags/">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">Tags</span>
                </a>
            </li>
            <li class="menu-item menu-item-about">
                <a href="/about/">
                    <i class="icon icon-cup-fill"></i>
                  <span class="menu-title">About</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>

<aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content"><p> 人生无常，大肠包小肠~</p>
            </div>
        </div>
    </div>
</div>

      <div class="widget">
    <h3 class="widget-title"> Tags</h3>
    <div id="tag-cloud-list" class="widget-body">
            
            
            <a href="https://gb.ytte.top/tags/bolg/" class="tag-list-link" rel="1">bolg<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/docker/" class="tag-list-link" rel="1">docker<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/git/" class="tag-list-link" rel="1">git<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/gitee/" class="tag-list-link" rel="2">gitee<span
               class="tag-list-count">2</span></a>
            
            
            <a href="https://gb.ytte.top/tags/github/" class="tag-list-link" rel="1">github<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/hexo/" class="tag-list-link" rel="1">hexo<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/https/" class="tag-list-link" rel="1">https<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/hugo/" class="tag-list-link" rel="1">hugo<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/index/" class="tag-list-link" rel="1">index<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/jvm/" class="tag-list-link" rel="1">jvm<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/mysql/" class="tag-list-link" rel="3">mysql<span
               class="tag-list-count">3</span></a>
            
            
            <a href="https://gb.ytte.top/tags/rabbit-mq/" class="tag-list-link" rel="1">rabbit-mq<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/springboot/" class="tag-list-link" rel="1">springboot<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/springcloud/" class="tag-list-link" rel="1">springcloud<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/thread/" class="tag-list-link" rel="1">thread<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/typora/" class="tag-list-link" rel="1">typora<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/zookeeper/" class="tag-list-link" rel="1">zookeeper<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/%E5%9F%9F%E5%90%8D/" class="tag-list-link" rel="2">域名<span
               class="tag-list-count">2</span></a>
            
            
            <a href="https://gb.ytte.top/tags/%E5%9F%BA%E7%A1%80/" class="tag-list-link" rel="3">基础<span
               class="tag-list-count">3</span></a>
            
            
            <a href="https://gb.ytte.top/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/" class="tag-list-link" rel="1">谷粒商城<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/%E9%A2%98%E7%9B%AE/" class="tag-list-link" rel="1">题目<span
               class="tag-list-count">1</span></a>
            
    </div>
<script>
document.onreadystatechange = () => {
  if (document.readyState === 'complete') {
    tagCloud('#tag-cloud-list a',  8 ,  20 );
  }
};

function tagCloud(where, min, max) {
  let iMax = 0;
  let iMin = 0;
  $(where).each(function() {
    let weight = Number($(this).attr("rel"));
    if(iMax < weight) iMax = weight;
    if(iMin > weight || iMin == 0) iMin = weight;
  });
  let step = (max - min)/(iMax - iMin);
  $(where).each(function() {
    let weight = $(this).attr("rel") - iMin;
    $(this).css({"font-size": min + (weight * step) + 'px'});
  });
};
</script>
</div>

      <div class="widget">
    <h3 class="widget-title"> Categories</h3>
    <div class="widget-body">
        <ul class="category-list">
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/bolg/" class="category-list-link">bolg</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/git/" class="category-list-link">git</a><span class="category-list-count">2</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/java/" class="category-list-link">java</a><span class="category-list-count">6</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/jvm/" class="category-list-link">jvm</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/zookeeper/" class="category-list-link">zookeeper</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="category-list-link">数据库</a><span class="category-list-count">3</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="category-list-link">服务器</a><span class="category-list-count">5</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/%E6%9D%82%E9%A1%B9/" class="category-list-link">杂项</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="category-list-link">消息队列</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="category-list-link">计算机网络</a><span class="category-list-count">3</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/%E9%A1%B9%E7%9B%AE/" class="category-list-link">项目</a><span class="category-list-count">1</span></li>
        </ul>
    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gb.ytte.top/2022/03/31/mysql-exercises-and-summaries/" class="title">Mysql Exercises and Summaries</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-31 21:49:37 &#43;0800 CST" itemprop="datePublished">2022-03-31</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gb.ytte.top/2022/03/24/mysql%E5%9F%BA%E7%A1%80/" class="title">MySql基础</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-24 16:49:54 &#43;0800 CST" itemprop="datePublished">2022-03-24</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gb.ytte.top/2022/03/24/mysql%E9%AB%98%E7%BA%A7/" class="title">MySql高级</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-24 16:49:54 &#43;0800 CST" itemprop="datePublished">2022-03-24</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gb.ytte.top/2022/03/22/rabbit-mq/" class="title">Rabbit Mq</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-22 13:31:53 &#43;0800 CST" itemprop="datePublished">2022-03-22</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gb.ytte.top/2022/03/22/docker/" class="title">Docker</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-22 13:31:01 &#43;0800 CST" itemprop="datePublished">2022-03-22</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <h4 class="toc-title">Catalogue</h4>
    <nav id="toc" class="js-toc toc">

    </nav>
  </div>
</aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/2022/03/24/mysql%E9%AB%98%E7%BA%A7/"
    >MySql高级</a
  >
</h1>

      <div class="article-meta">
        
<span class="article-date">
  <i class="icon icon-calendar-check"></i>&nbsp;
<a href="https://gb.ytte.top/2022/03/24/mysql%E9%AB%98%E7%BA%A7/" class="article-date">
  <time datetime="2022-03-24 16:49:54 &#43;0800 CST" itemprop="datePublished">2022-03-24</time>
</a>
</span>
<span class="article-category">
  <i class="icon icon-folder"></i>&nbsp;
  <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"> 数据库 </a>
</span>  
  <span class="article-tag">
    <i class="icon icon-tags"></i>&nbsp;
    <a class="article-tag-link" href="/tags/mysql/"> mysql </a>
  </span>

		<span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 28925 words</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">Read Time: 58 minutes </span>
      </div>
    </div>
    <div class="article-entry marked-body js-toc-content" itemprop="articleBody">
      <p>顺序io随机io</p>
<p>回表查询</p>
<h1 id="mysql高级">MySQL高级</h1>
<p>sql数据：</p>
<ul>
<li>
<p>course表</p>
<ul>
<li>
<p>8</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">`</span>course<span style="color:#f92672">`</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">AUTO_INCREMENT</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>course_id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>course_name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">40</span>) <span style="color:#66d9ef">CHARACTER</span> <span style="color:#66d9ef">SET</span> utf8 <span style="color:#66d9ef">COLLATE</span> utf8_general_ci <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span>) <span style="color:#66d9ef">USING</span> BTREE,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">KEY</span> <span style="color:#f92672">`</span>idx<span style="color:#f92672">`</span> (<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span>) <span style="color:#66d9ef">USING</span> BTREE
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">ENGINE</span><span style="color:#f92672">=</span>InnoDB <span style="color:#66d9ef">AUTO_INCREMENT</span><span style="color:#f92672">=</span><span style="color:#ae81ff">201</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">CHARSET</span><span style="color:#f92672">=</span>utf8mb3;
</span></span></code></pre></div></li>
<li>
<p>5.7</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">`</span>course<span style="color:#f92672">`</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">AUTO_INCREMENT</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>course_id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>course_name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">40</span>) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span>) <span style="color:#66d9ef">USING</span> BTREE,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">KEY</span> <span style="color:#f92672">`</span>idx<span style="color:#f92672">`</span> (<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span>) <span style="color:#66d9ef">USING</span> BTREE
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">ENGINE</span><span style="color:#f92672">=</span>InnoDB <span style="color:#66d9ef">AUTO_INCREMENT</span><span style="color:#f92672">=</span><span style="color:#ae81ff">201</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">CHARSET</span><span style="color:#f92672">=</span>utf8;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>student_info表</p>
<ul>
<li>
<p>8</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">`</span>student_info<span style="color:#f92672">`</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">AUTO_INCREMENT</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>student_id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">CHARACTER</span> <span style="color:#66d9ef">SET</span> utf8 <span style="color:#66d9ef">COLLATE</span> utf8_general_ci <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>course_id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>class_id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>create_time<span style="color:#f92672">`</span> <span style="color:#66d9ef">datetime</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">CURRENT_TIMESTAMP</span> <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">UPDATE</span> <span style="color:#66d9ef">CURRENT_TIMESTAMP</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span>) <span style="color:#66d9ef">USING</span> BTREE,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">KEY</span> <span style="color:#f92672">`</span>idx_sid<span style="color:#f92672">`</span> (<span style="color:#f92672">`</span>student_id<span style="color:#f92672">`</span>),
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">KEY</span> <span style="color:#f92672">`</span>idx_cre_time<span style="color:#f92672">`</span> (<span style="color:#f92672">`</span>create_time<span style="color:#f92672">`</span>)
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">ENGINE</span><span style="color:#f92672">=</span>InnoDB <span style="color:#66d9ef">AUTO_INCREMENT</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1000001</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">CHARSET</span><span style="color:#f92672">=</span>utf8mb3;
</span></span></code></pre></div></li>
<li>
<p>5.7</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#f92672">`</span>student_info<span style="color:#f92672">`</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">AUTO_INCREMENT</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>student_id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>name<span style="color:#f92672">`</span> <span style="color:#66d9ef">varchar</span>(<span style="color:#ae81ff">20</span>) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>course_id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>class_id<span style="color:#f92672">`</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">11</span>) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>create_time<span style="color:#f92672">`</span> <span style="color:#66d9ef">datetime</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">CURRENT_TIMESTAMP</span> <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">UPDATE</span> <span style="color:#66d9ef">CURRENT_TIMESTAMP</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (<span style="color:#f92672">`</span>id<span style="color:#f92672">`</span>) <span style="color:#66d9ef">USING</span> BTREE
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">ENGINE</span><span style="color:#f92672">=</span>InnoDB <span style="color:#66d9ef">AUTO_INCREMENT</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1000001</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#66d9ef">CHARSET</span><span style="color:#f92672">=</span>utf8;
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>存储过程，为course增加100条数据；为student_info 增加100w条数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">set</span> global log_bin_trust_function_creators<span style="color:#f92672">=</span><span style="color:#66d9ef">TRUE</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DELIMITER <span style="color:#f92672">//</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> FUNCTION <span style="color:#a6e22e">rand_string</span> ( n <span style="color:#66d9ef">INT</span> ) RETURNS <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">255</span> ) BEGIN
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">DECLARE</span>
</span></span><span style="display:flex;"><span>		chars_str <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#e6db74">&#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#39;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">DECLARE</span>
</span></span><span style="display:flex;"><span>		return_str <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">255</span> ) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#e6db74">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">DECLARE</span>
</span></span><span style="display:flex;"><span>		i <span style="color:#66d9ef">INT</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">WHILE</span>
</span></span><span style="display:flex;"><span>			i <span style="color:#f92672">&lt;</span> n DO
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">SET</span> return_str <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONCAT</span>(
</span></span><span style="display:flex;"><span>				return_str,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">SUBSTRING</span>( chars_str, <span style="color:#a6e22e">FLOOR</span>( <span style="color:#ae81ff">1</span><span style="color:#f92672">+</span><span style="color:#a6e22e">RAND</span> ()<span style="color:#f92672">*</span> <span style="color:#ae81ff">52</span> ), <span style="color:#ae81ff">1</span> ));
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">SET</span> i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	END <span style="color:#66d9ef">WHILE</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">RETURN</span> return_str;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>END <span style="color:#f92672">//</span> 
</span></span><span style="display:flex;"><span>DELIMITER;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DELIMITER <span style="color:#f92672">//</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> FUNCTION <span style="color:#a6e22e">rand_num</span> ( from_num <span style="color:#66d9ef">INT</span>, to_num <span style="color:#66d9ef">INT</span> ) RETURNS <span style="color:#66d9ef">INT</span> ( <span style="color:#ae81ff">11</span> ) BEGIN
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">DECLARE</span>
</span></span><span style="display:flex;"><span>		i <span style="color:#66d9ef">INT</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">SET</span> i <span style="color:#f92672">=</span> <span style="color:#a6e22e">FLOOR</span>(
</span></span><span style="display:flex;"><span>		from_num <span style="color:#f92672">+</span> <span style="color:#a6e22e">RAND</span>()<span style="color:#f92672">*</span>(
</span></span><span style="display:flex;"><span>			to_num <span style="color:#f92672">-</span> from_num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> 
</span></span><span style="display:flex;"><span>		));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">RETURN</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>END <span style="color:#f92672">//</span> 
</span></span><span style="display:flex;"><span>DELIMITER;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">show</span> variables <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;log_bin_trust_function_creators&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">set</span> global log_bin_trust_function_creators<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DELIMITER <span style="color:#f92672">//</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">PROCEDURE</span> <span style="color:#a6e22e">insert_course</span> ( max_num <span style="color:#66d9ef">INT</span> ) BEGIN
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">DECLARE</span>
</span></span><span style="display:flex;"><span>		i <span style="color:#66d9ef">INT</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">SET</span> autocommit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">REPEAT</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">SET</span> i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#a6e22e">course</span> ( course_id, course_name )
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">VALUES</span>
</span></span><span style="display:flex;"><span>			(
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_num</span> ( <span style="color:#ae81ff">10000</span>, <span style="color:#ae81ff">10100</span> ),
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">rand_string</span> ( <span style="color:#ae81ff">6</span> ));
</span></span><span style="display:flex;"><span>		UNTIL i <span style="color:#f92672">=</span> max_num 
</span></span><span style="display:flex;"><span>	END <span style="color:#66d9ef">REPEAT</span>;
</span></span><span style="display:flex;"><span>	COMMIT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>END <span style="color:#f92672">//</span> 
</span></span><span style="display:flex;"><span>DELIMITER;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DELIMITER <span style="color:#f92672">//</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">PROCEDURE</span> <span style="color:#a6e22e">insert_stu</span> ( max_num <span style="color:#66d9ef">INT</span> ) BEGIN
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">DECLARE</span>
</span></span><span style="display:flex;"><span>		i <span style="color:#66d9ef">INT</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">SET</span> autocommit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">REPEAT</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">SET</span> i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#a6e22e">student_info</span> ( course_id, class_id, student_id, NAME )
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">VALUES</span>
</span></span><span style="display:flex;"><span>			(
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_num</span> ( <span style="color:#ae81ff">10000</span>, <span style="color:#ae81ff">10100</span> ),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_num</span> ( <span style="color:#ae81ff">10000</span>, <span style="color:#ae81ff">10200</span> ),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_num</span> ( <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">200000</span> ),
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">rand_string</span> ( <span style="color:#ae81ff">6</span> ));
</span></span><span style="display:flex;"><span>		UNTIL i <span style="color:#f92672">=</span> max_num 
</span></span><span style="display:flex;"><span>	END <span style="color:#66d9ef">REPEAT</span>;
</span></span><span style="display:flex;"><span>	COMMIT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>END <span style="color:#f92672">//</span> 
</span></span><span style="display:flex;"><span>DELIMITER;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CALL</span> <span style="color:#a6e22e">insert_course</span>(<span style="color:#ae81ff">100</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CALL</span> <span style="color:#a6e22e">insert_stu</span>(<span style="color:#ae81ff">1000000</span>);
</span></span></code></pre></div></li>
</ul>
<h1 id="索引的创建与设计原则">索引的创建与设计原则</h1>
<h2 id="索引的必要使用场景">索引的必要使用场景</h2>
<h3 id="字段的数值有唯一性的限制">字段的数值有唯一性的限制</h3>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</p>
<p>说明：唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
<h3 id="频繁作为-where-查询条件的字段">频繁作为 WHERE 查询条件的字段</h3>
<p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
<p>比如查询 <code>student_id =144324</code>的时候</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> course_id ,class_id, <span style="color:#f92672">`</span>name<span style="color:#f92672">`</span>,create_time,student_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> student_info 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> student_id <span style="color:#f92672">=</span><span style="color:#ae81ff">144324</span>
</span></span></code></pre></div><ul>
<li>
<p>在student_id不加索引的情况下，<strong>100w</strong>条数据，耗时为<strong>350ms</strong>左右，即在百毫秒级</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> student_info 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ADD</span> <span style="color:#66d9ef">INDEX</span> idx_sid(student_id)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#66d9ef">FROM</span> student_info  <span style="color:#f92672">#</span><span style="color:#960050;background-color:#1e0010">查看是否添加成功</span>
</span></span></code></pre></div></li>
<li>
<p>在添加索引的情况下，耗时为<strong>22ms</strong>，降了一个数量级，这是很客观的。</p>
</li>
</ul>
<hr>
<h3 id="经常-group-by-和-order-by-的列">经常 GROUP BY 和 ORDER BY 的列</h3>
<p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用<code>GROUP BY</code>对数据进行分组查询，或者使用<code>ORDER BY</code>对数据进行排序的时候，就需要对分组或者排序的字段进行索引，从而减少排序的时间。如果待排序的列有多个，那么可以在这些列上建立组合索引。</p>
<h4 id="group-by">GROUP BY</h4>
<p>eg：在100w条数据中，按照<code>student_id</code>对学生选修课程进行分组，显示不同的<code>student_id</code>和课程数量，显示100个。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> student_id ,<span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">AS</span> num
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> student_id <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">INDEX</span> idx_sid <span style="color:#66d9ef">ON</span> student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#66d9ef">FROM</span> student_info
</span></span></code></pre></div><ul>
<li>在不加索引的情况下，耗时850毫秒。</li>
<li>在加索引的情况下（这里使用的是2）当中的<code>idx_sid</code>索引），耗时21毫秒。</li>
</ul>
<h4 id="order-by">ORDER BY</h4>
<p>ORDER BY单独使用的情况与GROUP BY差不多</p>
<h4 id="order-by和group-by同时使用的情况">ORDER BY和GROUP BY同时使用的情况</h4>
<p>==由于<code>GROUP BY</code>先执行，且GROUP BY为先排序再分组，所以主要耗时就集中在GROUP BY上。==</p>
<p><strong>使用以下三种情况来观察不同索引状况下，sql执行的速度差异</strong></p>
<ul>
<li>三种情况：</li>
</ul>
<p>​		①. <code>student_id</code>和<code>create_time</code>分别建立索引</p>
<p>​		②. <code>student_id</code>和<code>create_time</code>建立联合索引，且student_id在前</p>
<p>​		③. <code>student_id</code>和<code>create_time</code>建立联合索引，且create_time在前</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> student_id,<span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>)	<span style="color:#66d9ef">AS</span>	num	
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span>	student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span>	student_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span>	create_time <span style="color:#66d9ef">desc</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">100</span>
</span></span></code></pre></div><p>不加除主键索引以外的其他索引的情况下，耗时约==0.8~1s==</p>
<ul>
<li>两种版本：</li>
</ul>
<p>​		①. MySQL 5.7.5及以上功能依赖检测功能</p>
<p>​		②. MySQL 5.7.5以下无依赖检测功能</p>
<p>执行上方代码后MySQL 5.7.5及以上会报错</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>sql_mode<span style="color:#f92672">=</span>only_full_group_by <span style="color:#f92672">#</span><span style="color:#960050;background-color:#1e0010">出现问题</span>
</span></span></code></pre></div><p>MySQL 5.7.5及以上由于<code>sql_mode=only_full_group_by</code>是默认开启依赖检测功能，所以<code>HAVING</code>条件或<code>ORDER BY</code>列表的查询引用在<code>GROUP BY</code>子句中。
<strong>简单来说就是：输出的结果是叫target list，就是select后面跟着的字段，还有一个地方group by column，就是group by后面跟着的字段。由于开启ONLY_FULL_GROUP_BY的设置，如果一个字段没有在target list和group by字段中同时出现，或者是聚合函数的值的话，那么这条sql查询是被mysql认为非法的，会报错误。</strong></p>
<p>但是如果同时GROUP BY student_id，create_time 这两个字段，就失去了本例的作用。所以需要MySQL 5.7.5及以上的需要关闭依赖检测功能</p>
<p>具体解析链接====》<a href="https://shimo.im/docs/VMAPVynD0nU1vbqg">文档——石墨</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">@@</span><span style="color:#66d9ef">global</span>.sql_mode <span style="color:#f92672">#</span><span style="color:#960050;background-color:#1e0010">查看</span>sql_mode详细
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">set</span> <span style="color:#f92672">@@</span><span style="color:#66d9ef">global</span>.sql_mode <span style="color:#f92672">=</span><span style="color:#e6db74">&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;</span>; <span style="color:#f92672">#</span><span style="color:#960050;background-color:#1e0010">去掉</span>ONLY_FULL_GROUP_BY<span style="color:#960050;background-color:#1e0010">，重新设置值，对于新建的数据库有效</span> <span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">中还要去掉</span>NO_AUTO_CREATE_USER
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">set</span> <span style="color:#66d9ef">global</span> sql_mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;</span>;  <span style="color:#f92672">#</span><span style="color:#960050;background-color:#1e0010">对于已存在的数据库，则需要在对应的数据下执行</span>
</span></span></code></pre></div><p>继续测试</p>
<ol>
<li>
<p>添加单列<code>student_id</code>索引和<code>create_time</code>索引</p>
<p>​	5.7中：</p>
<p>耗时6s左右，添加索引就是将这些时间提前消耗掉，让客户查询的时候减少查询时间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ADD</span> <span style="color:#66d9ef">INDEX</span> idx_sid(student_id);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ADD</span> <span style="color:#66d9ef">INDEX</span> idx_cre_time(create_time <span style="color:#66d9ef">DESC</span>);
</span></span></code></pre></div><p><strong>这里 EXPLAIN 后会发现只使用了student_id 的索引idx_sid（单列索引的情况，只使用语句执行过程第一个索引）所以这里只使用了索引idx_sid，而idx_cre_time压根没用到。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#66d9ef">FROM</span> student_info
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> student_id,<span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>)	<span style="color:#66d9ef">AS</span>	num	
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span>	student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span>	student_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span>	create_time <span style="color:#66d9ef">DESC</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">100</span>;
</span></span></code></pre></div><p>各自单列索引的情况下，耗时大约1.5s（上面不加索引的情况下耗时1s）</p>
<p>​	8.0中</p>
<p>==todo 不明原因，未得到解决，上述方式在5.7中大约需要1.5s左右，而在8.0中需要几分钟的时间。==</p>
</li>
<li>
<p>联合索引的情况① ：</p>
<p>先删除除主键外其他的单列索引</p>
<p><strong>idx_sid_cre_time(student_id,create_time)，student_id在前</strong></p>
<p>​	5.7：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ADD</span> <span style="color:#66d9ef">INDEX</span> idx_sid_cre_time(student_id,create_time);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#66d9ef">FROM</span> student_info;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> student_id,<span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>)	<span style="color:#66d9ef">AS</span>	num	
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span>	student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span>	student_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span>	create_time <span style="color:#66d9ef">DESC</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">100</span>;
</span></span></code></pre></div><p><img src="https://blogimg.ytte.top//img-jixiang/20220306131117.png" alt=""></p>
<p>耗时约==300ms==左右（未加索引1s左右，单列索引1.5s左右）</p>
<p>8.0：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">INDEX</span>  idx_sid <span style="color:#66d9ef">ON</span> student_info ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">INDEX</span>  idx_cre_time <span style="color:#66d9ef">ON</span> student_info;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">INDEX</span>  idx_sid_cre_time <span style="color:#66d9ef">ON</span> student_info;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ADD</span> <span style="color:#66d9ef">INDEX</span> idx_sid_cre_time(student_id,create_time <span style="color:#66d9ef">DESC</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#66d9ef">FROM</span> student_info;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> student_id,<span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>)	<span style="color:#66d9ef">AS</span>	num	
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span>	student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span>	student_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span>	create_time <span style="color:#66d9ef">DESC</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">100</span>;
</span></span></code></pre></div><ul>
<li>
<p>索引不加<code>DESC</code>时，耗时约==800ms==左右（不加索引1s左右，单列索引几分钟）</p>
</li>
<li>
<p>索引加<code>DESC</code>时，耗时约==300ms==左右（不加索引1s左右，单列索引几分钟）</p>
</li>
</ul>
</li>
<li>
<p>联合索引的情况② ：</p>
<p><strong>idx_cre_sid_time(create_time,student_id)，create_time在前</strong></p>
<p>在语句执行中，先进行group by 所以此时如果存在<code>idx_sid(student_id)</code>的话，会优先使用group by student_id的student_id索引（idx_sid），这样就变成了使用单列索引，联合索引idx_sid_cre_time就不起作用了。</p>
<p>如果不存在idx_sid，只有联合索引idx_cre_sid_time：</p>
<p>​    5.7：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">INDEX</span>  idx_sid <span style="color:#66d9ef">ON</span> student_info ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">INDEX</span>  idx_cre_time <span style="color:#66d9ef">ON</span> student_info;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">INDEX</span>  idx_sid_cre_time <span style="color:#66d9ef">ON</span> student_info;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ADD</span> <span style="color:#66d9ef">INDEX</span> idx_cre_sid_time(create_time,student_id);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> student_id,<span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>)	<span style="color:#66d9ef">AS</span>	num	
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span>	student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span>	student_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span>	create_time <span style="color:#66d9ef">DESC</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">100</span>;
</span></span></code></pre></div><p>耗时约==800ms左右== （未加索引1s左右，单列索引1.5s左右，idx_sid_cre_time索引耗时约300ms）</p>
<p>​    8.0 ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">INDEX</span>  idx_sid <span style="color:#66d9ef">ON</span> student_info ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">INDEX</span>  idx_cre_time <span style="color:#66d9ef">ON</span> student_info;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">INDEX</span>  idx_sid_cre_time <span style="color:#66d9ef">ON</span> student_info;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">INDEX</span>  idx_cre_sid_time <span style="color:#66d9ef">ON</span> student_info;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ADD</span> <span style="color:#66d9ef">INDEX</span> idx_cre_sid_time(create_time <span style="color:#66d9ef">DESC</span>,student_id);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> student_id,<span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>)	<span style="color:#66d9ef">AS</span>	num	
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span>	student_info
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span>	student_id
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span>	create_time <span style="color:#66d9ef">DESC</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">100</span>;
</span></span></code></pre></div><ul>
<li>
<p>索引不加<code>DESC</code>时，耗时约==1s==左右（不加索引1s左右，单列索引几分钟，idx_sid_cre_time索引800ms左右）</p>
</li>
<li>
<p>索引加<code>DESC</code>时，耗时约==1s==左右（不加索引1s左右，单列索引几分钟，idx_sid_cre_time索引300ms左右）</p>
</li>
</ul>
</li>
</ol>
<h3 id="updatedelete-的-where-条件列">UPDATE、DELETE 的 WHERE 条件列</h3>
<p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。</p>
<p>原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</strong></p>
<h3 id="distinct-字段需要创建索引">DISTINCT 字段需要创建索引</h3>
<p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p>
<p>比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行</p>
<p>SQL 语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">DISTINCT</span>(student_id) <span style="color:#66d9ef">FROM</span> <span style="color:#f92672">`</span>student_info<span style="color:#f92672">`</span>;
</span></span></code></pre></div><p>运行结果（600637 条记录，运行时间 0.683s ）：</p>
<p>如果我们对 student_id 创建索引，再执行 SQL 语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">DISTINCT</span>(student_id) <span style="color:#66d9ef">FROM</span> <span style="color:#f92672">`</span>student_info<span style="color:#f92672">`</span>;
</span></span></code></pre></div><p>运行结果（600637 条记录，运行时间 0.010s ）：</p>
<p>SQL 查询效率有了提升，同时显示出来的 student_id 还是按照 递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</p>
<h3 id="多表-join-连接操作时创建索引注意事项">多表 JOIN 连接操作时，创建索引注意事项</h3>
<p>首先， ==连接表的数量尽量不要超过 3 张==，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p>
<p>其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p>
<p>最后，==类似字符串和int比较时，会存在隐式转换，即使用了函数，一旦使用了函数就会让索引失效。 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。==比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p>
<p>举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> course_id, name, student_info.student_id, course_name 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">FROM</span> student_info <span style="color:#66d9ef">JOIN</span> course 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">ON</span> student_info.course_id <span style="color:#f92672">=</span> course.course_id 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;462eed7ac6e791292a79&#39;</span>;
</span></span></code></pre></div><p>运行结果（1 条数据，运行时间 0.189s ）：</p>
<p>这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。</p>
<h3 id="使用列的类型小的创建索引">使用列的类型小的创建索引</h3>
<p><img src="https://blogimg.ytte.top//img-jixiang/20220306160740.png" alt=""></p>
<h3 id="使用字符串前缀创建索引">使用字符串前缀创建索引</h3>
<p><img src="https://blogimg.ytte.top//img-jixiang/20220306161326.png" alt=""></p>
<p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> shop(address varchar(<span style="color:#ae81ff">120</span>) <span style="color:#66d9ef">not</span> <span style="color:#66d9ef">null</span>); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> shop <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">index</span>(address(<span style="color:#ae81ff">12</span>)); 
</span></span></code></pre></div><p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字</p>
<p>段的散列度(选择性)会降低。<strong>怎么计算不同的长度的选择性呢？</strong></p>
<p>先看一下字段在全部数据中的选择度：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#66d9ef">distinct</span> address) <span style="color:#f92672">/</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> shop;
</span></span></code></pre></div><p>通过不同长度去计算，与全表的选择性对比：</p>
<p>公式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">count</span>(<span style="color:#66d9ef">distinct</span> <span style="color:#66d9ef">left</span>(<span style="color:#960050;background-color:#1e0010">列名</span>, <span style="color:#960050;background-color:#1e0010">索引长度</span>))<span style="color:#f92672">/</span><span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>)
</span></span></code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#66d9ef">distinct</span> <span style="color:#66d9ef">left</span>(address,<span style="color:#ae81ff">10</span>)) <span style="color:#f92672">/</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">as</span> sub10, <span style="color:#75715e">-- 截取前10个字符的选择度 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">count</span>(<span style="color:#66d9ef">distinct</span> <span style="color:#66d9ef">left</span>(address,<span style="color:#ae81ff">15</span>)) <span style="color:#f92672">/</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">as</span> sub11, <span style="color:#75715e">-- 截取前15个字符的选择度 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">count</span>(<span style="color:#66d9ef">distinct</span> <span style="color:#66d9ef">left</span>(address,<span style="color:#ae81ff">20</span>)) <span style="color:#f92672">/</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">as</span> sub12, <span style="color:#75715e">-- 截取前20个字符的选择度 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">count</span>(<span style="color:#66d9ef">distinct</span> <span style="color:#66d9ef">left</span>(address,<span style="color:#ae81ff">25</span>)) <span style="color:#f92672">/</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">as</span> sub13 <span style="color:#75715e">-- 截取前25个字符的选择度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">from</span> shop;
</span></span></code></pre></div><p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p>
<p><strong>拓展：Alibaba《Java开发手册》</strong></p>
<p>==在 varchar 字段上建立索引时，必须指定索引长度，根据实际文本区分度决定索引长度。==</p>
<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达 90% 以上 ，可以使用</p>
<p><code> count(distinct left(列名, 索引长度))/count(*)</code>的区分度来确定。</p>
<h3 id="区分度高散列性高的列适合作为索引">区分度高(散列性高)的列适合作为索引</h3>
<p><img src="https://blogimg.ytte.top//img-jixiang/20220306161828.png" alt=""></p>
<h3 id="使用最频繁的列放到联合索引的左侧">使用最频繁的列放到联合索引的左侧</h3>
<h3 id="在多个字段都要创建索引的情况下联合索引优于单值索引">在多个字段都要创建索引的情况下，联合索引优于单值索引</h3>
<h2 id="限制索引的数目">限制索引的数目</h2>
<p><img src="https://blogimg.ytte.top//img-jixiang/20220306162540.png" alt=""></p>
<h2 id="哪些情况不适合创建索引"><strong>哪些情况不适合创建索引</strong></h2>
<ol>
<li>WHERE条件（包括GROUP BY、ORDER BY)里用不到的字段不需要创建索引</li>
<li>数据量小的表最好不要使用索引</li>
<li>有大量重复数据的列上不要建立索引
<ul>
<li>比如性别。</li>
</ul>
</li>
<li>避免对经常更新的表创建过多的索引</li>
<li>不建议用无序的值作为索引
<ul>
<li>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</li>
</ul>
</li>
<li>删除不再使用或者很少使用的索引</li>
<li>不要定义冗余或重复的索引</li>
</ol>
<h1 id="性能分析工具的使用">性能分析工具的使用</h1>
<h2 id="数据库服务器的优化步骤">数据库服务器的优化步骤</h2>
<p>视频 p134————<a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=134">尚硅谷</a></p>
<p>一般数据库遇到问题需要调优的时候需要经历一下几个过程。</p>
<p>整个流程划分成观察（show status）和行动（Action）字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。如图：</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/24/164135619.png" alt=""></p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/24/164109224.png" alt=""></p>
<p>mysql优化的效果是随着成本提高而降低的：</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/24/165832459.png" alt=""></p>
<h2 id="查看系统性能参数">查看系统性能参数</h2>
<p>视频 p134 ———— <a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=134&amp;t=356.9">尚硅谷</a></p>
<p>在MySQL中，可以使用 <code>SHOW STATUS</code> 语句查询一些MySQL数据库服务器的 ==性能参数== 、 ==执行频率== 。</p>
<p>语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> [GLOBAL<span style="color:#f92672">|</span>SESSION] STATUS <span style="color:#66d9ef">LIKE</span> <span style="color:#e6db74">&#39;参数&#39;</span>;
</span></span></code></pre></div><table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">意译</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Connections</td>
<td style="text-align:center">连接MySQL服务器的次数</td>
</tr>
<tr>
<td style="text-align:center">Uptime</td>
<td style="text-align:center">MySQL服务器的上线时间</td>
</tr>
<tr>
<td style="text-align:center">Slow_queries</td>
<td style="text-align:center">慢查询的次数</td>
</tr>
<tr>
<td style="text-align:center">Innodb_rows_read</td>
<td style="text-align:center">Select查询返回的行数</td>
</tr>
<tr>
<td style="text-align:center">Innodb_rows_inserted</td>
<td style="text-align:center">执行INSERT操作插入的行数</td>
</tr>
<tr>
<td style="text-align:center">Innodb_rows_updated</td>
<td style="text-align:center">执行UPDATE操作更新的行数</td>
</tr>
<tr>
<td style="text-align:center">Innodb_rows_deleted</td>
<td style="text-align:center">执行DELETE操作删除的行数</td>
</tr>
<tr>
<td style="text-align:center">Com_select</td>
<td style="text-align:center">查询操作的次数</td>
</tr>
<tr>
<td style="text-align:center">Com_insert</td>
<td style="text-align:center">插入操作的次数。对于批量插入的 INSERT 操作，只累加一次</td>
</tr>
<tr>
<td style="text-align:center">Com_update</td>
<td style="text-align:center">更新操作的次数</td>
</tr>
<tr>
<td style="text-align:center">Com_delete</td>
<td style="text-align:center">删除操作的次数</td>
</tr>
</tbody>
</table>
<h2 id="统计sql的查询成本">统计SQL的查询成本</h2>
<p>视频 p134 ———— <a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=134&amp;t=682.4">尚硅谷</a></p>
<p><code>last_query_cost</code>.</p>
<p>需要在原始命令行中输入查询，Navicat中查询的last_query_cost不正确</p>
<p>如果我们想要查询 id=900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：</p>
<p>耗时在0.01s左右</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> student_id, class_id, NAME, create_time <span style="color:#66d9ef">FROM</span> student_info <span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">900001</span>;
</span></span></code></pre></div><p>然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/25/120550457.png" alt=""></p>
<p>如果我们想要查询 id 在 900001 到 9000100 之间的学生记录：</p>
<p>耗时在0.04s左右</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> student_id, class_id, NAME, create_time <span style="color:#66d9ef">FROM</span> student_info <span style="color:#66d9ef">WHERE</span> id <span style="color:#66d9ef">BETWEEN</span> <span style="color:#ae81ff">900001</span> <span style="color:#66d9ef">AND</span> <span style="color:#ae81ff">901000</span>;
</span></span></code></pre></div><p>然后再看下查询优化器的成本，这时我们大概需要进行 400 个页的查询。</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/25/121008968.png" alt=""></p>
<p>你能看到页的数量是刚才的 400 倍，但是查询的效率并没有明显的数量级变化，实际上这两个 SQL 查询的时间基本上一样，<strong>就是因为采用了==顺序读取==的方式将页面一次性加载到缓冲池中，然后再进行查找</strong>。<strong>虽然页数量（last_query_cost）增加了不少 ，但是通过缓冲池的机制，并 没有增加多少查询时间</strong> 。</p>
<p>**使用场景：**它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p>
<h2 id="定位执行慢的sql慢查询日志">定位执行慢的SQL：慢查询日志</h2>
<p>视频 p135————<a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=135">尚硅谷</a></p>
<p>MySQL的慢查询日志，用来记录在MySQL中响==应时间超过阀值==的语句，具体指运行时间超过==long_query._time==值的SQL,则会被记录到慢查询日志中。long_query._time的默认值为==10==，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。</p>
<p>它的主要作用是，帮助我们发现那些执行时间特别长的SQL查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合explain进行全面分析。</p>
<p><strong>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</strong></p>
<p>慢查询日志支持将日志记录写入文件。</p>
<p>myisam中会自动存储一个所有数据的数量的变量，所以与innodb相比，count(*)执行的速度会快于innodb。</p>
<p>补充说明：
除了上述变量，控制慢查询日志的还有一个系统变量：min_examined_row_limit。这个变量的意思是，查询
扫描过的最少记录数。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询
扫描过的记录数大于等于这个变量的值，并且查询执行时间超过long_query_.time的值，那么，这个查询就
被记录到慢查询日志中；反之，则不被记录到慢查询日志中。</p>
<p>这个值默认是0。与long-query_.time=10合在一起，表示只要查询的执行时间超过10秒钟，哪怕一个记录也
没有扫描过，都要被记录到慢查询日志中。你也可以根据需要，通过修改“y.ii”文件，来修改查询时长，或
者通过SET指令，用SQL语句修改“min_examined_.row_limit&quot;的值。</p>
<p>日常开发需注意的结论：
①converting HEAP to MyISAM:查询结果太大，内存不够，数据往磁盘上搬了。
②Creating tmp table：创建临时表。先拷贝数据到l临时表，用完后再删除临时表。
③Copying to tmp table on disk：把内存中临时表复制到磁盘上，警惕！
④1 ocked。
如果在show profilei诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。
注意：
不过SHOW PROFILE命令将被弃用，我们可以从information_schema中的profiling数据表进行查看。</p>
<h2 id="查看sql执行成本show-profile">查看SQL执行成本：show profile</h2>
<h2 id="分析查询语句explain">分析查询语句：explain</h2>
<h3 id="概述">概述</h3>
<p>定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。DESCRIBE语句
的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。
MySQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户
端请求的Qury提供它认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分
最耗费时间)。</p>
<p>这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来
具体执行查询等等。MySQL为我们提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，大家看懂
EXPLAIN语句的各个输出项，可以有针对性的提升我们查询语句的性能。</p>
<p><strong>官网介绍</strong></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a></p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">https://dev.mysql.com/doc/refman/8.0/en/explain-output.html</a></p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/28/130141141.png" alt=""></p>
<p><strong>版本情况</strong></p>
<ul>
<li>
<p>MySQL 5.6.3以前只能 EXPLAIN SELECT ；MYSQL 5.6.3以后就可以 EXPLAIN SELECT，UPDATE， DELETE</p>
</li>
<li>
<p>在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示filtered 需要使用 explain extended 命令。在5.7版本后，默认explain直接显示partitions和 filtered中的信息</p>
</li>
</ul>
<h3 id="基本语法">基本语法</h3>
<p>EXPLAIN 或 DESCRIBE语句的语法形式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> select_options 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#或者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">DESCRIBE</span> <span style="color:#66d9ef">SELECT</span> select_options
</span></span></code></pre></div><p>如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#ae81ff">1</span>;
</span></span></code></pre></div><p>EXPLAIN 语句输出的各个列的作用如下：</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/28/130415755.png" alt=""></p>
<h3 id="数据准备">数据准备</h3>
<h4 id="建表">建表</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#a6e22e">s1</span> (
</span></span><span style="display:flex;"><span>	id <span style="color:#66d9ef">INT</span> <span style="color:#66d9ef">AUTO_INCREMENT</span>,
</span></span><span style="display:flex;"><span>	key1 <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ),
</span></span><span style="display:flex;"><span>	key2 <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>	key3 <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ),
</span></span><span style="display:flex;"><span>	key_part1 <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ),
</span></span><span style="display:flex;"><span>	key_part2 <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ),
</span></span><span style="display:flex;"><span>	key_part3 <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ),
</span></span><span style="display:flex;"><span>	common_field <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> ( id ),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">INDEX</span> <span style="color:#a6e22e">idx_key1</span> ( key1 ),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">UNIQUE</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#a6e22e">idx_key2</span> ( key2 ),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">INDEX</span> <span style="color:#a6e22e">idx_key3</span> ( key3 ),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">INDEX</span> <span style="color:#a6e22e">idx_key_part</span> ( key_part1, key_part2, key_part3 ) 
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">ENGINE</span> <span style="color:#f92672">=</span> INNODB <span style="color:#66d9ef">CHARSET</span> <span style="color:#f92672">=</span> utf8;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#a6e22e">s2</span> (
</span></span><span style="display:flex;"><span>	id <span style="color:#66d9ef">INT</span> <span style="color:#66d9ef">AUTO_INCREMENT</span>,
</span></span><span style="display:flex;"><span>	key1 <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ),
</span></span><span style="display:flex;"><span>	key2 <span style="color:#66d9ef">INT</span>,
</span></span><span style="display:flex;"><span>	key3 <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ),
</span></span><span style="display:flex;"><span>	key_part1 <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ),
</span></span><span style="display:flex;"><span>	key_part2 <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ),
</span></span><span style="display:flex;"><span>	key_part3 <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ),
</span></span><span style="display:flex;"><span>	common_field <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> ( id ),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">INDEX</span> <span style="color:#a6e22e">idx_key1</span> ( key1 ),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">UNIQUE</span> <span style="color:#66d9ef">INDEX</span> <span style="color:#a6e22e">idx_key2</span> ( key2 ),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">INDEX</span> <span style="color:#a6e22e">idx_key3</span> ( key3 ),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">INDEX</span> <span style="color:#a6e22e">idx_key_part</span> ( key_part1, key_part2, key_part3 ) 
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">ENGINE</span> <span style="color:#f92672">=</span> INNODB <span style="color:#66d9ef">CHARSET</span> <span style="color:#f92672">=</span> utf8;
</span></span></code></pre></div><h4 id="设置参数-log_bin_trust_function_creators"><strong>设置参数</strong> <strong>log_bin_trust_function_creators</strong></h4>
<p>创建函数，假如报错，需开启如下命令：允许创建函数设置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">set</span> global log_bin_trust_function_creators<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e"># 不加global只是当前窗口有效。
</span></span></span></code></pre></div><h4 id="创建函数">创建函数</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>DELIMITER <span style="color:#f92672">//</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> FUNCTION <span style="color:#a6e22e">rand_string1</span> ( n <span style="color:#66d9ef">INT</span> ) RETURNS <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">255</span> ) BEGIN
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">DECLARE</span>
</span></span><span style="display:flex;"><span>		chars_str <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">100</span> ) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#e6db74">&#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#39;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">DECLARE</span>
</span></span><span style="display:flex;"><span>		return_str <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">255</span> ) <span style="color:#66d9ef">DEFAULT</span> <span style="color:#e6db74">&#39;&#39;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">DECLARE</span>
</span></span><span style="display:flex;"><span>		i <span style="color:#66d9ef">INT</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">WHILE</span>
</span></span><span style="display:flex;"><span>			i <span style="color:#f92672">&lt;</span> n DO
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">SET</span> return_str <span style="color:#f92672">=</span> <span style="color:#a6e22e">CONCAT</span>(
</span></span><span style="display:flex;"><span>				return_str,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">SUBSTRING</span>( chars_str, <span style="color:#a6e22e">FLOOR</span>( <span style="color:#ae81ff">1</span><span style="color:#f92672">+</span><span style="color:#a6e22e">RAND</span> ()<span style="color:#f92672">*</span> <span style="color:#ae81ff">52</span> ), <span style="color:#ae81ff">1</span> ));
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">SET</span> i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>	END <span style="color:#66d9ef">WHILE</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">RETURN</span> return_str;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>END <span style="color:#f92672">//</span> 
</span></span><span style="display:flex;"><span>DELIMITER;
</span></span></code></pre></div><h4 id="创建存储过程">创建存储过程</h4>
<p>创建往s1表中插入数据的存储过程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>DELIMITER <span style="color:#f92672">//</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">PROCEDURE</span> <span style="color:#a6e22e">insert_s1</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">IN</span> min_num <span style="color:#66d9ef">INT</span> ( <span style="color:#ae81ff">10</span> ),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">IN</span> max_num <span style="color:#66d9ef">INT</span> ( <span style="color:#ae81ff">10</span> )) BEGIN
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">DECLARE</span>
</span></span><span style="display:flex;"><span>		i <span style="color:#66d9ef">INT</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">SET</span> autocommit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">REPEAT</span>
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">SET</span> i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> s1
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">VALUES</span>
</span></span><span style="display:flex;"><span>			(
</span></span><span style="display:flex;"><span>				( min_num <span style="color:#f92672">+</span> i ),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_string1</span> ( <span style="color:#ae81ff">6</span> ),
</span></span><span style="display:flex;"><span>				( min_num <span style="color:#f92672">+</span> <span style="color:#ae81ff">30</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span> ),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_string1</span> ( <span style="color:#ae81ff">6</span> ),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_string1</span> ( <span style="color:#ae81ff">10</span> ),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_string1</span> ( <span style="color:#ae81ff">5</span> ),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_string1</span> ( <span style="color:#ae81ff">10</span> ),
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">rand_string1</span> ( <span style="color:#ae81ff">10</span> ));
</span></span><span style="display:flex;"><span>		UNTIL i <span style="color:#f92672">=</span> max_num 
</span></span><span style="display:flex;"><span>	END <span style="color:#66d9ef">REPEAT</span>;
</span></span><span style="display:flex;"><span>	COMMIT;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>END <span style="color:#f92672">//</span> 
</span></span><span style="display:flex;"><span>DELIMITER;
</span></span></code></pre></div><p>创建往s2表中插入数据的存储过程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>DELIMITER <span style="color:#f92672">//</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">PROCEDURE</span> <span style="color:#a6e22e">insert_s2</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">IN</span> min_num <span style="color:#66d9ef">INT</span> ( <span style="color:#ae81ff">10</span> ),
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">IN</span> max_num <span style="color:#66d9ef">INT</span> ( <span style="color:#ae81ff">10</span> )) BEGIN
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">DECLARE</span>
</span></span><span style="display:flex;"><span>		i <span style="color:#66d9ef">INT</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">SET</span> autocommit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">REPEAT</span>
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">SET</span> i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> s2
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">VALUES</span>
</span></span><span style="display:flex;"><span>			(
</span></span><span style="display:flex;"><span>				( min_num <span style="color:#f92672">+</span> i ),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_string1</span> ( <span style="color:#ae81ff">6</span> ),
</span></span><span style="display:flex;"><span>				( min_num <span style="color:#f92672">+</span> <span style="color:#ae81ff">30</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span> ),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_string1</span> ( <span style="color:#ae81ff">6</span> ),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_string1</span> ( <span style="color:#ae81ff">10</span> ),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_string1</span> ( <span style="color:#ae81ff">5</span> ),
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">rand_string1</span> ( <span style="color:#ae81ff">10</span> ),
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">rand_string1</span> ( <span style="color:#ae81ff">10</span> ));
</span></span><span style="display:flex;"><span>		UNTIL i <span style="color:#f92672">=</span> max_num 
</span></span><span style="display:flex;"><span>	END <span style="color:#66d9ef">REPEAT</span>;
</span></span><span style="display:flex;"><span>	COMMIT;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>END <span style="color:#f92672">//</span> DELIMITER;
</span></span></code></pre></div><h4 id="调用存储过程">调用存储过程</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CALL</span> <span style="color:#a6e22e">insert_s1</span>(<span style="color:#ae81ff">10001</span>,<span style="color:#ae81ff">10000</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">CALL</span> <span style="color:#a6e22e">insert_s2</span>(<span style="color:#ae81ff">10001</span>,<span style="color:#ae81ff">10000</span>);
</span></span></code></pre></div><p>即可完成s1与s2中1w条数据的插入</p>
<h2 id="explain各列作用">EXPLAIN各列作用</h2>
<ol>
<li><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="##table">table</a>：表名</li>
<li><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="##id">id</a>：在一个大的查询语句中每个SELECT关键字都对应一个唯一的id</li>
<li><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="##select_type">select_type</a>：查询的类型</li>
<li><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="##partition(%E7%95%A5)">partition(略)</a>：匹配的分区信息</li>
<li><!-- raw HTML omitted --> <!-- raw HTML omitted --> <a href="##type">type</a>：针对单表的访问方法</li>
<li><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="##possible_keys%E5%92%8Ckey">possible_keys和key</a>：可能用到的索引 和  实际上使用的索引</li>
<li><!-- raw HTML omitted --> <!-- raw HTML omitted --> <a href="##key_len">key_len</a>：实际使用到的索引长度(即：字节数)</li>
<li><!-- raw HTML omitted --> <!-- raw HTML omitted --> <a href="##ref">ref</a>：当使用索引列等值查询时，与索引列进行等值匹配的对象信息。</li>
<li><!-- raw HTML omitted --> <!-- raw HTML omitted --> <a href="##rows">rows</a>：预估的需要读取的记录条数</li>
<li><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="##filtered">filtered</a>: 某个表经过搜索条件过滤后剩余记录条数的百分比</li>
<li><!-- raw HTML omitted --> <!-- raw HTML omitted --><a href="##Extra">Extra</a>:一些额外的信息（更准确的理解MySQL到底将如何执行给定的查询语句）</li>
</ol>
<h3 id="table">table</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">#1. table：表名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#查询的每一行记录都对应着一个单表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#s1:驱动表  s2:被驱动表 （mysql会根据优化器优化，不一定s1:驱动表 s2:被驱动表，有可能反过来）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> s2;
</span></span></code></pre></div><h3 id="id">id</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">#2. id：在一个大的查询语句中每个SELECT关键字都对应一个唯一的id
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> s2
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">ON</span> s1.key1 <span style="color:#f92672">=</span> s2.key1
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">WHERE</span> s1.common_field <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#66d9ef">IN</span> (<span style="color:#66d9ef">SELECT</span> key3 <span style="color:#66d9ef">FROM</span> s2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">UNION</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> s2;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#66d9ef">IN</span> (<span style="color:#66d9ef">SELECT</span> key1 <span style="color:#66d9ef">FROM</span> s2) <span style="color:#66d9ef">OR</span> key3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">######查询优化器可能对涉及子查询的查询语句进行重写,转变为多表查询的操作########
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e"># 子查询的复杂度是n方，多表查询是n+n，所以优化器将能优化成多表查询的子查询给优化了，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e"># 所以这里查询到的id只有1，而不是几个select几个不同的id
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#66d9ef">IN</span> (<span style="color:#66d9ef">SELECT</span> key2 <span style="color:#66d9ef">FROM</span> s2 <span style="color:#66d9ef">WHERE</span> common_field <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#Union去重 union需要建立零时表去组合去重工作，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#所以会多出一行id为空table为&lt;union1,2&gt; select_type为UNION RESULT------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">UNION</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s2;
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#UNION ALL不会创建零时表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1  <span style="color:#66d9ef">UNION</span> <span style="color:#66d9ef">ALL</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s2;
</span></span></code></pre></div><p>id如果相同，可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行</p>
<p>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</p>
<h3 id="select_type">select_type</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">#3. select_type：SELECT关键字对应的那个查询的类型,确定小查询在整个大查询中扮演了一个什么角色
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># 查询语句中不包含`UNION`或者子查询的查询都算作是`SIMPLE`类型---------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#连接查询也算是`SIMPLE`类型--------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> s2;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#对于包含`UNION`或者`UNION ALL`或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#查询的`select_type`值就是`PRIMARY`-----------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#对于包含`UNION`或者`UNION ALL`的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#以外，其余的小查询的`select_type`值就是`UNION`--------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#`MySQL`选择使用临时表来完成`UNION`查询的去重工作，针对该临时表的查询的`select_type`就是
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#`UNION RESULT`-----------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">UNION</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s2;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">UNION</span> <span style="color:#66d9ef">ALL</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s2;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#子查询：-------------------------------------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#如果包含子查询的查询语句不能够转为对应的`semi-join`的形式（子查询会默认转化为多表连接的方式，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#但也有不能转化的情况），并且该子查询是不相关子查询。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e"># in 在非相关子查询中会被优化器转变成多表连接查询，降低复杂度；
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#如下方所说在相关子查询中`select_type`就是`DEPENDENT SUBQUERY`，这时候in会被转变为Exist。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#该子查询的第一个`SELECT`关键字代表的那个查询的`select_type`就是`SUBQUERY`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#66d9ef">IN</span> (<span style="color:#66d9ef">SELECT</span> key1 <span style="color:#66d9ef">FROM</span> s2) <span style="color:#66d9ef">OR</span> key3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#如果包含子查询的查询语句不能够转为对应的`semi-join`的形式，并且该子查询是相关子查询，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#则该子查询的第一个`SELECT`关键字代表的那个查询的`select_type`就是`DEPENDENT SUBQUERY`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#66d9ef">IN</span> (<span style="color:#66d9ef">SELECT</span> key1 <span style="color:#66d9ef">FROM</span> s2 <span style="color:#66d9ef">WHERE</span> s1.key2 <span style="color:#f92672">=</span> s2.key2) <span style="color:#66d9ef">OR</span> key3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#注意的是，select_type为`DEPENDENT SUBQUERY`的查询可能会被执行多次。--------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#在包含`UNION`或者`UNION ALL`的大查询中，如果各个小查询都依赖于外层查询的话，那除了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#最左边的那个小查询之外，其余的小查询的`select_type`的值就是`DEPENDENT UNION`。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#66d9ef">IN</span> (<span style="color:#66d9ef">SELECT</span> key1 <span style="color:#66d9ef">FROM</span> s2 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#66d9ef">UNION</span> <span style="color:#66d9ef">SELECT</span> key1 <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;b&#39;</span>);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#对于包含`派生表`的查询，该派生表对应的子查询的`select_type`就是`DERIVED` （从新生成的表中获取数据）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">FROM</span> (<span style="color:#66d9ef">SELECT</span> key1, <span style="color:#a6e22e">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">AS</span> c <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> key1) <span style="color:#66d9ef">AS</span> derived_s1 <span style="color:#66d9ef">WHERE</span> c <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#该子查询对应的`select_type`属性就是`MATERIALIZED`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#66d9ef">IN</span> (<span style="color:#66d9ef">SELECT</span> key1 <span style="color:#66d9ef">FROM</span> s2); <span style="color:#75715e">#子查询被转为了物化表
</span></span></span></code></pre></div><h3 id="partition略">partition(略)</h3>
<h3 id="type"><strong>type</strong></h3>
<p>system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span> <span style="color:#75715e"># 5. type：针对单表的访问方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当表中`只有一条记录`并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#那么对该表的访问方法就是`system`。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#a6e22e">t</span>(i <span style="color:#66d9ef">INT</span>) <span style="color:#66d9ef">ENGINE</span><span style="color:#f92672">=</span>MYISAM;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t <span style="color:#66d9ef">VALUES</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> t;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#换成InnoDB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#a6e22e">tt</span>(i <span style="color:#66d9ef">INT</span>) <span style="color:#66d9ef">ENGINE</span><span style="color:#f92672">=</span>INNODB;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> tt <span style="color:#66d9ef">VALUES</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> tt;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是`const`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">10005</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#表中key是有索引的，但是这里查询到的是ALL没有索引的情况，原因是，key3是varchar类型，我们给的值是
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#int类型，所以会进行隐式转换，这就会用到函数，一用到函数，索引就会失效，所以显示的为ALL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10066</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#对该被驱动表的访问方法就是`eq_ref`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> s2 <span style="color:#66d9ef">ON</span> s1.id <span style="color:#f92672">=</span> s2.id;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是`ref`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当对普通二级索引进行等值匹配查询，该索引列的值也可以是`NULL`值时，那么对该表的访问方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#就可能是`ref_or_null`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#66d9ef">OR</span> key1 <span style="color:#66d9ef">IS</span> <span style="color:#66d9ef">NULL</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#单表访问方法时在某些场景下可以使用`Intersection`、`Union`、
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#`Sort-Union`这三种索引合并的方式来执行查询
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#二者都是单列索引，默认情况下式使用一个索引，如果是取并集，就会将两个索引合并，index_merge
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#66d9ef">OR</span> key3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#`unique_subquery`是针对在一些包含`IN`子查询的查询语句中，如果查询优化器决定将`IN`子查询
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#转换为`EXISTS`子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的`type`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#列的值就是`unique_subquery`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">WHERE</span> key2 <span style="color:#66d9ef">IN</span> (<span style="color:#66d9ef">SELECT</span> id <span style="color:#66d9ef">FROM</span> s2 <span style="color:#66d9ef">WHERE</span> s1.key1 <span style="color:#f92672">=</span> s2.key1) <span style="color:#66d9ef">OR</span> key3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#如果使用索引获取某些`范围区间`的记录，那么就可能使用到`range`访问方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#66d9ef">IN</span> (<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#同上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#66d9ef">AND</span> key1 <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;b&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是`index`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> key_part2 <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key_part3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#最熟悉的全表扫描
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1;
</span></span></code></pre></div><p>总结：</p>
<p>结果值从最好到最坏依次是：==system &gt; const &gt; eq_ref &gt; ref== &gt; fulltext &gt; ref_or_null &gt; index_merge &gt;unique_subquery &gt; index_subquery &gt; ==range &gt; index &gt; ALL== 其中比较重要的几个提取出来。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴开发手册要求）</p>
<h3 id="possible_keys和key">possible_keys和key</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">#6. possible_keys和key：可能用到的索引 和  实际上使用的索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;z&#39;</span> <span style="color:#66d9ef">AND</span> key3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span></code></pre></div><h3 id="key_len">key_len</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">#7.  key_len：实际使用到的索引长度(即：字节数)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"># 帮你检查`是否充分的利用上了索引`，`值越大越好`,主要针对于联合索引，有一定的参考意义。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">10005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10126</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># varchar 100 utf8一个字符占三个字节，所以是300， 记录真正长度（用来观看查询） 2字节（记录303）， 记录是否为null 1字节 所以303
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#303
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key_part1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#606联合索引的情况下，数字越大查询到的页记录就少，就越精准，所以越大越好
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key_part1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#66d9ef">AND</span> key_part2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;b&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key_part1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#66d9ef">AND</span> key_part2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;b&#39;</span> <span style="color:#66d9ef">AND</span> key_part3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;c&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key_part3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#练习：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#varchar(10)变长字段且允许NULL  = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#char(10)固定字段且允许NULL    = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#char(10)固定字段且不允许NULL  = 10 * ( character set：utf8=3,gbk=2,latin1=1)
</span></span></span></code></pre></div><p>众所周知，记录是以行的形式进行保存的，Mysql5.1以后，行的保存格式默认为Compact格式。行记录Compact格式为：</p>
<p>变长字段NULL标志位记录头信息列1数据列2数据列3数据&hellip;</p>
<p>第一个变长字段是记录这行的总字段长度，如果行记录的字段总长小于255字节，变长字段就占一个字节(一个字节有8位，8位的二进制最多能表示到255)。当大于255时，变长字段的长度就是两个字节。Mysql规定变成字段不超过两个字节，就意味着行的段总长最多不能超过65535个字节(两个字节有16位，16位最多能表示65535)。</p>
<h3 id="ref">ref</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span> <span style="color:#75715e"># 8. ref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#比如只是一个常数或者是某个列。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> s2 <span style="color:#66d9ef">ON</span> s1.id <span style="color:#f92672">=</span> s2.id;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> s2 <span style="color:#66d9ef">ON</span> s2.key1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">UPPER</span>(s1.key1);
</span></span></code></pre></div><h3 id="rows">rows</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e"># 9. rows：预估的需要读取的记录条数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e"># `值越小越好` ，越小，数据就更有可能在同一个叶中，进行的io次数就会越少
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;z&#39;</span>;
</span></span></code></pre></div><h3 id="filtered">filtered</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e"># 10. filtered: 某个表经过搜索条件过滤后剩余记录条数的百分比
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#到对应索引的搜索条件外的其他搜索条件的记录有多少条。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;z&#39;</span> <span style="color:#66d9ef">AND</span> common_field <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#对于单表查询来说，这个filtered列的值没什么意义，我们`更关注在连接查询
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#中驱动表对应的执行计划记录的filtered值`，它决定了被驱动表要执行的次数(即：rows * filtered)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> s2 <span style="color:#66d9ef">ON</span> s1.key1 <span style="color:#f92672">=</span> s2.key1 <span style="color:#66d9ef">WHERE</span> s1.common_field <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span></code></pre></div><h3 id="extra">Extra</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">#11. Extra:一些额外的信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#更准确的理解MySQL到底将如何执行给定的查询语句
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当查询语句的没有`FROM`子句时将会提示该额外信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#查询语句的`WHERE`子句永远为`FALSE`时将会提示该额外信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当我们使用全表扫描来执行对某个表的查询，并且该语句的`WHERE`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#子句中有针对该表的搜索条件时，在`Extra`列中会提示上述额外信息。没有索引的时候显示useing where
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> common_field <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当使用索引访问来执行对某个表的查询，并且该语句的`WHERE`子句中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#有除了该索引包含的列之外的其他搜索条件时，在`Extra`列中也会提示上述额外信息。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#66d9ef">AND</span> common_field <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当查询列表处有`MIN`或者`MAX`聚合函数，但是并没有符合`WHERE`子句中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#的搜索条件的记录时，将会提示该额外信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#a6e22e">MIN</span>(key1) <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;abcdefg&#39;</span>;
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#Select tables optimized away
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#a6e22e">MIN</span>(key1) <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;NlPros&#39;</span>; <span style="color:#75715e">#NlPros 是 s1表中key1字段真实存在的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#select * from s1 limit 10;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#使用覆盖索引的情况下，在`Extra`列将会提示该额外信息。比方说下边这个查询中只
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#需要用到`idx_key1`而不需要回表操作：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> key1,id <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#有些搜索条件中虽然出现了索引列，但却不能使用到索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#看课件理解索引条件下推
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#SELECT FROM s1 WHERE key1 &gt;&#39;z&#39;AND key1 LIKE &#39;%a&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#其中的key1&gt;&#39;z&#39;可以使用到索引，但是key1 LIKE%a&#39;却无法使用到索引，在以前版本的MySQL中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#是按照下边步骤来执行这个查询的：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#1.先根据key1&gt;&#39;z&#39;这个条件，从二级索引1dx_key1中获取到对应的二级索引记录。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#2.根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#key1LIKE&#39;%a&#39;这个条件，将符合条件的记录加入到最后的结果集。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#但是虽然key1 LIKE&#39;%a&#39;不能组成范围区间参与range访问方法的执行，但这个条件毕竟只涉及到了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#key1列，所以MySQL把上边的步骤改进了一下：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#1.先根据key1&gt;&#39;z&#39;这个条件，定位到二级索引idx_key1中对应的二级索引记录。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#2.对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足key1 LIKE&#39;%à&#39;这个条件，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#如果这个条件不满足，则该二级索引记录压根儿就没必要回表。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#3.对于满足key1LIKE&#39;%a&#39;这个条件的二级索引记录执行回表操作。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#我们说回表操作其实是一个随机I0，,比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">##操作的成本。MySQL把他们的这个改进称之为索引条件下推（英文名：Index Condition Pushdown)。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#如果在查询语句的执行过程中将要使用索引条件下推这个特性，在Extra列中将会显示Using index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#condition,比如这样：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">&gt;</span> <span style="color:#e6db74">&#39;z&#39;</span> <span style="color:#66d9ef">AND</span> key1 <span style="color:#66d9ef">LIKE</span> <span style="color:#e6db74">&#39;%a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#其分配一块名叫`join buffer`的内存块来加快查询速度，也就是我们所讲的`基于块的嵌套循环算法`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#见课件说明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> s2 <span style="color:#66d9ef">ON</span> s1.common_field <span style="color:#f92672">=</span> s2.common_field;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当我们使用左（外）连接时，如果`WHERE`子句中包含要求被驱动表的某个列等于`NULL`值的搜索条件，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#而且那个列又是不允许存储`NULL`值的，那么在该表的执行计划的Extra列就会提示`Not exists`额外信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">LEFT</span> <span style="color:#66d9ef">JOIN</span> s2 <span style="color:#66d9ef">ON</span> s1.key1 <span style="color:#f92672">=</span> s2.key1 <span style="color:#66d9ef">WHERE</span> s2.id <span style="color:#66d9ef">IS</span> <span style="color:#66d9ef">NULL</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#如果执行计划的`Extra`列出现了`Using intersect(...)`提示，说明准备使用`Intersect`索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#合并的方式执行查询，括号中的`...`表示需要进行索引合并的索引名称；
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#如果出现了`Using union(...)`提示，说明准备使用`Union`索引合并的方式执行查询；
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#出现了`Using sort_union(...)`提示，说明准备使用`Sort-Union`索引合并的方式执行查询。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">WHERE</span> key1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#66d9ef">OR</span> key3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#当我们的`LIMIT`子句的参数为`0`时，表示压根儿不打算从表中读出任何记录，将会提示该额外信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#有一些情况下对结果集中的记录进行排序是可以使用到索引的。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#比如：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> key1 <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#进行排序，MySQL把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：`filesort`）。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的`Extra`列中显示`Using filesort`提示
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> common_field <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#在执行许多包含`DISTINCT`、`GROUP BY`、`UNION`等子句的查询过程中，如果不能有效利用索引来完成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#查询，MySQL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#计划的`Extra`列将会显示`Using temporary`提示
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">DISTINCT</span> common_field <span style="color:#66d9ef">FROM</span> s1;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#EXPLAIN SELECT DISTINCT key1 FROM s1;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#同上。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> common_field, <span style="color:#a6e22e">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">AS</span> amount <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> common_field;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#执行计划中出现`Using temporary`并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">#我们`最好能使用索引来替代掉使用临时表`。比如：扫描指定的索引idx_key1即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> key1, <span style="color:#a6e22e">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">AS</span> amount <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> key1;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#json格式的explain
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">EXPLAIN</span> FORMAT<span style="color:#f92672">=</span>JSON <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> s1 <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> s2 <span style="color:#66d9ef">ON</span> s1.key1 <span style="color:#f92672">=</span> s2.key2 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> s1.common_field <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span></code></pre></div><p><strong>小结</strong></p>
<ul>
<li>EXPLAIN不考虑各种Cache</li>
<li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li>
<li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li>
<li>部分统计信息是估算的，并非精确值</li>
</ul>
<h2 id="explain的进一步使用">EXPLAIN的进一步使用</h2>
<p><strong>EXPLAIN****四种输出格式</strong></p>
<p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：</p>
<p>传统格式 ， JSON格式 ， TREE格式 以及可 视化输出 。用户可以根据需要选择适用于自己的格式。</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/28/113806179.png" alt=""></p>
<h1 id="索引优化与查询优化">索引优化与查询优化</h1>
<p>todo</p>
<hr>
<p>2022-3-29 19:27:294</p>
<h1 id="数据库的设计规范">数据库的设计规范</h1>
<h2 id="为什么需要数据库设计">为什么需要数据库设计</h2>
<p>数据库的范式设计越高阶，冗余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式(1NF)。在第一范式的基础上进一步满足更多规范要求的称为第二范式(2NF),其余范式以次类推。一般来说，在关系型数据库设计中，最高也就遵循到BCNF,普遍还是3NF。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规侧也就是反规范化。</p>
<h2 id="范-式">范 式</h2>
<h3 id="范式简介">范式简介</h3>
<p>**在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。范式的定义会使用到主键和候选键，数据库中的键(Ky)）由一个或者多个属性组成。</p>
<h3 id="范式都包括哪些">范式都包括哪些</h3>
<p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：<strong>第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</strong></p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/29/105127271.png" alt=""></p>
<h3 id="键和相关属性的概念">键和相关属性的概念</h3>
<p>数据表中常用的几种键和属性的定义：</p>
<ul>
<li><strong>超键</strong>：能唯一标识元组的属性集叫做超键。</li>
<li><strong>候选键</strong>：如果超键不包括多余的属性，那么这个超键就是候选键。</li>
<li><strong>主键</strong>：用户可以从候选键中选择一个作为主键。</li>
<li><strong>外键</strong>：如果数据表R1中的某属性集不是R1的主键，而是另一个数据表R2的主键，那么这个属性集就是数据表R1的外键。</li>
<li><strong>主属性</strong>：包含在任一候选键中的属性称为主属性。</li>
<li><strong>非主属性</strong>：与主属性相对，指的是不包含在任何一个候选键中的属性。</li>
</ul>
<p>通常，我们也将候选键称之为“码”，把主键也称为“主码”。因为键可能是由多个属性组成的，针对单个属性，我
们还可以用主属性和非主属性来进行区分</p>
<p><strong>举例</strong>：</p>
<p>这里有两个表：</p>
<p>球员表(player) ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p>
<p>球队表(team) ：球队编号 | 主教练 | 球队所在地</p>
<ul>
<li>超键 ：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</li>
<li>候选键 ：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li>
<li>主键 ：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li>
<li>外键 ：球员表中的球队编号。</li>
<li>主属性 、 非主属性 ：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。</li>
</ul>
<h3 id="第一范式1st-nf">第一范式(1st NF)</h3>
<p>第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为不可再次拆分的最小数据单元。我们在设计某个字段的时候，对于字段X来说，不能把字段X拆分成字段X-1和字段X-2。事实上，任何的DBMS都会满足第一范式的要求，不会将字段进行拆分。</p>
<p><strong>举例1</strong>：</p>
<p>假设一家公司要存储员工的姓名和联系方式。它创建一个如下表：</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/29/110122773.png" alt=""></p>
<p>该表不符合 1NF ，因为规则说“表的每个属性必须具有原子（单个）值”，lisi和zhaoliu员工的emp_mobile 值违反了该规则。为了使表符合 1NF ，我们应该有如下表数据：</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/29/111655103.png" alt=""></p>
<p>属性的原子性是 <strong>主观的</strong> 。例如，城市全称是否需要分开呢？答案取决于业务。</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/29/111911758.png" alt=""></p>
<h3 id="第二范式2nd-nf">第二范式(2nd NF)</h3>
<p>第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的（要有主键）。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。**如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。(要求中的主键，其实可以拓展替换为候选键)。</p>
<p>==举例1==：</p>
<p><strong>成绩表</strong> （学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课程号也不能决定成绩，所以（学号，课程号）→成绩 就是 <strong>完全依赖关系</strong> 。</p>
<p>==举例2==：</p>
<p><strong>比赛表 player_game</strong> ，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：</p>
<pre tabindex="0"><code>(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)
</code></pre><p>但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：</p>
<p>姓名年龄完全取决于球员编号，和比赛编号没有关系，同理比赛时间, 比赛场地。</p>
<pre tabindex="0"><code>(球员编号) → (姓名，年龄)       
(比赛编号) → (比赛时间, 比赛场地)
</code></pre><p>对于非主属性来说，并非完全依赖候选键。这样会产生一下问题：</p>
<ul>
<li><strong>数据冗余</strong> ：</li>
</ul>
<p>如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。</p>
<ul>
<li>
<p><strong>插入异常</strong> ：</p>
<p>如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。</p>
</li>
<li>
<p><strong>删除异常</strong> ：</p>
<p>如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删除掉。</p>
</li>
<li>
<p><strong>更新异常</strong> ：</p>
<p>如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调整，否则就会出现一场比赛时间不同的情况。</p>
</li>
</ul>
<p>因此我们可以把球员比赛表设计为下面的三张表：</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/29/113642078.png" alt=""></p>
<blockquote>
<p>1NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，一张表只表达一个意思。</p>
</blockquote>
<h3 id="第三范式3rdnf">第三范式(3rdNF)</h3>
<p>第三范式是在第二范式的基础上，要求数据表中<strong>不能存有非主属性A依赖于非主属性B,非主属性B依赖于主键C的情况，即存在“A→B→C”的决定关系)</strong>，通俗地讲，==所有非主键属性之间不能有依赖关系，必须相互独立。==</p>
<p>这里的主键可以拓展为候选键。</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/29/152705367.png" alt=""></p>
<p>商品类别名称依赖于商品类别编号，不符合第三范式。</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/29/152856070.png" alt=""></p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/29/152944753.png" alt=""></p>
<p>符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括：“每个非键属性依赖于键，依赖于整个键，并且除了键别无他物”。</p>
<h3 id="小结">小结</h3>
<p>关于数据表的设计，有三个范式要遵循。</p>
<ol>
<li>
<p>第一范式(1NF),==确保每列保持原子性==
数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</p>
</li>
<li>
<p>第二范式(2NF),==确保每列都和主键完全依赖==</p>
<p>尤其在复合主键的情况下，非主键部分不应该依赖于部分主键。</p>
</li>
<li>
<p>第三范式(3NF)==确保每列都和主键列直接相关，而不是间接相关==</p>
</li>
<li>
<p><strong>范式的优点</strong>：数据的标准化有助于消除数据库中的<strong>数据冗余</strong>，第三范式(3N)通常被认为在性能、扩展性和数据完整性方面达到了最好的平衡。</p>
</li>
<li>
<p><strong>范式的缺点</strong>：范式的使用，<strong>可能降低查询的效率</strong>。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。</p>
</li>
</ol>
<h3 id="反范式化">反范式化</h3>
<p>视频 p153——<a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=153">尚硅谷</a></p>
<p>有的时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这时候，我们就要**遵循业务优先的原则，首先满足业务需求，再尽量减少冗余。**顶多违反第二三范式，第一范式还是要遵循的。</p>
<p>如果数据库中的数据量比较大，系统的UV和PV访问频次比较高，三大范式在一定程度上会影响数据库的读性能。因此反范式优化也是一种优化思路。此时，<strong>可以通过在数据表中增加冗余字段来提高数据库的读性能。</strong></p>
<blockquote>
<ol>
<li>为满足某种商业目标 , 数据库性能比规范化数据库更重要</li>
<li>在数据规范化的同时 , 要综合考虑数据库的性能</li>
<li>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</li>
<li>通过在给定的表中插入计算列，以方便查询</li>
</ol>
</blockquote>
<ul>
<li>
<p><strong>举例1</strong>：</p>
<p>第三范式当中举例，如果需要经常查询商品的名称，大可将增加冗余的字段商品名称。</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/29/152705367.png" alt=""></p>
</li>
</ul>
<h4 id="反范式的新问题"><strong>反范式的新问题</strong></h4>
<ul>
<li>存储 空间变大 了</li>
<li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 <strong>数据不一致</strong></li>
<li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 <strong>消耗系统资源</strong></li>
<li>在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加 <strong>复杂</strong></li>
</ul>
<h4 id="反范式的适用场景"><strong>反范式的适用场景</strong></h4>
<p>当冗余信息有价值或者能 <strong>大幅度提高查询效率</strong> 的时候，我们才会采取反范式的优化。</p>
<ol>
<li>
<p><strong>增加冗余字段的建议</strong></p>
<p>只有满足这两个条件，才可以考虑增加==冗余字段==。</p>
<ul>
<li>这个冗余字段==不需要经常进行修改；==</li>
<li>这个冗余字段==查询的时候不可或缺。==</li>
</ul>
</li>
<li>
<p><strong>历史快照、历史数据的需要</strong></p>
</li>
</ol>
<p>在现实生活中，我们经常需要一些冗余信息，比如<strong>订单中的收货人信息，包括姓名、电话和地址等</strong>。每次发生的 <strong>订单收货信息</strong> 都属于<strong>历史快照</strong> ，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p>
<blockquote>
<p>反范式优化也常用在 <strong>数据仓库</strong>的设计中，因为数据仓库通常 存储历史数据 ，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p>
<p>我简单总结下数据仓库和数据库在使用上的区别：</p>
<ul>
<li>
<p>数据库设计的目的在于<strong>捕获数据</strong>，而数据仓库设计的目的在于<strong>分析数据</strong>；</p>
</li>
<li>
<p>数据库对数据的<strong>增删改实时性</strong>要求强，需要存储在线的用户数据，而数据仓库存储的一般是历史数据：</p>
</li>
<li>
<p>数据库设计需要<strong>尽量避免冗余</strong>，但为了提高查询效率也允许一定的<strong>冗余度</strong>，而数据仓库在设计上更偏向采用反范式设计</p>
</li>
</ul>
</blockquote>
<h3 id="bcnf巴斯范式">BCNF(巴斯范式)</h3>
<p>视频 p154 ———— <a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=154">尚硅谷</a></p>
<p>巴斯范式(BCNF),也叫做巴斯-科德范式(Boyce-Codd Normal Form)。BCNF被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是修正的第三范式。</p>
<p><strong>若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BC范式。</strong></p>
<p>一般来说，一个数据库设计符合3NF或BCNF就可以了。</p>
<p><strong>举例1</strong>：</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/29/200754811.png" alt=""></p>
<p>在这个表中，一个仓库只有一个管理员，同时一个管理员也只管理一个仓库。我们先来梳理下这些属性之间的依赖关系。</p>
<p>仓库名决定了管理员，管理员也决定了仓库名，同时（仓库名，物品名）的属性集合可以决定数量这个属性。这样，我们就可以找到数据表的候选键。</p>
<ul>
<li><strong>候选键</strong> ：是（管理员，物品名）和（仓库名，物品名），然后我们从候选键中选择一个作为 主键 ，比如（仓库名，物品名）。</li>
<li><strong>主属性</strong> ：包含在任一候选键中的属性，也就是仓库名，管理员和物品名。</li>
<li><strong>非主属性</strong> ：数量这个属性。</li>
</ul>
<p><strong>符合三范式</strong></p>
<p>我们需要根据范式的等级，从低到高来进行判断。</p>
<ul>
<li>首先，数据表每个属性都是原子性的，符合 1NF 的要求；</li>
<li>其次，数据表中非主属性”数量“都与候选键全部依赖，（仓库名，物品名）决定数量，（管理员，物品名）决定数量。因此，数据表符合 2NF 的要求；</li>
<li>最后，数据表中的非主属性，不传递依赖于候选键。因此符合 3NF 的要求。</li>
</ul>
<p><strong>存在的问题</strong></p>
<ul>
<li>增加一个仓库，但是还没有存放任何物品。根据数据表实体完整性的要求，主键不能有空值，因此会出现 插入异常 ；</li>
<li>如果仓库更换了管理员，我们就可能会 修改数据表中的多条记录 ；</li>
<li>如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除。</li>
</ul>
<p>即便数据表符合 3NF 的要求，同样可能存在插入，更新和删除数据的异常情况。</p>
<p><strong>问题解决</strong></p>
<p>首先我们需要确认造成异常的原因：==<strong>主属性</strong>仓库名<strong>对于候选键</strong>（管理员，物品名）<strong>是部分依赖的关系</strong>，这样就有可能导致上面的异常情况。因此引入BCNF，它在3NF的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。==</p>
<p>如果在关系R中，U为主键，B属性是主键的一个属性，若存在B-&gt;A，A为主属性，则该关系不属于BCNF。</p>
<p>根据 BCNF 的要求，我们需要把仓库管理关系 warehouse_keeper 表拆分成下面这样：</p>
<ul>
<li>
<p>仓库表 ：（仓库名，管理员）</p>
</li>
<li>
<p>库存表 ：（仓库名，物品名，数量）</p>
</li>
</ul>
<p>这样就不存在主属性对于候选键的部分依赖或传递依赖，上面数据表的设计就符合 BCNF。</p>
<h3 id="第四范式">第四范式</h3>
<p>todo</p>
<h3 id="第五范式域键范式">第五范式、域键范式</h3>
<p>todo</p>
<h3 id="实战案例">实战案例</h3>
<p>视频 p155 ———— <a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=155">尚硅谷</a></p>
<p>商超进货系统中的进货单表进行剖析：</p>
<p>进货单表：</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/29/202241513.png" alt=""></p>
<p>这个表中的字段很多，表里的数据量也很惊人。大量重复导致表变得庞大，效率极低。如何改造？</p>
<p>在实际工作场景中，这种由于数据表结构设计不合理，而导致的数据重复的现象并不少见。往往是系统虽然能够运行，承载能力却很差，稍微有点流量，就会出现内存不足、CUP使用率飙升的情况，甚至会导致整个项目失败。</p>
<hr>
<p>2022-3-30</p>
<h2 id="er模型">ER模型</h2>
<p>视频 p156 ———— <a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=156&amp;spm_id_from=pageDriver">尚硅谷</a></p>
<p>数据库设计是牵一发而动全身的。那有没有什么办法提前看到数据库的全貌呢？比如需要哪些数据表、
数据表中应该有哪些字段，数据表与数据表之间有什么关系、通过什么字段进行连接，等等。这样我们才能进行整体的梳理和设计。</p>
<p>其实，ER模型就是一个这样的工具。ER模型也叫作<strong>实体关系模型</strong>，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。<strong>在开发基于数据库的信息系统的设计阶段，通常使用E模型来描述信息需求和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。</strong></p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/30/105325124.png" alt=""></p>
<p>特别说明：</p>
<p>==工作中数据库最好不要用外键，如上所说非常影响性能，我们可以采取应用层面数据的一致性检查：例如选课系统，如果数据库中不做外键处理，我们可以在前端后端做校验处理，让用户只能输入相应的课程（或者采用下拉菜单选择的方式选择），从而实现外键的作用。==</p>
<h2 id="设计原则">设计原则</h2>
<p>三少一多：</p>
<ul>
<li><strong>数据==表的个数==越少越好</strong>
RDBMS的核心在于对实体和联系的定义，也就是E-R图(Entity Relationship Diagram),数据表越少，证明实体
和联系设计得越简洁，既方便理解又方便操作。</li>
<li><strong>数据表中的==字段==个数越少越好</strong>
字段个数越多，数据沉余的可能性越大。设置字段个数少的前提是各个字段相互独立，而不是某个字段的取值可
以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。</li>
<li><strong>数据表中==联合主键的字段==个数越少越好</strong>
设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式（也就是用多个字
段来定义一个主键)。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间
和索引空间，因此联合主键的字段个数越少越好。</li>
<li><strong>使用==主键和代码逻辑层外键关系（不是外键约束）==越多越好</strong>
数据库的设计实际上就是定义各种表，以及各种字段之间的关系。这些关系越多，证明这些实体之间的冗余度越
低，利用度越高。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率。</li>
</ul>
<p>“三少一多”原则的核心就是简单可复用。简单指的是用更少的表、更少的字段、更少的联合主键字段来完成数据
表的设计。可复用则是通过主键、外键的使用来增强数据表之间的复用率。因为一个主键可以理解是一张表的代
表。键设计得越多，证明它们之间的利用率越高。</p>
<h2 id="数据对象的编写建议">数据对象的编写建议</h2>
<p>todo</p>
<h2 id="数据库对象编写建议">数据库对象编写建议</h2>
<p>todo</p>
<h1 id="事务">事务</h1>
<h2 id="事务概述">事务概述</h2>
<h3 id="存储引擎支持情况">存储引擎支持情况</h3>
<p>SHOW ENGINES 命令来查看MySQL 中，只有InnoDB 是支持事务的。</p>
<h3 id="基本概念">基本概念</h3>
<p>**事务：**一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p>**事务处理的原则：**保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。</p>
<h3 id="事务的acid特性">事务的ACID特性</h3>
<ul>
<li>
<p><strong>原子性（atomicity）</strong>：</p>
<p>原子性是指==事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。==</p>
</li>
<li>
<p><strong>一致性（consistency）</strong>：</p>
<p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对<strong>Consistency</strong>的阐述）根据定义，一致性是指事务执行前后，数据从一个 合法性状态 变换到另外一个 合法性状态 。这种状态是 语义上 的而不是语法上的，跟具体的业务有关。通俗的说，就是==事务前后数据状态符合事实约束，符合常理==</p>
<p>那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p>
<ul>
<li>举例1：A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须&gt;0。</li>
<li>举例2：A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时数据是不一致的，为什么呢？因为你定义了一个状态，要求A+B的总余额必须不变。</li>
<li>举例3：在数据表中我们将姓名字段设置为唯一性约束，这时当事务进行提交或者事务发生回滚的时候，如果数据表中的姓名不唯一，就破坏了事务的一致性要求。</li>
</ul>
</li>
<li>
<p><strong>隔离型（isolation）</strong>：</p>
<p>事务的隔离性是指一个==事务的执行不能被其他事务干扰== ，即一个事务内部的操作及使用的数据对 并发 的</p>
<p>其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50</p>
<p>元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">UPDATE</span> accounts <span style="color:#66d9ef">SET</span> money <span style="color:#f92672">=</span> money <span style="color:#f92672">-</span> <span style="color:#ae81ff">50</span> <span style="color:#66d9ef">WHERE</span> NAME <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;AA&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">UPDATE</span> accounts <span style="color:#66d9ef">SET</span> money <span style="color:#f92672">=</span> money <span style="color:#f92672">+</span> <span style="color:#ae81ff">50</span> <span style="color:#66d9ef">WHERE</span> NAME <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;BB&#39;</span>;
</span></span></code></pre></div><p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/30/121637994.png" alt=""></p>
</li>
<li>
<p><strong>持久性（durability）</strong>：</p>
</li>
</ul>
<p>持久性是指一个==事务一旦被提交，它对数据库中数据的改变就是 永久性的==，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
<p>==持久性是通过 事务日志 来保证的==。日志包括了 <strong>重做日志</strong> 和 <strong>回滚日志</strong> 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性</p>
<blockquote>
<p>==原子性是基础，隔离性是手段，1一致性是约束条件，而持久性是我们的目的。==</p>
</blockquote>
<h3 id="事务的状态"><strong>事务的状态</strong></h3>
<p>我们现在知道 事务 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把 事务 大致划分成几个状态：</p>
<ul>
<li>
<p>活动的（active）
事务对应的数据库操作正在执行过程中时，我们就说该事务处在 活动的 状态。</p>
</li>
<li>
<p>部分提交的（partially committed）
当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 没有刷新到磁盘时，我们就说该事务处在 部分提交的 状态。</p>
</li>
<li>
<p>失败的（failed）
当事务处在 活动的 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失 败的 状态。</p>
</li>
<li>
<p>中止的（aborted）
如果事务执行了一部分而变为 失败的 状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 回滚 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 中止的 状态。</p>
</li>
<li>
<p>提交的（committed）
当一个处在 部分提交的 状态的事务将修改过的数据都 同步到磁盘 上之后，我们就可以说该事务处在了 提交的 状态。</p>
</li>
</ul>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/03/30/150921666.png" alt=""></p>
<h2 id="使用事务">使用事务</h2>
<p>分别为 显式事务 和 隐式事务 。</p>
<h3 id="显示事务">显示事务</h3>
<ol>
<li><strong>步骤1</strong>： START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span> BEGIN; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#或者 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>mysql<span style="color:#f92672">&gt;</span> START TRANSACTION;
</span></span></code></pre></div><p><code>START TRANSACTION</code> 语句相较于 <code>BEGIN </code>特别之处在于，后边能跟随几个 修饰符 ：</p>
<ul>
<li>
<p><code>READ ONLY</code>：标识当前事务是一个 只读事务 ，也就是属于该事务的数据库操作只能读取数据，而不
能修改数据。</p>
<blockquote>
<p>补充：只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用
CREATE TMEPORARY TABLE创建的表)，由于它们只能在当前会话中可见，所以只读事务其实也是可以对临时表进行增、删、改操作的。</p>
</blockquote>
</li>
<li>
<p><code>READ WRITE</code>：标识当前事务是一个 读写事务 ，也就是属于该事务的数据库操作既可以读取数据，
也可以修改数据。</p>
</li>
<li>
<p><code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。</p>
</li>
</ul>
<ol start="2">
<li>
<p><strong>步骤2</strong>：一系列事务中的操作（==主要是DML，不含DDL==）</p>
</li>
<li>
<p><strong>步骤3</strong>：提交事务 或 中止事务（即回滚事务）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e"># 提交事务。当提交事务后，对数据库的修改是永久性的。 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>mysql<span style="color:#f92672">&gt;</span> COMMIT;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 回滚事务。即撤销正在进行的所有没有提交的修改 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>mysql<span style="color:#f92672">&gt;</span> ROLLBACK;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 将事务回滚到某个保存点。 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>mysql<span style="color:#f92672">&gt;</span> ROLLBACK <span style="color:#66d9ef">TO</span> [SAVEPOINT]
</span></span></code></pre></div><p>其中SAVEPOINT（关键点，使得不用全部回滚）相关操作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#75715e">#在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>SAVEPOINT <span style="color:#960050;background-color:#1e0010">保存点名称；</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#朋除某个保存点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">RELEASE</span> SAVEPOINT <span style="color:#960050;background-color:#1e0010">保存点名称：</span>
</span></span></code></pre></div></li>
</ol>
<h3 id="隐式事务"><strong>隐式事务</strong></h3>
<p>MySQL中有一个系统变量 autocommit ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">SHOW</span> VARIABLES <span style="color:#66d9ef">LIKE</span> <span style="color:#e6db74">&#39;autocommit&#39;</span>; 
</span></span><span style="display:flex;"><span><span style="color:#f92672">+---------------+-------+</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> Variable_name <span style="color:#f92672">|</span> Value <span style="color:#f92672">|</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">+---------------+-------+</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> autocommit    <span style="color:#f92672">|</span> <span style="color:#66d9ef">ON</span>    <span style="color:#f92672">|</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">+---------------+-------+</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> row <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">set</span> (<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">01</span> sec)
</span></span></code></pre></div><p>默认情况下，如果我们不显式的使用START TRANSACTION或者BEGIN语句开启一个事务，那么<strong>每一条语句都算是一个独立的事务</strong>，这种特性称之为事务的<strong>自动提交</strong>。</p>
<p>若想不自动提交，就使用显示事务（ <code>START TRANSACTION</code> 或者 <code>BEGIN</code>）并且关闭 自动提交：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> autocommit <span style="color:#f92672">=</span> OFF; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#或
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">SET</span> autocommit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span></code></pre></div><p>我们显式的写出C0MMIT语句来把这个事务提交掉，或者显式的写出ROLLBACK语句来把这个事务回滚掉。</p>
<h3 id="隐式提交数据的情况">隐式提交数据的情况</h3>
<ul>
<li>
<p>数据定义语言（Data definition language，缩写为：DDL）</p>
</li>
<li>
<p>隐式使用或修改mysql数据库中的表</p>
<p>当我们使用<code>ALTER USER、CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD</code>等语句时也会隐式的提交前边语句所属于的事务。</p>
</li>
<li>
<p>事务控制或关于锁定的语句</p>
<ul>
<li>
<p>当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了
另一个事务时，会 隐式的提交 上一个事务。</p>
</li>
<li>
<p>当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交 前边语
句所属的事务。</p>
</li>
<li>
<p>使用<code>LOCK TABLES</code> 、 <code>UNLOCK TABLES </code>等关于锁定的语句也会 隐式的提交 前边语句所属的事</p>
<p>务。</p>
</li>
</ul>
</li>
<li>
<p>加载数据的语句</p>
<p>使用<code>LOAD DATA</code>语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。</p>
</li>
<li>
<p>关于MySQL复制的一些语句</p>
<p>使用<code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code>等语句时会隐式的提交前边语句所属的事务。</p>
</li>
<li>
<p>其它的一些语句</p>
<p>使用<code>ANALYZE TABLE</code>、<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、<code>LOAD INDEX INTO CACHE</code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET</code>等语句也会隐式的提交前边语句所属的事务。</p>
</li>
</ul>
<hr>
<p>2022-4-1</p>
<h3 id="使用举例1提交与回滚">使用举例1：提交与回滚</h3>
<p>事务执行参数completion._type：</p>
<p>MySQL中<code>completion._type</code>参数的作用，实际上这个参数有3种可能：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> <span style="color:#f92672">@@</span>completion_type <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span></code></pre></div><ol>
<li>completion=0（NO CHAIN），这是<strong>默认情况</strong>。当我们执行COMMIT的时候会提交事务，在执行下一个事务时，还需要使 用START TRANSACTION或者BEGIN来开启.</li>
<li>completion=1，这种情况下，当我们提交事务后，相当于执行了COMMIT AND CHAIN，也就是开启一个 链式事务，即当我们提交事务之后会开启一个相同隔离级别的事务。</li>
<li>completion=2，这种情况下COMMIT=COMMIT AND RELEASE，也就是当我们提交后，会自动与服务器断 开连接。</li>
</ol>
<blockquote>
<p>当我们设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。</p>
<p>当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。</p>
</blockquote>
<h2 id="事务的隔离级别">事务的隔离级别</h2>
<p>视频 p164 ———— <a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=164&amp;spm_id_from=pageDriver">尚硅谷</a></p>
<p><strong>MySQL是一个 客户端／服务器 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个会话（ Session ）</strong>。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务有 隔离性 的特性，理论上在某个事务 对某个数据进行访问 时，其他事务应该进行 排 队 ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 性能影太大 ，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 性能尽量高些 ，那就看二者如何权衡取舍了。</p>
<h3 id="数据准备-1">数据准备</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#a6e22e">student</span> ( 
</span></span><span style="display:flex;"><span>	studentno <span style="color:#66d9ef">INT</span>, 
</span></span><span style="display:flex;"><span>    NAME <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">20</span> ), 
</span></span><span style="display:flex;"><span>	class <span style="color:#66d9ef">VARCHAR</span> ( <span style="color:#ae81ff">20</span> ), 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> ( studentno ) 
</span></span><span style="display:flex;"><span>) <span style="color:#66d9ef">ENGINE</span> <span style="color:#f92672">=</span> INNODB <span style="color:#66d9ef">CHARSET</span> <span style="color:#f92672">=</span> utf8;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> student <span style="color:#66d9ef">VALUES</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;小谷&#39;</span>, <span style="color:#e6db74">&#39;1班&#39;</span>);
</span></span></code></pre></div><h3 id="数据并发问题">数据并发问题</h3>
<p>下访问相同数据的事务在 不保证串行执行 （也就是执行完一个再执行另一个）的情况下可能会出现哪些问题：</p>
<ul>
<li>脏写（ Dirty Write ）</li>
<li>脏读（ Dirty Read ）</li>
<li>不可重复读（ Non-Repeatable Read ）</li>
<li>幻读（ Phantom ）</li>
</ul>
<h4 id="脏写">脏写</h4>
<p><strong>对于两个事务 Session A、Session B，如果事务Session A 修改了 另一个 未提交 事务Session B 修改过 的数据，那就意味着发生了 脏写</strong></p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/04/01/101812514.png" alt=""></p>
<h4 id="脏读">脏读</h4>
<p>对于两个事务 Session A、Session B，<strong>Session A 读取 了已经被 Session B 更新 但还 没有被提交 的字段。</strong>
<strong>之后若 Session B 回滚 ，Session A 读取 的内容就是 临时且无效 的。</strong></p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/04/01/103711344.png" alt=""></p>
<p>Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为&rsquo;张三&rsquo;，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为&rsquo;张三&rsquo;，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为 脏读 。</p>
<h4 id="不可重复读">不可重复读</h4>
<p><strong>(简单系统往往视为正常，并发系统中不可重复读是个问题)对于两个事务Session A、Session B，Session A 读取 了一个字段，然后 Session B 更新 了该字段。 之后Session A 再次读取 同一个字段， 值就不同 了。那就意味着发生了不可重复读。</strong></p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/04/01/104032961.png" alt=""></p>
<p>我们在Session B中提交了几个 隐式事务 （注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为 不可重复读 。</p>
<h4 id="幻读">幻读</h4>
<p><strong>对于两个事务Session A、Session B, Session A 从一个表中 读取 了一个字段, 然后 Session B 在该表中 插 入 了一些新的行。 之后, 如果 Session A 再次读取 同一个表, 就会多出几行。那就意味着发生了幻读。</strong></p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/04/01/104356458.png" alt=""></p>
<p>Session A中的事务先根据条件 studentno &gt; 0这个条件查询表student，得到了name列值为&rsquo;张三&rsquo;的记录；之后Session B中提交了一个 <strong>隐式事务</strong> ，该事务向表student中插入了一条新记录；之后Session A中的事务再根据相同的条件 studentno &gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为 <strong>幻读</strong> 。我们把新插入的那些记录称之为 <strong>幻影记录</strong> 。</p>
<h4 id="注意1">注意1</h4>
<p>有的同学会有疑问，那如果Session B中删除了一些符合studentno&gt;g的记录而不是插入新记录，那Session A 之后再根据studentno&gt;0的条件读取的<strong>记录变少了</strong>，这种现象算不算幻读呢？<strong>这种现象不属于幻读，幻读强 调的是多了记录。</strong></p>
<h4 id="注意2">注意2</h4>
<p><strong>那对于先前已经读到的记录，之后又读取不到这种情况相当于对每一条记录都发生了 不可重复读的 现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。</strong></p>
<h3 id="sql中的四种隔离级别">SQL中的四种隔离级别</h3>
<p>严重性来排序：脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读。</p>
<p>隔离性和性能都要兼顾。设立一些隔离级别，隔离级别越低，并发问题发生的就越多。</p>
<p>SQL标准 中设立了4个 隔离级别 ： (<strong>以下4种隔离级别都解决的脏写的问题</strong>)</p>
<ul>
<li><code>READ UNCOMMITTED </code>：<strong>读未提交</strong>，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。<strong>不能避免脏读、不可重复读、幻读。</strong></li>
<li><code>READ COMMITTED </code>：<strong>读已提交</strong>，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。<strong>可以避免脏读，但不可重复读、幻读问题仍然存在。</strong></li>
<li><code>REPEATABLE READ</code> ：<strong>可重复读</strong>，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。<strong>可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</strong></li>
<li><code>SERIALIZABLE </code>：<strong>可串行化</strong>，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但<strong>性能十分低下</strong>。<strong>能避免脏读、不可重复读和幻读。</strong></li>
</ul>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/04/01/103524510.png" alt=""></p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/04/01/110118281.png" alt=""></p>
<h3 id="mysql支持的四种隔离级别">MySQL支持的四种隔离级别</h3>
<p>视频 p165 ———— <a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=165&amp;spm_id_from=pageDriver">尚硅谷</a></p>
<ul>
<li>
<p>Oracle就只支持READ COMMITTED(默认隔离级别)和SERIALIZABLE隔离级别。</p>
</li>
<li>
<p>MySQL虽然支持4种隔离级别，但与SQL标准中所规定的各级隔离级别 允许发生的问题却有些出入，MySQL在 REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的，禁止幻读 的原因在<a href="##%E4%BB%80%E4%B9%88%E6%98%AFMVCC">后面的章节中</a>。</p>
</li>
</ul>
<p><strong>查看隔离级别</strong>：</p>
<ul>
<li>
<p>MySQL 5.7.20版本之前</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> VARIABLES <span style="color:#66d9ef">LIKE</span> <span style="color:#e6db74">&#39;tx_isolation&#39;</span>;
</span></span></code></pre></div></li>
<li>
<p>MySQL 5.7.20版本之后</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> VARIABLES <span style="color:#66d9ef">LIKE</span> <span style="color:#e6db74">&#39;transaction_isolation&#39;</span>;
</span></span></code></pre></div></li>
<li>
<p>或者不同MySQL版本中都可以使用的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">@@</span>transaction_isolation; 
</span></span></code></pre></div></li>
</ul>
<h3 id="如何设置事务的隔离级别">如何设置事务的隔离级别</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> [GLOBAL<span style="color:#f92672">|</span>SESSION] TRANSACTION_ISOLATION <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;隔离级别&#39;</span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#其中，隔离级别格式： 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">READ</span><span style="color:#f92672">-</span>UNCOMMITTED 
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">READ</span><span style="color:#f92672">-</span>COMMITTED 
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> REPEATABLE<span style="color:#f92672">-</span><span style="color:#66d9ef">READ</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> SERIALIZABLE
</span></span></code></pre></div><h4 id="关于设置时使用global或session的影响">关于设置时使用GLOBAL或SESSION的影响：</h4>
<ul>
<li>
<p>使用 GLOBAL 关键字（在全局范围影响）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> GLOBAL TRANSACTION_ISOLATION <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;SERIALIZABLE&#39;</span>;
</span></span></code></pre></div><ul>
<li><strong>当前已经存在的会话无效</strong></li>
<li><strong>只对执行完该语句之后产生的会话起作用</strong></li>
</ul>
</li>
<li>
<p>使用 SESSION 关键字（在会话范围影响）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span><span style="color:#66d9ef">SET</span> SESSION TRANSACTION_ISOLATION <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;SERIALIZABLE&#39;</span>;
</span></span></code></pre></div><ul>
<li><strong>对当前会话的所有后续的事务有效</strong></li>
<li><strong>如果在事务之间执行，则对后续的事务有效</strong></li>
<li><strong>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</strong></li>
</ul>
</li>
<li>
<p>修改配置文件：</p>
<p><strong>如果在服务器启动时想改变事务的默认隔离级别，可以修改启动参数<code>transaction_isolation</code>的值。比如，在 启动服务器时指定了<code>transaction_isplation=SERIALIZABLE</code>,那么事务的默认隔离级别就从原来的 REPEATABLE-READ变成了SERIALIZABLE。</strong></p>
</li>
</ul>
<blockquote>
<p>小结：</p>
<p>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性
就越好，但并发性越弱。</p>
</blockquote>
<h3 id="不同隔离级别举例">不同隔离级别举例</h3>
<h4 id="演示1-读未提交之脏读解决了脏写">演示1. 读未提交之脏读（解决了脏写）</h4>
<p>设置隔离级别为未提交读：</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/04/01/114214781.png" alt=""></p>
<p>事务1和事务2的执行流程如下：</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/04/01/114231296.png" alt=""></p>
<h4 id="演示2读已提交解决了脏写脏读">演示2：读已提交（解决了脏写，脏读）</h4>
<p>视频 p167 ———— <a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=167&amp;spm_id_from=pageDriver">尚硅谷</a></p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/04/01/114318005.png" alt=""></p>
<h4 id="演示3可重复读解决了脏写脏读不可重复读">演示3：可重复读（解决了脏写，脏读，不可重复读）</h4>
<p>视频 p167 ———— <a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=167&amp;t=397.2">尚硅谷</a></p>
<p>设置隔离级别为可重复读，事务的执行流程如下：</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/04/01/114339783.png" alt=""></p>
<h4 id="演示4幻读">演示4：幻读</h4>
<p>视频 p168 ———— <a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=168&amp;spm_id_from=pageDriver">尚硅谷</a></p>
<p>repeatable read 解决不了幻读，但是mysql可以避免幻读，看后续</p>
<p>事务1中事务开启后，事务2 提交， 事务1中查询还是查不到的，但是如果在事务1中插入相同的数据，会报错，从而证明了发生了幻读。</p>
<p><img src="https://blogimg.ytte.top//img-jixiang/2022/04/01/114401813.png" alt=""></p>
<h2 id="事务的常见分类">事务的常见分类</h2>
<ul>
<li>扁平事务（Flat Transactions）</li>
<li>带有保存点的扁平事务（Flat Transactions with Savepoints）</li>
<li>链事务（Chained Transactions）</li>
<li>嵌套事务（Nested Transactions）</li>
<li>分布式事务（Distributed Transactions）</li>
</ul>
<h3 id="扁平事务">扁平事务</h3>
<p><strong>最简单的一种，但是在实际生产环境中，这可能是使用最频繁的事务</strong>，在扁平事务 中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是 原子的，要么都执行，要么都回滚，因此，<strong>扁平事务是应用程序成为原子操作的基本组成模块</strong>。扁平事务虽然简单，但是在实际环境中使用最为频繁，也正因为其简单，使用频繁，故每个数据库系统都实现了对扁平事务的支持。扁平事务的主要限制是<strong>不能提交或者回滚事务的某一部分</strong>，或分几个步骤提交。</p>
<p>扁平事务一般有三种不同的结果：</p>
<ul>
<li>事务成功完成。在平常应用中约占所有事务的96%。</li>
<li>应用程序要求停止事 务。比如应用程序在捕获到异常时会回滚事务，约占事务的3%。</li>
<li>外界因素强制终止事务。如连接超时或连接断 开，约占所有事务的1%。</li>
</ul>
<h3 id="带有保存点的扁平事务">带有保存点的扁平事务</h3>
<p>todo</p>
<h3 id="链事务">链事务</h3>
<p>todo</p>
<h3 id="嵌套事务">嵌套事务</h3>
<p>todo</p>
<h3 id="分布式事务">分布式事务</h3>
<p>todo</p>
<h1 id="事务的日志">事务的日志</h1>
<p>事务的四种特性到底是基于什么机制实现呢？</p>
<ul>
<li>事务的隔离性由 锁机制 实现。</li>
<li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。
<ul>
<li><strong>REDO LOG 称为 重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持</strong>
<strong>久性。</strong></li>
<li><strong>UNDO LOG 称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</strong></li>
</ul>
</li>
</ul>
<p><strong>UNDO 不是 REDO 的逆过程，UNDO 和 REDO都可以视为一种恢复操作，都是存储引擎层生成的日志。</strong></p>
<p>redo log:<strong>记录的是&quot;物理级别&quot;上的页修改操作，比如页号xxx、偏移量yyy 写入了&rsquo;zzz&rsquo;数据。主要为了保证数据的可靠性；</strong></p>
<p>undo log:<strong>记录的是逻辑操作日志，比如对某一行数据进行了INSERT语句 操作，那么undo logi就记录一条与之相反的DELETE操作。主要用于事务的回滚  ( undo log记录的是每个修改操作的逆操作)和一致性非锁定读(undo log回滚行记录到某种特定的版本-MVCC,即多版本并发控制 ) 。</strong></p>
<h2 id="redo-log">REDO LOG</h2>
<h3 id="概念">概念</h3>
<p>视频 p169 ———— <a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=169&amp;spm_id_from=pageDriver">尚硅谷</a></p>
<p>INNODB存储引擎是以<strong>页为单位</strong>来管理存储空间的。在真正访问页面之前，需要把在磁盘上的页缓存到<strong>内存中的 Buffer Poo1</strong>之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以<strong>一定的频率</strong>被刷入磁盘(<strong>checkPoint机制</strong>)，通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不 会下降太快。</p>
<p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint 并不是每次变更的时候就触发 的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p>
<p>另一方面，事务包含 持久性 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p>
<p>那么如何保证这个持久性呢？</p>
<ul>
<li>
<p>一个简单的做法 ：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题</p>
<ul>
<li>修改量与刷新磁盘工作量严重不成比例 有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在IoDB中是以页为单位来进行磁盘1o的，也 就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB 大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太小题大做了。</li>
<li>随机1O刷新较慢 一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相 邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机I0,随机I0比 顺序I0要慢，尤其对于传统的机械硬盘来说。</li>
</ul>
</li>
<li>
<p>另一个解决的思路 ：我们只需要把 修改 了哪些东西 记录一下 就好。比如，某个事务将系统表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。</p>
</li>
<li>
<p>InnoDB引擎的事务采用了WAL技术（Write-Ahead Logging),这种技术的思想就是先写日志，再写磁盘，只 有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通 过redo log来恢复，保证AclD中的D,这就是redo log的作用。</p>
</li>
</ul>
<p><img src="https://blogimg.ytte.top/img-jixiang/2022/04/01/REDO.gif" alt=""></p>
<h3 id="redo日志的好处特点">REDO日志的好处特点</h3>
<ol>
<li>
<p>好处</p>
<p>redo日志降低了刷盘频率redo日志占用的空间非常小</p>
</li>
<li>
<p>特点</p>
</li>
</ol>
<p>redo日志是顺序写入磁盘的事务执行过程中，redo log不断记录</p>
<hr>
<p>2022-4-2</p>
<h3 id="redo的组成">redo的组成</h3>
<h1 id="小记">小记</h1>
<ol>
<li>
<p>我们进行内联查询前，最好能限制连的表大小的条件都先用上了，同时尽量让条件查询和分组执行的表尽量小====》<a href="https://blog.csdn.net/Tim_phper/article/details/78344444">CSDN博客_mysql联表查询优化① </a></p>
</li>
<li>
<p>uuid采用char(32)或char(36)存储的话，需要占用32或36个字节。为节省存储空间，改为binary(16)，占用16字节。对于500W行的表，可节省7.4G的空间。</p>
<p>mybatis中没有默认的type handler来完成uuid类型&lt;-&gt;binary类型的相互转换，需要自定义一个type handler。下面就详细地介绍如何实现。</p>
</li>
<li>
<p><code>DATEDIFF(w1.recordDate,w2.recordDate)=1</code> 日期函数，计算二者差值</p>
</li>
</ol>
    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>Permalink: </strong>
      <a href="https://gb.ytte.top/2022/03/24/mysql%E9%AB%98%E7%BA%A7/" title="MySql高级" target="_blank" rel="external">https://gb.ytte.top/2022/03/24/mysql%E9%AB%98%E7%BA%A7/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License: </strong>
        <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN</a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/YTTE-jx" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://gb.ytte.top/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/YTTE-jx" target="_blank"><span class="text-dark">YTTE</span><small class="ml-1x">努力奋斗，不负韶华。</small></a></h3>
        <div>Good Good Study, Day Day Up~</div>
      </div>
    </figure>
  </div>
</div>

    </div>
  </article>
</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="https://gb.ytte.top/2022/03/22/rabbit-mq/" title="Rabbit Mq"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;Older</span></a>
            </li>
            <li class="next">
                <a href="https://gb.ytte.top/2022/03/24/mysql%E5%9F%BA%E7%A1%80/"
                    title="MySql基础"><span>Newer&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="Catalogue" role="button">
                    <span>[&nbsp;</span><span>Catalogue</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>


</main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://github.com/YTTE-jx" target="_blank" title="github" data-toggle=tooltip data-placement=top >
            <i class="icon icon-github"></i></a></li>
    <li><a href="https://gb.ytte.top/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2022  -
    2022
    <div class="publishby">
        Theme by <a href="https://github.com/xiaoheiAh" target="_blank"> xiaoheiAh </a>base on<a href="https://github.com/xiaoheiAh/hugo-theme-pure" target="_blank"> pure</a>.
    </div>
    
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
    window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/python.min.js" defer></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/javascript.min.js" defer></script><script>
    hljs.configure({
        tabReplace: '    ', 
        classPrefix: ''     
        
    })
    hljs.initHighlightingOnLoad();
</script>
<script src="https://gb.ytte.top/js/application.min.e720b935330b2a176cfb4b8bd9a6cc632caf6b752f94e87c62152a9557ff6d15.js"></script>
<script src="https://gb.ytte.top/js/plugin.min.334875d4d4a72afb866e446df61b5f4bf1f0a516d1303166f52f7804d17ef3ab.js"></script>

<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            ROOT_URL: 'https:\/\/gb.ytte.top\/',
            CONTENT_URL: 'https:\/\/gb.ytte.top\/\/searchindex.json ',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script type="text/javascript" src="https://gb.ytte.top/js/insight.min.759e5002714e12761afcd512f103d39c86573165db51972dd3b24df6eddf238ed3e3e85c1988e96cba09419d1deccdeb68c15284f2c3d03049fad53c11774524.js" defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<script>
    tocbot.init({
        
        tocSelector: '.js-toc',
        
        contentSelector: '.js-toc-content',
        
        headingSelector: 'h1, h2, h3',
        
        hasInnerContainers: true,
    });
</script>


  </body>
</html>
