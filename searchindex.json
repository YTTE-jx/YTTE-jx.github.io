{"categories":[{"title":"java","uri":"https://gb.ytte.top/categories/java/"},{"title":"JVM","uri":"https://gb.ytte.top/categories/jvm/"},{"title":"MySQL","uri":"https://gb.ytte.top/categories/mysql/"},{"title":"ZooKeeper","uri":"https://gb.ytte.top/categories/zookeeper/"},{"title":"服务器","uri":"https://gb.ytte.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"杂项","uri":"https://gb.ytte.top/categories/%E6%9D%82%E9%A1%B9/"},{"title":"项目","uri":"https://gb.ytte.top/categories/%E9%A1%B9%E7%9B%AE/"}],"posts":[{"content":"Https  视频====》哔哩哔哩_bilibili\n 获得域名设置二级域名 jix\n","id":0,"section":"posts","summary":"\u003c!-- raw HTML omitted --\u003e","tags":["Https"],"title":"Https","uri":"https://gb.ytte.top/2022/03/19/https/","year":"2022"},{"content":"Java8之Consumer、Supplier、Predicate和Function攻略 - 公众号好好学java - 博客园 (cnblogs.com)\n","id":1,"section":"posts","summary":"","tags":["基础"],"title":"Consumer、Supplier、Predicate和Function","uri":"https://gb.ytte.top/2022/03/14/consumersupplierpredicate%E5%92%8Cfunction/","year":"2022"},{"content":"ZooKeeper 非docker 单机（本地）安装配置启动 视频====》_哔哩哔哩_bilibili p7\n  需要jdk环境，并配置环境变量\nlinux安装jdk8\n  下载ZooKeeper压缩包（Apache Downloads)放在linux下的/mnt/zookeeper下。\n  tar -zxvf apache-zookeeper-3.5.7-bin.tar.gz\r   将文件夹改名\nmv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7/\r   更改conf下 的zoo-sample.cfg为zoo.cfg\n  更改zoo.cfg中\ndataDir=/mnt/zookeeper/zookeeper-3.5.7/data\rdataLogDir=/mnt/zookeeper/zookeeper-3.5.7/dataLog\r   启动服务端：\n**注意：**需要在/mnt/zookeeper/zookeeper-3.5.7/目录下使用启动命令bin/zkServer.sh start 不能再/mnt/zookeeper/zookeeper-3.5.7/bin/目录下使用zkServer.sh start\n  使用jps -l 查看是否启动了zookeeper 的java进程。\n  启动客户端： bin/zkCli.sh\n    ls /查看节点\n  quit退出客户端\n  bin/zkServer.sh status查看zookeeper的状态（standalone单机模式）\n  bin/zkServer.sh stop 停止服务器端\n    docker 配置参数解读 视频====》p8\n  tickTime=2000——通信的心跳时间\nZooKeeper服务器与客户端之间通信频率，每2000ms发送一次。\n  initLimit=10——LF初始通信时限\n  Leader与Follower初始连接是\n ","id":2,"section":"posts","summary":"","tags":["ZooKeeper"],"title":"ZooKeeper","uri":"https://gb.ytte.top/2022/03/14/zookeeper/","year":"2022"},{"content":"Filter Filter-CSDN博客_java过滤器\nLstener Filter与Listener - 简书 (jianshu.com)\nListener(监听器)的简单介绍_LrvingTc的博客-CSDN博客_listener\nServlet JavaWeb——Servlet（全网最详细教程包括Servlet源码分析）_扬俊的小屋-CSDN博客_servlet\n四大域对象 JavaWeb四大域对象 - 简书 (jianshu.com)\nJAVA中的四大域对象总结_kun blog-CSDN博客_域对象\n","id":3,"section":"posts","summary":"","tags":["基础"],"title":"Filter/ Lstener/ Servlet/四大域对象","uri":"https://gb.ytte.top/1/01/01/filter/-lstener/-servlet/%E5%9B%9B%E5%A4%A7%E5%9F%9F%E5%AF%B9%E8%B1%A1/","year":"0001"},{"content":"JVM上篇 JVM与Java体系结构 1. Java虚拟机整体架构祥图 2.Java代码执行过程详图 3. JVM的架构模型","id":4,"section":"posts","summary":"","tags":["JVM"],"title":"JVM上篇","uri":"https://gb.ytte.top/1/01/01/jvm%E4%B8%8A%E7%AF%87/","year":"0001"},{"content":"MySQL 基础 高级 8、 索引的创建与设计原则 2、索引的必要使用场景 1). 字段的数值有唯一性的限制 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。\n说明：唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。\n2). 频繁作为 WHERE 查询条件的字段 某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。\n比如查询 student_id =144324的时候\nSELECT course_id ,class_id, `name`,create_time,student_id\rFROM student_info WHERE student_id =144324\r   在student_id不加索引的情况下，100w条数据，耗时为350ms左右，即在百毫秒级\nALTER TABLE student_info ADD INDEX idx_sid(student_id)\rSHOW INDEX FROM student_info #查看是否添加成功\r   在添加索引的情况下，耗时为22ms，降了一个数量级，这是很客观的。\n   3). 经常 GROUP BY 和 ORDER BY 的列 索引就是让数据按照某种顺序进行存储或检索，因此当我们使用GROUP BY对数据进行分组查询，或者使用ORDER BY对数据进行排序的时候，就需要对分组或者排序的字段进行索引，从而减少排序的时间。如果待排序的列有多个，那么可以在这些列上建立组合索引。\n1. GROUP BY eg：在100w条数据中，按照student_id对学生选修课程进行分组，显示不同的student_id和课程数量，显示100个。\nSELECT student_id ,COUNT(*) AS num\rFROM student_info\rGROUP BY student_id LIMIT 100\rDROP INDEX idx_sid ON student_info\rSHOW INDEX FROM student_info\r  在不加索引的情况下，耗时850毫秒。 在加索引的情况下（这里使用的是2）当中的idx_sid索引），耗时21毫秒。  2. ORDER BY ORDER BY单独使用的情况与GROUP BY差不多\n3. ORDER BY和GROUP BY同时使用的情况 ==由于GROUP BY先执行，且GROUP BY为先排序再分组，所以主要耗时就集中在GROUP BY上。==\n使用以下三种情况来观察不同索引状况下，sql执行的速度差异\n 三种情况：  ​\t①. student_id和create_time分别建立索引\n​\t②. student_id和create_time建立联合索引，且student_id在前\n​\t③. student_id和create_time建立联合索引，且create_time在前\nSELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info\rGROUP BY\tstudent_id\rORDER BY\tcreate_time desc\rLIMIT 100\r 不加除主键索引以外的其他索引的情况下，耗时约==0.8~1s==\n 两种版本：  ​\t①. MySQL 5.7.5及以上功能依赖检测功能\n​\t②. MySQL 5.7.5以下无依赖检测功能\n执行上方代码后MySQL 5.7.5及以上会报错\nsql_mode=only_full_group_by #出现问题\r MySQL 5.7.5及以上由于sql_mode=only_full_group_by是默认开启依赖检测功能，所以HAVING条件或ORDER BY列表的查询引用在GROUP BY子句中。 简单来说就是：输出的结果是叫target list，就是select后面跟着的字段，还有一个地方group by column，就是group by后面跟着的字段。由于开启ONLY_FULL_GROUP_BY的设置，如果一个字段没有在target list和group by字段中同时出现，或者是聚合函数的值的话，那么这条sql查询是被mysql认为非法的，会报错误。\n但是如果同时GROUP BY student_id，create_time 这两个字段，就失去了本例的作用。所以需要MySQL 5.7.5及以上的需要关闭依赖检测功能\n具体解析链接====》文档——石墨\nselect @@global.sql_mode #查看sql_mode详细\rset @@global.sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'; #去掉ONLY_FULL_GROUP_BY，重新设置值，对于新建的数据库有效 8.0中还要去掉NO_AUTO_CREATE_USER\rset global sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'; #对于已存在的数据库，则需要在对应的数据下执行\r 继续测试\n  添加单列student_id索引和create_time索引\n​\t5.7中：\n耗时6s左右，添加索引就是将这些时间提前消耗掉，让客户查询的时候减少查询时间。\nALTER TABLE student_info\rADD INDEX idx_sid(student_id);\rALTER TABLE student_info\rADD INDEX idx_cre_time(create_time DESC);\r 这里 EXPLAIN 后会发现只使用了student_id 的索引idx_sid（单列索引的情况，只使用语句执行过程第一个索引）所以这里只使用了索引idx_sid，而idx_cre_time压根没用到。\nSHOW INDEX FROM student_info\rEXPLAIN SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info\rGROUP BY\tstudent_id\rORDER BY\tcreate_time DESC\rLIMIT 100;\r 各自单列索引的情况下，耗时大约1.5s（上面不加索引的情况下耗时1s）\n​\t8.0中\n==todo 不明原因，未得到解决，上述方式在5.7中大约需要1.5s左右，而在8.0中需要几分钟的时间。==\n  联合索引的情况① ：\n先删除除主键外其他的单列索引\nidx_sid_cre_time(student_id,create_time)，student_id在前\n​\t5.7：\nALTER TABLE student_info\rADD INDEX idx_sid_cre_time(student_id,create_time);\rSHOW INDEX FROM student_info;\rEXPLAIN SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info\rGROUP BY\tstudent_id\rORDER BY\tcreate_time DESC\rLIMIT 100;\r 耗时约==300ms==左右（未加索引1s左右，单列索引1.5s左右）\n8.0：\nDROP INDEX idx_sid ON student_info ;\rDROP INDEX idx_cre_time ON student_info;\rDROP INDEX idx_sid_cre_time ON student_info;\rALTER TABLE student_info\rADD INDEX idx_sid_cre_time(student_id,create_time DESC);\rSHOW INDEX FROM student_info;\rEXPLAIN SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info\rGROUP BY\tstudent_id\rORDER BY\tcreate_time DESC\rLIMIT 100;\r   索引不加DESC时，耗时约==800ms==左右（不加索引1s左右，单列索引几分钟）\n  索引加DESC时，耗时约==300ms==左右（不加索引1s左右，单列索引几分钟）\n    联合索引的情况② ：\nidx_cre_sid_time(create_time,student_id)，create_time在前\n在语句执行中，先进行group by 所以此时如果存在idx_sid(student_id)的话，会优先使用group by student_id的student_id索引（idx_sid），这样就变成了使用单列索引，联合索引idx_sid_cre_time就不起作用了。\n如果不存在idx_sid，只有联合索引idx_cre_sid_time：\n​ 5.7：\nDROP INDEX idx_sid ON student_info ;\rDROP INDEX idx_cre_time ON student_info;\rDROP INDEX idx_sid_cre_time ON student_info;\rALTER TABLE student_info\rADD INDEX idx_cre_sid_time(create_time,student_id);\rSELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info\rGROUP BY\tstudent_id\rORDER BY\tcreate_time DESC\rLIMIT 100;\r 耗时约==800ms左右== （未加索引1s左右，单列索引1.5s左右，idx_sid_cre_time索引耗时约300ms）\n​ 8.0 ：\nDROP INDEX idx_sid ON student_info ;\rDROP INDEX idx_cre_time ON student_info;\rDROP INDEX idx_sid_cre_time ON student_info;\rDROP INDEX idx_cre_sid_time ON student_info;\rALTER TABLE student_info\rADD INDEX idx_cre_sid_time(create_time DESC,student_id);\rSELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info\rGROUP BY\tstudent_id\rORDER BY\tcreate_time DESC\rLIMIT 100;\r   索引不加DESC时，耗时约==1s==左右（不加索引1s左右，单列索引几分钟，idx_sid_cre_time索引800ms左右）\n  索引加DESC时，耗时约==1s==左右（不加索引1s左右，单列索引几分钟，idx_sid_cre_time索引300ms左右）\n    4). UPDATE、DELETE 的 WHERE 条件列 对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。\n原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。\n5). DISTINCT 字段需要创建索引 有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。\n比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行\nSQL 语句：\nSELECT DISTINCT(student_id) FROM `student_info`;\r 运行结果（600637 条记录，运行时间 0.683s ）：\n如果我们对 student_id 创建索引，再执行 SQL 语句：\nSELECT DISTINCT(student_id) FROM `student_info`;\r 运行结果（600637 条记录，运行时间 0.010s ）：\nSQL 查询效率有了提升，同时显示出来的 student_id 还是按照 递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。\n6). 多表 JOIN 连接操作时，创建索引注意事项 首先， ==连接表的数量尽量不要超过 3 张==，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。\n其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。\n最后，==类似字符串和int比较时，会存在隐式转换，即使用了函数，一旦使用了函数就会让索引失效。 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。==比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。\n举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：\nSELECT course_id, name, student_info.student_id, course_name FROM student_info JOIN course ON student_info.course_id = course.course_id WHERE name = '462eed7ac6e791292a79';\r 运行结果（1 条数据，运行时间 0.189s ）：\n这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。\n7). 使用列的类型小的创建索引 8). 使用字符串前缀创建索引 创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引\ncreate table shop(address varchar(120) not null); alter table shop add index(address(12));  问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字\n段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？\n先看一下字段在全部数据中的选择度：\nselect count(distinct address) / count(*) from shop;\r 通过不同长度去计算，与全表的选择性对比：\n公式：\ncount(distinct left(列名, 索引长度))/count(*)\r 例如：\nselect count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度 count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度 count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度 count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度\rfrom shop;\r 引申另一个问题：索引列前缀对排序的影响\n拓展：Alibaba《Java开发手册》\n==在 varchar 字段上建立索引时，必须指定索引长度，根据实际文本区分度决定索引长度。==\n说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达 90% 以上 ，可以使用\n count(distinct left(列名, 索引长度))/count(*)的区分度来确定。\n9). 区分度高(散列性高)的列适合作为索引 10). 使用最频繁的列放到联合索引的左侧 11). 在多个字段都要创建索引的情况下，联合索引优于单值索引 3. 限制索引的数目 4. 哪些情况不适合创建索引  WHERE条件（包括GROUP BY、ORDER BY)里用不到的字段不需要创建索引 数据量小的表最好不要使用索引 有大量重复数据的列上不要建立索引  比如性别。   避免对经常更新的表创建过多的索引 不建议用无序的值作为索引  例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。   删除不再使用或者很少使用的索引 不要定义冗余或重复的索引  小记  我们进行内联查询前，最好能限制连的表大小的条件都先用上了，同时尽量让条件查询和分组执行的表尽量小====》CSDN博客_mysql联表查询优化①   ","id":5,"section":"posts","summary":"","tags":["MySQL"],"title":"MySQL","uri":"https://gb.ytte.top/1/01/01/mysql/","year":"0001"},{"content":"彻底弄懂session，cookie，token - SegmentFault 思否\n彻底理解cookie，session，token - 墨颜丶 - 博客园 (cnblogs.com)\n","id":6,"section":"posts","summary":"","tags":["基础"],"title":"session，cookie，token","uri":"https://gb.ytte.top/1/01/01/sessioncookietoken/","year":"0001"},{"content":"SpringBoot 5. web开发 3. 请求参数处理 1. 普通参数与基本注解 1.1注解 视频====》尚硅谷雷神SpringBoot2_bilibili\n@PathVariable、\n@RequestHeader、\n@ModelAttribute、\n@RequestParam、\n@MatrixVariable（矩阵变量）、\n@CookieValue、\n@RequestBody\n@RestController\rpublic class ParameterTestController {\r// car/2/owner/zhangsan\r@GetMapping(\u0026quot;/car/{id}/owner/{username}\u0026quot;)\rpublic Map\u0026lt;String,Object\u0026gt; getCar(@PathVariable(\u0026quot;id\u0026quot;) Integer id,\r@PathVariable(\u0026quot;username\u0026quot;) String name,\r@PathVariable Map\u0026lt;String,String\u0026gt; pv,\r@RequestHeader(\u0026quot;User-Agent\u0026quot;) String userAgent,\r@RequestHeader Map\u0026lt;String,String\u0026gt; header,\r@RequestParam(\u0026quot;age\u0026quot;) Integer age,\r@RequestParam(\u0026quot;inters\u0026quot;) List\u0026lt;String\u0026gt; inters,\r@RequestParam Map\u0026lt;String,String\u0026gt; params,\r@CookieValue(\u0026quot;_ga\u0026quot;) String _ga,\r@CookieValue(\u0026quot;_ga\u0026quot;) Cookie cookie){\rMap\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\r// map.put(\u0026quot;id\u0026quot;,id);\r// map.put(\u0026quot;name\u0026quot;,name);\r// map.put(\u0026quot;pv\u0026quot;,pv);\r// map.put(\u0026quot;userAgent\u0026quot;,userAgent);\r// map.put(\u0026quot;headers\u0026quot;,header);\rmap.put(\u0026quot;age\u0026quot;,age);\rmap.put(\u0026quot;inters\u0026quot;,inters);\rmap.put(\u0026quot;params\u0026quot;,params);\rmap.put(\u0026quot;_ga\u0026quot;,_ga);\rSystem.out.println(cookie.getName()+\u0026quot;===\u0026gt;\u0026quot;+cookie.getValue());\rreturn map;\r}\r@PostMapping(\u0026quot;/save\u0026quot;)\rpublic Map postMethod(@RequestBody String content){\rMap\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\rmap.put(\u0026quot;content\u0026quot;,content);\rreturn map;\r}\r//1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd\r//2、SpringBoot默认是禁用了矩阵变量的功能\r// 手动开启：原理。对于路径的处理。UrlPathHelper进行解析。\r// removeSemicolonContent（移除分号内容）支持矩阵变量的\r//3、矩阵变量必须有url路径变量才能被解析\r@GetMapping(\u0026quot;/cars/{path}\u0026quot;)\rpublic Map carsSell(@MatrixVariable(\u0026quot;low\u0026quot;) Integer low,\r@MatrixVariable(\u0026quot;brand\u0026quot;) List\u0026lt;String\u0026gt; brand,\r@PathVariable(\u0026quot;path\u0026quot;) String path){\rMap\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\rmap.put(\u0026quot;low\u0026quot;,low);\rmap.put(\u0026quot;brand\u0026quot;,brand);\rmap.put(\u0026quot;path\u0026quot;,path);\rreturn map;\r}\r// /boss/1;age=20/2;age=10\r@GetMapping(\u0026quot;/boss/{bossId}/{empId}\u0026quot;)\rpublic Map boss(@MatrixVariable(value = \u0026quot;age\u0026quot;,pathVar = \u0026quot;bossId\u0026quot;) Integer bossAge,\r@MatrixVariable(value = \u0026quot;age\u0026quot;,pathVar = \u0026quot;empId\u0026quot;) Integer empAge){\rMap\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\rmap.put(\u0026quot;bossAge\u0026quot;,bossAge);\rmap.put(\u0026quot;empAge\u0026quot;,empAge);\rreturn map;\r}\r}\r","id":7,"section":"posts","summary":"","tags":["SpringBoot"],"title":"SpringBoot","uri":"https://gb.ytte.top/1/01/01/springboot/","year":"0001"},{"content":"SpringCloud alibaba","id":8,"section":"posts","summary":"","tags":["SpringCloud"],"title":"SpringCloud alibaba","uri":"https://gb.ytte.top/1/01/01/springcloud-alibaba/","year":"0001"},{"content":"线程的实现方式及其优缺点 继承Thread类 public class TestCode1 extends Thread\r{\rprivate int i;\rpublic void run()\r{\rfor(;i\u0026lt;100;i++)\r{\rSystem.out.println(getName()+\u0026quot; \u0026quot;+i);\r}\r}\rpublic static void main(String[] args) {\rfor(int i=0;i\u0026lt;100;i++)\r{\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; \u0026quot;+i);\rif(i==20){\rnew TestCode1().start();\rnew TestCode1().start();\r}\r}\r}\r}\r 实现Runnable接口  实现Runnable接口，重写run方法，实例要作为Thread的target来创建对象，thread.start()（推荐这种，清洗可见）  class MyRunnable implements Runnable{\r@Override\rpublic void run() {\rfor (int i = 0; i \u0026lt; 20; i++) {\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; \u0026quot;+i);\r}\r}\r}\rpublic class MyThread {\rpublic static void main(String[] args) {\r//创建自定义类对象 线程任务对象\rMyRunnable mr = new MyRunnable();\r//创建线程对象\rThread t = new Thread(mr, \u0026quot;小强\u0026quot;);\rt.start();\rfor (int i = 0; i \u0026lt; 20; i++) {\rSystem.out.println(\u0026quot;旺财 \u0026quot; + i);\r}\r}\r}   或者在方法内直接重写  public class MyThread {\rpublic static void main(String[] args) { Runnable r = new Runnable(){\rpublic void run(){\rfor (int i = 0; i \u0026lt; 20; i++) {\rSystem.out.println(\u0026quot;张宇:\u0026quot;+i);\r}\r}\r};\rnew Thread(r).start(); }\r}\r  直接lambda创建Runnable实现类  public class MyThread {\rpublic static void main(String[] args) {\rRunnable r = () -\u0026gt; {\rfor (int i = 0; i \u0026lt; 20; i++) {\rSystem.out.println(\u0026quot;张宇:\u0026quot;+i);\r}\r};\rnew Thread(r).start();\r}\r}\r 实现Callable接口   创建Callable接口的实现类，并实现Call（）方法，该方法将作为线程执行体，且该方法有返回值，再创建Callable实现类的实例。从Java8开始，可以直接使用Lambda表达式创建Callable对象。\n  使用FutureTask来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。\n  使用FutureTask对象作为Thread对象的target创建并启动新线程。\n  调用FutureTask对象的get（）方法来获取子线程执行结束后的返回值。\n  class MyCallable implements Callable {\r@Override\rpublic Object call() throws Exception {\rint i = 0;\rfor (; i \u0026lt; 100; i++) {\rThread.sleep(100);\rSystem.out.println(Thread.currentThread().getName() + \u0026quot;循环遍历i的值\u0026quot; + i);\r}\rreturn null;\r}\r}\rpublic class ThreadTest {\rpublic static void main(String[] args) {\rCallable myCallable = new MyCallable();\rFutureTask task = new FutureTask(myCallable);\rnew Thread(task).start();\rfor (int i = 0; i \u0026lt; 100; i++) {\rtry {\rThread.sleep(100);\rSystem.out.println(Thread.currentThread().getName()+\u0026quot;循环遍历i的值\u0026quot; + i);\r}\rcatch (Exception e) {\re.printStackTrace();\r}\r}\r}\r}\r//lambda方式\rpublic class ThreadTest {\rpublic static void main(String[] args) {\rFutureTask\u0026lt;Integer\u0026gt; task = new FutureTask\u0026lt;\u0026gt;(()-\u0026gt;{\rint i=0;\rfor(;i\u0026lt;100;i++){\rSystem.out.println(Thread.currentThread().getName()+\u0026quot;循环变量i的值：\u0026quot;+i);\r}\rreturn i;\r});\rfor(int i=0;i\u0026lt;100;i++){\rSystem.out.println(Thread.currentThread().getName()+\u0026quot;循环变量i的值：\u0026quot;+i);\rif(i==20){\rnew Thread(task,\u0026quot;有返回值的线程\u0026quot;).start();\r}\rtry{\rSystem.out.println(\u0026quot;子线程的返回值：\u0026quot;+task.get());\r}\rcatch (Exception e) {\re.printStackTrace();\r}\r}\r}\r}\r 异同点和优缺点 异同点   相同点\n 都可以实现多线程 Runnable与Callable实现方式类似    不同点\n Thread方式是通过继承来实现。 Runnable与Callable是通过实现接口方式创建线程。 Runnable与Callable  因为通过FutureTask包装Callable接口，FutureTask有get方法可以获取返回值，所以只有这种方式创建的子线程有返回值。 run方法无法抛出异常，call方法可以抛出checked exception。 Callable和Runnable都可以应用于executors。而Thread类只支持Runnable.      优缺点   优点\n  Thread\n 编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this即可获得当前线程。    Runnable与Callable\n 可以继承其他类 多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。      缺点\n Thread  继承的局限性，不能继承其他类   Runnable与Callable  编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread（）方法。      补充 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。\n子线程执行完，主线程执行 正常如1中的各种实现方式 Local跳转方式，Shimo跳转方式，主线程与子线程是争夺线程资源的，所以一般情况是会出现类似交替执行的状况。\nFutureTask来包装Callable对象 上方（ Local跳转方式，Shimo跳转方式）的这种是子线程无返回值的情况，这种情况下，子线程与多线程可以争夺线程资源，\n如果为子线程添加返回值，使用 FutureTask来包装Callable对象，通过task.get()来获取返回值，主线程进行到task.get()时，如果子线程还在执行，没有返回，主线程就会子线程返回之前等待挂起。从而达到要求。\npublic class TestCode3 {\rpublic static void main(String[] args) {\rFutureTask\u0026lt;Integer\u0026gt; task = new FutureTask\u0026lt;Integer\u0026gt;((Callable\u0026lt;Integer\u0026gt;)()-\u0026gt;{\rint i=0;\rfor(;i\u0026lt;100;i++){\rSystem.out.println(Thread.currentThread().getName()+\u0026quot;循环变量i的值：\u0026quot;+i);\r}\rreturn i;\r});\rfor(int i=0;i\u0026lt;100;i++){\rSystem.out.println(Thread.currentThread().getName()+\u0026quot;循环变量i的值：\u0026quot;+i);\rif(i==20){\rnew Thread(task,\u0026quot;有返回值的线程\u0026quot;).start();\r}\rtry{\rSystem.out.println(\u0026quot;子线程的返回值：\u0026quot;+task.get());\r}\rcatch (Exception e) {\re.printStackTrace();\r}\r}\r}\r}\r join方法 参考资料链接\n结论：t.join()方法只会使主线程(或者说调用t.join()的线程)进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。\nt.join方法底层中使用wait(0)方法，即使用了该方法的线程会进入无限等待中，直到 t 执行完成才返回。进入等待的只是调用了join方法的线程，其他线程没开启的不会开启，开启了的不会等待继续执行。\npublic class TestJoin {\rpublic static void main(String[] args) throws InterruptedException {\r// TODO Auto-generated method stub\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; start\u0026quot;);\rThreadTest t1=new ThreadTest(\u0026quot;A\u0026quot;);\rThreadTest t2=new ThreadTest(\u0026quot;B\u0026quot;);\rThreadTest t3=new ThreadTest(\u0026quot;C\u0026quot;);\rSystem.out.println(\u0026quot;t1start\u0026quot;);\rt1.start();\rSystem.out.println(\u0026quot;t1end\u0026quot;);\rSystem.out.println(\u0026quot;t2start\u0026quot;);\rt2.start();\rSystem.out.println(\u0026quot;t2end\u0026quot;);\rt1.join();\rSystem.out.println(\u0026quot;t3start\u0026quot;);\rt3.start();\rSystem.out.println(\u0026quot;t3end\u0026quot;);\rSystem.out.println(Thread.currentThread().getName()+\u0026quot; end\u0026quot;);\r}\r}\r 结果：\nmain start\rt1start\rt1end\rt2start\rt2end\rA-1\rB-1\rA-2\rA-3\rA-4\rA-5\rB-2\rt3start\rt3end\rB-3\rmain end\rB-4\rB-5\rC-1\rC-2\rC-3\rC-4\rC-5\r 主线程在t1.join()方法处停止，并需要等待A线程执行完毕后才会执行t3.start()，然而，并不影响B线程的执行。因此，可以得出结论，t.join()方法只会使主线程进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。\n join源码中，只会调用wait方法，并没有在结束时调用notify，这是因为==线程在die的时候会自动调用自身的notifyAll方法，来释放所有的资源和锁。==\n 线程与线程池的状态 线程的状态（NRBWTT）（牛肉包我舔舔）  NEW\t尚未启动 RUNNABLE 正在执⾏中 BLOCKED 阻塞的（被同步锁或者IO锁阻塞） WAITING 永久等待状态 TIMED_WAITING 等待指定的时间重新被唤醒的状态 TERMINATED 执⾏完成  线程池的状态（RSSTT）（人事是傻甜甜）   RUNNING： 这是最正常的状态 ，接受新的任务，处理等待队列中的任务 。\n  SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。\n  STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执⾏任务的线程。\n  TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执⾏钩⼦⽅法 terminated()。\n  TERMINATED：terminated()⽅法结束后，线程池的状态就会变成这个。\n  线程池 大佬链接====》线程池1_CSDN博客\n大佬链接====》线程池2-CSDN博客\n线程池的优点   降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n  提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n  **提高线程的可管理性。**线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n  线程池的继承树 线程池地使用 线程池的真正实现类是ThreadPoolExecutor ，其构造器方法有以下4种：\npublic ThreadPoolExecutor(int corePoolSize,\rint maximumPoolSize,\rlong keepAliveTime,\rTimeUnit unit,\rBlockingQueue\u0026lt;Runnable\u0026gt; workQueue) {\rthis(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\rExecutors.defaultThreadFactory(), defaultHandler);\r}\rpublic ThreadPoolExecutor(int corePoolSize,\rint maximumPoolSize,\rlong keepAliveTime,\rTimeUnit unit,\rBlockingQueue\u0026lt;Runnable\u0026gt; workQueue,\rThreadFactory threadFactory) {\rthis(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\rthreadFactory, defaultHandler);\r}\rpublic ThreadPoolExecutor(int corePoolSize,\rint maximumPoolSize,\rlong keepAliveTime,\rTimeUnit unit,\rBlockingQueue\u0026lt;Runnable\u0026gt; workQueue,\rRejectedExecutionHandler handler) {\rthis(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\rExecutors.defaultThreadFactory(), handler);\r}\rpublic ThreadPoolExecutor(int corePoolSize,\rint maximumPoolSize,\rlong keepAliveTime,\rTimeUnit unit,\rBlockingQueue\u0026lt;Runnable\u0026gt; workQueue,\rThreadFactory threadFactory,\rRejectedExecutionHandler handler) {\rif (corePoolSize \u0026lt; 0 ||\rmaximumPoolSize \u0026lt;= 0 ||\rmaximumPoolSize \u0026lt; corePoolSize ||\rkeepAliveTime \u0026lt; 0)\rthrow new IllegalArgumentException();\rif (workQueue == null || threadFactory == null || handler == null)\rthrow new NullPointerException();\rthis.corePoolSize = corePoolSize;\rthis.maximumPoolSize = maximumPoolSize;\rthis.workQueue = workQueue;\rthis.keepAliveTime = unit.toNanos(keepAliveTime);\rthis.threadFactory = threadFactory;\rthis.handler = handler;\r}\r 参数说明：IPHP  corePoolSize（必需）：核心线程数。默认情况下，核心线程会一直存活，但是当将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。 maximumPoolSize（必需）：线程池所能容纳的最大线程数。当活跃线程数达到该数值后，后续的新任务将会阻塞。 keepAliveTime（必需）：线程闲置超时时长。如果超过该时长，非核心线程就会被回收。如果将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。 unit（必需）：指定 keepAliveTime 参数的时间单位。常用的有：TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）。 workQueue（必需）：任务队列。通过线程池的 execute() 方法提交的 Runnable 对象将存储在该参数中。其采用阻塞队列实现。 threadFactory（可选）：线程工厂。用于指定为线程池创建新线程的方式。 handler（可选）：拒绝策略。当达到最大线程数时需要执行的饱和策略。  线程池的使用流程：\n// 创建线程池\rThreadPoolExecutor threadPool = new ThreadPoolExecutor(CORE_POOL_SIZE,\rMAXIMUM_POOL_SIZE,\rKEEP_ALIVE,\rTimeUnit.SECONDS,\rsPoolWorkQueue,\rsThreadFactory);\r// 向线程池提交任务\rthreadPool.execute(new Runnable() {\r@Override\rpublic void run() {\r... // 线程执行的任务\r}\r});\r// 关闭线程池\rthreadPool.shutdown(); // 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程\rthreadPool.shutdownNow(); // 设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表\r 线程池的工作原理 简概：IPHP  1.如果线程数小于corePoolSize，创建一个新核心线程来运行新任务。 2.如果线程数大于等于corePoolSize但小于maximumPoolSize，则将任务放入队列。 3.如果队列已满，并且线程数小于maxPoolSize，则创建一个新非核心线程来运行任务。 4.如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。  是否需要增加线程的判断顺序是：1、corePoolSize 2、workQueue 3、maxPoolSize\n举个例子：\n线程池的核心线程数corePoolSize大小为5，最大池maxPoolSize大小为10，队列workQueue为100。\n因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程，最多到10个线程，如果再来任务，就拒绝。\n特点：\n 通过设置corePoolSize和maximumPoolSize 相同，就可以创建固定大小的线程池。 我们使用线程池一般希望保持较少的线程数，并且只有在负载变得很大时才增加它。 通过设置maximumPoolSize为很高的值，例如 Integer.MAX_VALUE，可以允许线程池容纳任意数量的并发任务。 只有在队列填满时才创建多于corePoolSize的非核心线程，如果使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize。  线程参数解析 任务队列workQueue 任务队列是基于阻塞队列实现的，即采用生产者消费者模式，在 Java 中需要实现 BlockingQueue 接口。但 Java 已经为我们提供了 7 种阻塞队列的实现：\n  ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列（数组结构可配合指针实现一个环形队列）。\n  LinkedBlockingQueue： 一个由链表结构组成的有界阻塞队列，在未指明容量时，容量默认为Integer.MAX_VALUE。\n 这种队列容量无限大，可以防止流量突增。设置maximumPoolSize也用不到，因为队列装不满，永远不需要创建新的非核心线程。但是也有风险，处理任务的速度跟不上提交的速度，可能造成内存浪费或者OOM。\n   PriorityBlockingQueue： 一个支持优先级排序的无界阻塞队列，对元素没有要求，可以实现 Comparable 接口也可以提供 Comparator 来对队列中的元素进行比较。跟时间没有任何关系，仅仅是按照优先级取任务。\n  DelayQueue：类似于PriorityBlockingQueue，是二叉堆实现的无界优先级阻塞队列。要求元素都实现 Delayed 接口，通过执行时延从队列中提取任务，时间没到任务取不出来。\n  SynchronousQueue： 一个不存储元素的阻塞队列，消费者线程调用 take() 方法的时候就会发生阻塞，直到有一个生产者线程生产了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用 put() 方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。\n 工作任务不多的情况下，只是将任务中转，就可以用SynchronousQueue，这个队列本身内部没有容量，使用这种队列，maximumPoolSize就可能需要设置的大一些。因为没有队列容量作为缓冲了，很容易创建新线程。\n   LinkedBlockingDeque： 使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样 FIFO（先进先出），也可以像栈一样 FILO（先进后出）。\n  LinkedTransferQueue： 它是ConcurrentLinkedQueue、LinkedBlockingQueue 和 SynchronousQueue 的结合体，但是把它用在 ThreadPoolExecutor 中，和 LinkedBlockingQueue 行为一致，但是是无界的阻塞队列。\n  注意有界队列和无界队列的区别：如果使用有界队列，当队列饱和时并超过最大线程数时就会执行拒绝策略；而如果使用无界队列，因为任务队列永远都可以添加任务，所以设置 maximumPoolSize 没有任何意义。\n线程工厂（threadFactory） 线程工厂指定创建线程的方式，需要实现 ThreadFactory 接口，并实现 newThread(Runnable r) 方法。\n 新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory() 创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。 如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。 通常使用默认的ThreadFactory就可以了  // 验证第一点，新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory()\rpublic static ThreadFactory defaultThreadFactory() {\rreturn new DefaultThreadFactory();\r}\r......\rstatic class DefaultThreadFactory implements ThreadFactory {\rprivate static final AtomicInteger poolNumber = new AtomicInteger(1);\rprivate final ThreadGroup group;\rprivate final AtomicInteger threadNumber = new AtomicInteger(1);\rprivate final String namePrefix;\rDefaultThreadFactory() {\rSecurityManager s = System.getSecurityManager();\rgroup = (s != null) ? s.getThreadGroup() :\rThread.currentThread().getThreadGroup();\rnamePrefix = \u0026quot;pool-\u0026quot; +\rpoolNumber.getAndIncrement() +\r\u0026quot;-thread-\u0026quot;;\r}\rpublic Thread newThread(Runnable r) {\r// 验证第二点，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。\rThread t = new Thread(group, r,\rnamePrefix + threadNumber.getAndIncrement(),\r0);\rif (t.isDaemon())\rt.setDaemon(false);\rif (t.getPriority() != Thread.NORM_PRIORITY)\rt.setPriority(Thread.NORM_PRIORITY);\rreturn t;\r}\r}\r 拒绝策略（handler） 当线程池的线程数达到最大线程数时，需要执行拒绝策略。拒绝策略需要实现 RejectedExecutionHandler 接口，并实现 rejectedExecution(Runnable r, ThreadPoolExecutor executor) 方法。不过 Executors 框架已经为我们实现了 4 种拒绝策略：\n AbortPolicy（默认）：丢弃任务并抛出 RejectedExecutionException 异常。 CallerRunsPolicy：由调用线程处理该任务。 DiscardPolicy：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。 DiscardOldestPolicy：丢弃队列最早的未处理任务，然后重新尝试执行任务。  功能线程池 嫌上面使用线程池的方法太麻烦？其实Executors已经为我们封装好了 4 种常见的功能线程池，如下：\n 定长线程池（FixedThreadPool） 定时线程池（ScheduledThreadPool ） 可缓存线程池（CachedThreadPool） 单线程化线程池（SingleThreadExecutor）  定长线程池（FixedThreadPool） public static ExecutorService newFixedThreadPool(int nThreads) {\rreturn new ThreadPoolExecutor(nThreads, nThreads,\r0L, TimeUnit.MILLISECONDS,\rnew LinkedBlockingQueue\u0026lt;Runnable\u0026gt;());\r}\rpublic static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\rreturn new ThreadPoolExecutor(nThreads, nThreads,\r0L, TimeUnit.MILLISECONDS,\rnew LinkedBlockingQueue\u0026lt;Runnable\u0026gt;(),\rthreadFactory);\r}\r  特点：只有核心线程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。 应用场景：控制线程最大并发数。  使用：\n// 1. 创建定长线程池对象 \u0026amp; 设置线程池线程数量固定为3\rExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);\r// 2. 创建好Runnable类线程对象 \u0026amp; 需执行的任务\rRunnable task =new Runnable(){\rpublic void run() {\rSystem.out.println(\u0026quot;执行任务啦\u0026quot;);\r}\r};\r// 3. 向线程池提交任务\rfixedThreadPool.execute(task);\r 定时线程池（ScheduledThreadPool ） private static final long DEFAULT_KEEPALIVE_MILLIS = 10L;\rpublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\rreturn new ScheduledThreadPoolExecutor(corePoolSize);\r}\rpublic ScheduledThreadPoolExecutor(int corePoolSize) {\rsuper(corePoolSize, Integer.MAX_VALUE,\rDEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,\rnew DelayedWorkQueue());\r}\rpublic static ScheduledExecutorService newScheduledThreadPool(\rint corePoolSize, ThreadFactory threadFactory) {\rreturn new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);\r}\rpublic ScheduledThreadPoolExecutor(int corePoolSize,\rThreadFactory threadFactory) {\rsuper(corePoolSize, Integer.MAX_VALUE,\rDEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,\rnew DelayedWorkQueue(), threadFactory);\r}\r  特点：核心线程数量固定，非核心线程数量无限，执行完闲置 10ms 后回收，任务队列为延时阻塞队列。 应用场景：执行定时或周期性的任务。  // 1. 创建 定时线程池对象 \u0026amp; 设置线程池线程数量固定为5\rScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);\r// 2. 创建好Runnable类线程对象 \u0026amp; 需执行的任务\rRunnable task =new Runnable(){\rpublic void run() {\rSystem.out.println(\u0026quot;执行任务啦\u0026quot;);\r}\r};\r// 3. 向线程池提交任务\rscheduledThreadPool.schedule(task, 1, TimeUnit.SECONDS); // 延迟1s后执行任务\rscheduledThreadPool.scheduleAtFixedRate(task,10,1000,TimeUnit.MILLISECONDS);// 延迟10ms后、每隔1000ms执行任务\r 可缓存线程池（CachedThreadPool） public static ExecutorService newCachedThreadPool() {\rreturn new ThreadPoolExecutor(0, Integer.MAX_VALUE,\r60L, TimeUnit.SECONDS,\rnew SynchronousQueue\u0026lt;Runnable\u0026gt;());\r}\rpublic static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {\rreturn new ThreadPoolExecutor(0, Integer.MAX_VALUE,\r60L, TimeUnit.SECONDS,\rnew SynchronousQueue\u0026lt;Runnable\u0026gt;(),\rthreadFactory);\r}\r  特点：无核心线程，非核心线程数量无限，执行完闲置 60s 后回收，任务队列为不存储元素的阻塞队列。 应用场景：执行大量、耗时少的任务。  // 1. 创建可缓存线程池对象\rExecutorService cachedThreadPool = Executors.newCachedThreadPool();\r// 2. 创建好Runnable类线程对象 \u0026amp; 需执行的任务\rRunnable task =new Runnable(){\rpublic void run() {\rSystem.out.println(\u0026quot;执行任务啦\u0026quot;);\r}\r};\r// 3. 向线程池提交任务\rcachedThreadPool.execute(task)\r 单线程化线程池（SingleThreadExecutor） public static ExecutorService newSingleThreadExecutor() {\rreturn new FinalizableDelegatedExecutorService\r(new ThreadPoolExecutor(1, 1,\r0L, TimeUnit.MILLISECONDS,\rnew LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()));\r}\rpublic static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {\rreturn new FinalizableDelegatedExecutorService\r(new ThreadPoolExecutor(1, 1,\r0L, TimeUnit.MILLISECONDS,\rnew LinkedBlockingQueue\u0026lt;Runnable\u0026gt;(),\rthreadFactory));\r}\r  特点：只有 1 个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。 应用场景：不适合并发但可能引起 IO 阻塞性及影响 UI 线程响应的操作，如数据库操作、文件操作等。  // 1. 创建单线程化线程池\rExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();\r// 2. 创建好Runnable类线程对象 \u0026amp; 需执行的任务\rRunnable task =new Runnable(){\rpublic void run() {\rSystem.out.println(\u0026quot;执行任务啦\u0026quot;);\r}\r};\r// 3. 向线程池提交任务\rsingleThreadExecutor.execute(task);\r 对比 线程池模板 大佬链接====》Spring线程池配置模板- 博客园 \n@EnableAsync\r@Configuration\rpublic class LogThreadPoolConfig {\r@Bean(name = \u0026quot;logThreadPool\u0026quot;)\rpublic ThreadPoolTaskExecutor LogThreadPoolTask() {\rThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\rLogThreadPoolProperties properties = this.logThreadPoolProperties();\rexecutor.setCorePoolSize(properties.getCorePoolSize());\rexecutor.setMaxPoolSize(properties.getMaxPoolSize());\rexecutor.setQueueCapacity(properties.getQueueCapacity());\rexecutor.setKeepAliveSeconds(properties.getKeepAliveSeconds());\rexecutor.setThreadNamePrefix(properties.getThreadName());\rswitch (properties.getRejectedExecutionHandler()) {\rcase \u0026quot;abortPolicy\u0026quot;:\rexecutor.setRejectedExecutionHandler(new AbortPolicy());\rbreak;\rcase \u0026quot;callerRunsPolicy\u0026quot;:\rexecutor.setRejectedExecutionHandler(new CallerRunsPolicy());\rbreak;\rcase \u0026quot;discardOldestPolicy\u0026quot;:\rexecutor.setRejectedExecutionHandler(new DiscardOldestPolicy());\rbreak;\rcase \u0026quot;discardPolicy\u0026quot;:\rexecutor.setRejectedExecutionHandler(new DiscardOldestPolicy());\rbreak;\rdefault:\rexecutor.setRejectedExecutionHandler(new CallerRunsPolicy());\rbreak;\r}\rexecutor.initialize();\rreturn executor;\r}\r@Bean\r@ConfigurationProperties(prefix = \u0026quot;threadpool.log\u0026quot;)\rpublic LogThreadPoolProperties logThreadPoolProperties() {\rreturn new LogThreadPoolProperties();\r}\r//@Getter lombok提供的getset方法生成注解\r//@Setter\r@Configuration\rpublic static class LogThreadPoolProperties {\r/**\r* 线程前缀名\r*/\rprivate String threadName;\r/**\r* 核心线程池大小\r*/\rprivate int corePoolSize;\r/**\r* 最大线程数\r*/\rprivate int maxPoolSize;\r/**\r* 队列大小\r*/\rprivate int queueCapacity;\r/**\r* 线程池维护空闲线程存在时间\r*/\rprivate int keepAliveSeconds;\r/**\r* 拒绝策略\r*/\rprivate String rejectedExecutionHandler;\r}\r}\r 这样就可以在yml文件中配置参数了：\nthreadpool:\rlog:\rthreadName: ThreadPool-log- # 线程池前缀名\rcorePoolSize: 8 # 核心线程池数：IO型推荐设置为cpu核心数*2；cpu型推荐设置为cpu数+1\rmaxPoolSize: 16 # 最大线程池数\rqueueCapacity: 1000 # 线程池阻塞队列容量\rkeepAliveSeconds: 60 # 允许线程空闲时间\r# 拒绝策略 abortPolicy callerRunsPolicy discardOldestPolicy discardPolicy\rrejectedExecutionHandler: callerRunsPolicy\r 使用：\nSpring提供了注解方式来方便我们使用线程池，只需要在要异步处理的方法上加 @Async(\u0026ldquo;你配置的线程池名字\u0026rdquo;)就可以了,注意这个类需要被spring扫描并纳入管理，所以要加@Service、@Component等注解。\n@Service\rpublic class ServiceImpl implements Service {\r@Override\r@Async(\u0026quot;logThreadPool\u0026quot;)\rpublic void addOperationLog(BaseLog baseLog) {\r//你要异步执行的逻辑\r}\r}\r 小总结  ==Executors 的 4 个功能线程池虽然方便，但现在已经不建议使用了，而是建议直接通过使用 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。==  其实 Executors 的 4 个功能线程有如下弊端：\n FixedThreadPool 和 SingleThreadExecutor：主要问题是堆积的请求处理队列均采用 LinkedBlockingQueue，可能会耗费非常大的内存，甚至 OOM。 CachedThreadPool 和 ScheduledThreadPool：主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。  线程池里的线程数量设定为多少比较合适？  这个得看任务类型\n CPU密集型（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。 耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般会大于CPU核心数很多倍 ，参考Brain Goetz专家推荐的计算方法：线程数=CPU核心数*（1+平均等待时间/平均工作时间）  如果需要更精确的线程数量，那就需要根据不同的程序去做压测，这样就能得到比较合适的线程数量。\nThreadLocal 概念 ThreadLocal叫做线程变量，ThreadLocal中填充的变量 属于当前线程，该变量对其他线程而言是隔离的。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。\nThreadLocal 适用于每个线程变量在线程间隔离而在方法或类间共享的场景。\nThreadLocal与Synchronized的区别   ThreadLocal\nThreadLocal则用于线程间的数据隔离。ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象\n  Synchronized\nSynchronized用于线程间的数据共享。利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。\n  使用 public class ThreadLocaDemo {\rprivate static ThreadLocal\u0026lt;String\u0026gt; localVar = new ThreadLocal\u0026lt;String\u0026gt;();\rstatic void print(String str) {\r//打印当前线程中本地内存中本地变量的值\rSystem.out.println(str + \u0026quot; :\u0026quot; + localVar.get());\r//清除本地内存中的本地变量\rlocalVar.remove();\r}\rpublic static void main(String[] args) throws InterruptedException {\rnew Thread(new Runnable() {\rpublic void run() {\rThreadLocaDemo.localVar.set(\u0026quot;local_A\u0026quot;);\rprint(\u0026quot;A\u0026quot;);\r//打印本地变量\rSystem.out.println(\u0026quot;after remove : \u0026quot; + localVar.get());\r}\r},\u0026quot;A\u0026quot;).start();\rThread.sleep(1000);\rnew Thread(new Runnable() {\rpublic void run() {\rThreadLocaDemo.localVar.set(\u0026quot;local_B\u0026quot;);\rprint(\u0026quot;B\u0026quot;);\rSystem.out.println(\u0026quot;after remove : \u0026quot; + localVar.get());\r}\r},\u0026quot;B\u0026quot;).start();\r}\r}\rA :local_A\rafter remove : null\rB :local_B\rafter remove : null\r set() ==向ThreadLocal里面存东西就是向它里面的Map存东西的，然后ThreadLocal把这个Map挂到当前的线程底下==\npublic void set(T value) {\r//1、获取当前线程\rThread t = Thread.currentThread();\r//2、获取线程中的属性 threadLocalMap ,如果threadLocalMap 不为空，\r//则直接更新要保存的变量值，否则创建threadLocalMap，并赋值\rThreadLocalMap map = getMap(t);\rif (map != null)\rmap.set(this, value);\relse\r// 初始化thradLocalMap 并赋值\rcreateMap(t, value);\r}\r 从上面的代码可以看出，ThreadLocal set赋值的时候首先会获取当前线程thread,并获取thread线程中的ThreadLocalMap属性。如果map属性不为空，则直接更新value值，如果map为空，则实例化threadLocalMap,并将value值初始化。\n==ThreadLocalMap呢是当前线程Thread一个叫threadLocals的变量中获取的。每个线程Thread都维护了自己的threadLocals变量，所以在每个线程创建ThreadLocal的时候，实际上数据是存在自己线程Thread的threadLocals变量里面的，别人没办法拿到，从而实现了隔离。==\nThreadLocalMap getMap(Thread t) {\rreturn t.threadLocals;\r}\r static class ThreadLocalMap {\r/**\r* The entries in this hash map extend WeakReference, using\r* its main ref field as the key (which is always a\r* ThreadLocal object). Note that null keys (i.e. entry.get()\r* == null) mean that the key is no longer referenced, so the\r* entry can be expunged from table. Such entries are referred to\r* as \u0026quot;stale entries\u0026quot; in the code that follows.\r*/\rstatic class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; {\r/** The value associated with this ThreadLocal. */\rObject value;\rEntry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) {\rsuper(k);\rvalue = v;\r}\r}\r}\r 可看出ThreadLocalMap是ThreadLocal的内部静态类，而它的构成主要是用Entry来保存数据 ，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。IPHP姬祥todo createMap\nget() public T get() {\r//1、获取当前线程\rThread t = Thread.currentThread();\r//2、获取当前线程的ThreadLocalMap\rThreadLocalMap map = getMap(t);\r//3、如果map数据为空，\rif (map != null) {\r//3.1、获取threalLocalMap中存储的值\rThreadLocalMap.Entry e = map.getEntry(this);\rif (e != null) {\r@SuppressWarnings(\u0026quot;unchecked\u0026quot;)\rT result = (T)e.value;\rreturn result;\r}\r}\r//如果是数据为null，则初始化，初始化的结果，TheralLocalMap中存放key值为threadLocal，值为null\rreturn setInitialValue();\r}\rprivate T setInitialValue() {\rT value = initialValue();\rThread t = Thread.currentThread();\rThreadLocalMap map = getMap(t);\rif (map != null)\rmap.set(this, value);\relse\rcreateMap(t, value);\rreturn value;\r}\r remove() public void remove() {\rThreadLocalMap m = getMap(Thread.currentThread());\rif (m != null)\rm.remove(this);\r}\r remove方法，直接将ThrealLocal 对应的值从当前相差Thread中的ThreadLocalMap中删除。为什么要删除，这涉及到内存泄露的问题。\n如上所说（Local跳转方式，Shimo跳转方式）， ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。\n所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。这样就造成了内存泄露。\nThreadLocal与Thread，ThreadLocalMap之间的关系 ThreadLocal 常见使用场景 参考====》ThreadLocal的应用场景 - sw_kong - 博客园 (cnblogs.com)\n场景的需求：\n 每个线程需要有自己单独的实例 实例需要在多个方法中共享，但不希望变量被多线程共享 ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。  SimpleDateFormat （Java8里的 java.time.format.DateTimeFormatter 是线程安全的 ，由于它调用的parseResolved0 方法入参都是final 修饰的，不可变变量是线程安全的。）\n当时我们使用SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear（），然后调用Calendar.add()。ThreadLocal_敖丙-CSDN博客。如果一个线程先调用了add()然后另一个线程又调用了clear()，这时候parse()方法解析的时间就不对了。\n在这种情况下，每个Thread内都有自己的实例副本，且该副本只能由当前Thread访问到并使用，相当于每个线程内部的本地变量，这也是ThreadLocal命名的含义。因为每个线程独享副本，而不是公用的，所以不存在多线程间共享的问题。\n比如有1000个线程都要用到SimpleDateFormat\npublic class ThreadLocalDemo011 {\rpublic static ExecutorService threadPool = Executors.newFixedThreadPool(16);\rpublic static void main(String[] args) throws InterruptedException {\rfor (int i = 0; i \u0026lt; 1000; i++) {\rint finalI = i;\rthreadPool.submit(() -\u0026gt; {\rString data = new ThreadLocalDemo011().date(finalI);\rSystem.out.println(data);\r});\r}\rthreadPool.shutdown();\r}\rpublic static Integer id= 0;\rprivate String date(int seconds){\rDate date = new Date(1000 * seconds);\rid++;\rSystem.out.println(id+\u0026quot;=============\u0026quot;);\rSimpleDateFormat simpleDateFormat = new SimpleDateFormat(\u0026quot;mm:ss\u0026quot;);\rreturn simpleDateFormat.format(date);\r}\r}\r 可以看出，我们用了一个16线程的线程池，并且给这个线程池提交了1000次任务。每个任务中它做的事情和之前是一样的，还是去执行date方法，并且在这个方法中创建一个simpleDateFormat 对象。近1000个simpleDateFormat 对象会被创建。\n这么多对象的创建是有开销的，并且在使用完之后的销毁同样是有开销的，同时存在在内存中也是一种内存的浪费。\n我们可能会想到，要不所有的线程共用一个 simpleDateFormat 对象？但是simpleDateFormat 又不是线程安全的，我们必须做同步，比如使用synchronized加锁。到这里也许就是我们最终的一个解决方法。但是使用synchronized加锁会陷入一种排队的状态，多个线程不能同时工作，这样一来，整体的效率就被大大降低了。\n 使用ThreadLocal  对这种场景，ThreadLocal再合适不过了，ThreadLocal给每个线程维护一个自己的simpleDateFormat对象，这个对象在线程之间是独立的，互相没有关系的。这也就避免了线程安全问题。与此同时，simpleDateFormat对象还不会创造过多，线程池一共只有 16 个线程，所以需要16个对象即可。\npublic class ThreadLocalDemo04 {\rpublic static ExecutorService threadPool = Executors.newFixedThreadPool(16);\rpublic static void main(String[] args) throws InterruptedException {\rfor (int i = 0; i \u0026lt; 1000; i++) {\rint finalI = i;\rthreadPool.submit(() -\u0026gt; {\rString data = new ThreadLocalDemo04().date(finalI);\rSystem.out.println(data);\r});\r}\rthreadPool.shutdown();\r}\rprivate String date(int seconds){\rDate date = new Date(1000 * seconds);\rSimpleDateFormat dateFormat = ThreadSafeFormater.dateFormatThreadLocal.get();\rreturn dateFormat.format(date);\r}\r}\rclass ThreadSafeFormater{\rpublic static Integer id= 0;\rpublic static ThreadLocal\u0026lt;SimpleDateFormat\u0026gt; dateFormatThreadLocal = ThreadLocal.withInitial(() -\u0026gt; {\rid++;\rSystem.out.println(id+\u0026quot;=============\u0026quot;);\rreturn new SimpleDateFormat(\u0026quot;mm:ss\u0026quot;);\r});\r}\r   结果：\n可以看出只创建了16个SimpleDateFormat对象。\n  1=============\r4=============\r5=============\r6=============\r3=============\r7=============\r2=============\r8=============\r9=============\r10=============\r11=============\r13=============\r12=============\r14=============\r15=============\r16=============\r00:09\r00:16\r00:17\r........\r........\r16:05\r16:04\r16:03\r16:02\r  问题：  这种情况每个线程的SimpleDataFormat的parse()方法，在一个任务执行后其他任务继续使用这个线程执行任务时，会不会造成数据混乱。   答案  不会，SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear()清除数据，然后调用Calendar.add()添加数据。    用户信息（类似线程内的全局变量） 每个线程内需要保存类似于全局变量的信息（例如在拦截器中获取的用户信息），可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享（因为不同线程获取到的用户信息不一样）。\n例如，用 ThreadLocal 保存一些业务内容（用户权限信息、从用户系统获取到的用户名、用户ID 等），这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。\n在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，避免了将这个对象（如 user 对象）作为参数传递的麻烦。\n比如说我们是一个用户系统，那么当一个请求进来的时候，一个线程会负责执行这个请求，然后这个请求就会依次调用service-1()、service-2()、service-3()、service-4()，这4个方法可能是分布在不同的类中的。\npackage com.kong.threadlocal;\rpublic class ThreadLocalDemo05 {\rpublic static void main(String[] args) {\rUser user = new User(\u0026quot;jack\u0026quot;);\rnew Service1().service1(user);\r}\r}\rclass Service1 {\rpublic void service1(User user){\r//给ThreadLocal赋值，后续的服务直接通过ThreadLocal获取就行了。\rUserContextHolder.holder.set(user);\rnew Service2().service2();\r}\r}\rclass Service2 {\rpublic void service2(){\rUser user = UserContextHolder.holder.get();\rSystem.out.println(\u0026quot;service2拿到的用户:\u0026quot;+user.name);\rnew Service3().service3();\r}\r}\rclass Service3 {\rpublic void service3(){\rUser user = UserContextHolder.holder.get();\rSystem.out.println(\u0026quot;service3拿到的用户:\u0026quot;+user.name);\r//在整个流程执行完毕后，一定要执行remove\rUserContextHolder.holder.remove();\r}\r}\rclass UserContextHolder {\r//创建ThreadLocal保存User对象\rpublic static ThreadLocal\u0026lt;User\u0026gt; holder = new ThreadLocal\u0026lt;\u0026gt;();\r}\rclass User {\rString name;\rpublic User(String name){\rthis.name = name;\r}\r}\r 守护线程 面试题 线程池创建的4中方法 Local跳转方式，Shimo跳转方式\n任务加入的线程池的流程 Local跳转方式，Shimo跳转方式\n线程池的7个参数。拒绝策略。 参数：Local跳转方式，Shimo跳转方式\n拒绝策略：Local跳转方式，Shimo跳转方式\n线程池中如何拿到线程的执行结果 线程池中 submit()和 execute()方法有什么区别？   execute()：只能执⾏ Runnable 类型的任务。\n  submit()：可以执⾏ Runnable 和 Callable 类型的任务。\n  死锁 两线程都有各自的锁，并都尝试去获取独占对方的锁，就会发生阻塞的现象。\n解释下生产消费模型 生产者消费者能够解决的问题如下：\n 生产与消费的速度不匹配 软件开发过程中解耦  生产者生产，消费者消费，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架满的时候，消费者可以从货架上拿走商品，生产者此时等待货架的空位，这样不断的循环。那么在这个过程中，生产者和消费者是不直接接触的，所谓的‘货架’其实就是一个==阻塞队列==，生产者生产的产品不直接给消费者消费，而是仍给阻塞队列，这个阻塞队列就是来解决生产者消费者的强耦合的。就是生产者消费者模型。TP①，TP②\n参考  ThreadLocal原理分析与使用场景 - 阿凡卢 - 博客园 (cnblogs.com) ThreadLocal的应用场景 - sw_kong - 博客园 (cnblogs.com) ThreadLocal_敖丙-CSDN博客 CSDN博客_生产者消费者模型 Java8之Consumer、Supplier、Predicate和Function攻略 博客园 ","id":9,"section":"posts","summary":"","tags":["Thread"],"title":"Thread","uri":"https://gb.ytte.top/1/01/01/thread/","year":"0001"},{"content":"使用typora写文档传图片，再上传石墨等网站的好方法 1. typora下载 typora开始收费，我们可以使用不收费的老版本 下载链接\n2. typora图床 picgotypora不像word，word可以直接将上传的图片保存在文件当中，而typora不行。但是typora支持picgo插件的使用，所以，我们下在picgo 下载链接\n3. 七牛云和picgo的使用，二级域名（如果不想弄直接第4步骤） 注册七牛云 ，并开通对象存储 picgo使用七牛云图床 - 知乎 。为七牛云配置二级域名（前提是有了一级域名）：二级域名-石墨\n4. picgo 配置： 进入picgo，点击左侧的图床设置，选择七牛图床。按下图所示填写配置，SecretKey向 j j 索取。\n SbOIcbA56xQGcpZyyLDtuARvi3COHhlBxa-IZxDi\nytte-picgo\nhttps://blogimg.ytte.top/\nz2\nimg-sunsifan/或者是img-wuhao\n 伍昊：\n孙思凡：\n将最后 一项，指定存储路径更改为：img-sunsifan。\n5. typora设置   打开typora后，\n  点击左上角文件，\n  点击偏好设置，\n  点击图像，\n  如图进行配置，\n   成功就会出现如图信息，  ==大功告成==\n6. picgo的使用 使用截图软件截图，打开picgo点记左侧的上传区，点击剪切板图片上传，上传成功后自动将图片地址返回到剪切板当中。\n 注意：如果直接截图后直接粘贴到typora文中，使用的是标签，在有的编辑器不能正常识别（比如石墨），所以最好先按上面方法。\n","id":10,"section":"posts","summary":"","tags":["typora"],"title":"typora","uri":"https://gb.ytte.top/1/01/01/typora/","year":"0001"},{"content":"一级域名 1. 购买域名  地址：域名_域名查询_域名注册_.com_.cn-阿里云 (aliyun.com)  任何服务，都可以不买，只购买域名使用权\n  选择个人\n  选择个人信息\n    未实名认证的，进行阿里云个人实名认证 (aliyun.com)\n  选择已阅读，购买\n  2. 等待审核 进入控制台，点击域名列表可以看到，域名正在审核\n","id":11,"section":"posts","summary":"","tags":["域名"],"title":"一级域名","uri":"https://gb.ytte.top/1/01/01/%E4%B8%80%E7%BA%A7%E5%9F%9F%E5%90%8D/","year":"0001"},{"content":"二级域名 给七牛云配置阿里云所属顶级域名的二级域名\n1. 首先要有一级域名 一级域名-石墨\n2.配置七牛云 尽量选择华南地区（便宜）。\n 点击域名   点击域名绑定   点击创建 如下图，说明创建成功，    点击复制CNAME（七牛云页面不要关闭）\n  进入阿里云控制台\n  点击域名=\u0026gt;点击域名列表\n  点击解析\n  点击添加记录 =\u0026gt;点击确认\n这里的主机记录和记录值前缀要一致\n  如果状态显示正常，即可\n  再回到七牛云中，观察是否设置成功\n ","id":12,"section":"posts","summary":"","tags":["域名"],"title":"二级域名","uri":"https://gb.ytte.top/1/01/01/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/","year":"0001"},{"content":"谷粒商城步骤笔记 使用人人代码生成器 视频====》谷粒商城——p17\n  clone人人代码生成器\n  放进项目中加入模块\n  在application.yml修改数据库相关信息\n  在generator.properties中修改参数\nmainPath=com.atguigu\r#包名\rpackage=com.atguigu.gulimall\rmoduleName=product\r#作者\rauthor=yttejx\r#Email\remail=1026190684@qq.com\r#表前缀(类名不会包含表前缀)\rtablePrefix=pms_\r   更改renren-generator的resources的template的Controller模板中@RequiresPermissions注解和导包注释掉，以后再导入使用。\n  启动renren-generator的Application。网页访问localhost:80，点击显示全部表格，全选表格，点击生成代码。\n  将生成的代码中main包复制粘贴到product项目下。\n  新建模块（maven）取名，gulimall_common（项目的公共资源全部放在这里）\n  查看product项目中报错信息。将相应的pom 和类（renren自己创建的工具类）加入到common项目中\n从renren-faster中导入\n  包：\n exception utils  Constant PageUtils Query R validator xss  去掉XssFilter和XssHttpServletRequestWrapper，是防跨站脚本攻击的，以后用springsecurity来实现。 这里需要导包Servlet，同时设置scope 为provided，因为tomcat内有Servlet        pom：\n  \u0026lt;properties\u0026gt;\r\u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt;\r\u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt;\r\u0026lt;mybatis.plus.boot.starter.version\u0026gt;3.5.1\u0026lt;/mybatis.plus.boot.starter.version\u0026gt;\r\u0026lt;lombok.version\u0026gt;1.18.22\u0026lt;/lombok.version\u0026gt;\r\u0026lt;commons.lang.version\u0026gt;2.6\u0026lt;/commons.lang.version\u0026gt;\r\u0026lt;httpcore.version\u0026gt;4.4.15\u0026lt;/httpcore.version\u0026gt;\r\u0026lt;shiro.version\u0026gt;1.4.0\u0026lt;/shiro.version\u0026gt;\r\u0026lt;commons.io.version\u0026gt;2.5\u0026lt;/commons.io.version\u0026gt;\r\u0026lt;mysql.connector.version\u0026gt;8.0.28\u0026lt;/mysql.connector.version\u0026gt;\r\u0026lt;/properties\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;${mybatis.plus.boot.starter.version}\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;commons-lang\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;commons-lang\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;${commons.lang.version}\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore --\u0026gt;\r\u0026lt;!--java 发送http请求--\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;httpcore\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;${httpcore.version}\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;commons-io\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;${commons.io.version}\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;shiro-core\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;${shiro.version}\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;shiro-spring\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;${shiro.version}\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;${mysql.connector.version}\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt;\r\u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt;\r\u0026lt;!-- tomcat内有Servlet--\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;jakarta.validation\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;jakarta.validation-api\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;2.0.2\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r   product的UndoLogEntity的rollbackInfo属性，数据库中使用的是Longblob，实体类中使用byte[]。\n  配置\u0026amp;测试服务的crud功能 视频====》谷粒商城——p18\n  每个项目都需要crud，所以在common中导入mysql驱动\n  配置数据源\nspring:\rdatasource:\rusername: root\rpassword: as123\rurl: jdbc:mysql://localhost:3380/gulimall_pms?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;useSSL=false\u0026amp;serverTimezone=Asia/Shanghai\rdriver-class-name: com.mysql.cj.jdbc.Driver\r   配置mybatis-plus\n 使用MapperScan  @MapperScan(\u0026quot;com.atguigu.gulimall.product.dao\u0026quot;)\r   告诉mybatis-plus，sql映射文件位置\n使用自增主键（以后数据量大了在使用其他主键策略）\nmybatis-plus:\rmapper-locations: classpath*:/mapper/**/*.xml\rglobal-config:\rdb-config:\rid-type: auto\r   crud测试\n@Test\rvoid contextLoads() {\rBrandEntity brandEntity = new BrandEntity();\rbrandEntity.setName(\u0026quot;华为\u0026quot;);\rbrandService.save(brandEntity);\rSystem.out.println(\u0026quot;保存成功----------\u0026quot;);\rbrandEntity.setBrandId(1L);\rbrandEntity.setDescript(\u0026quot;华为手机\u0026quot;);\rbrandService.updateById(brandEntity);\rSystem.out.println(\u0026quot;更新成功---------\u0026quot;);\rList\u0026lt;BrandEntity\u0026gt; list = brandService.list(new LambdaQueryWrapper\u0026lt;BrandEntity\u0026gt;().eq(BrandEntity::getBrandId, \u0026quot;1\u0026quot;));\rlist.forEach(System.out::println);\rSystem.out.println(\u0026quot;查询成功---------\u0026quot;);\r}\r     逆向工程生成所有代码 视频====》p19\n分","id":13,"section":"posts","summary":"","tags":["谷粒商城"],"title":"谷粒商城步骤笔记","uri":"https://gb.ytte.top/1/01/01/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E6%AD%A5%E9%AA%A4%E7%AC%94%E8%AE%B0/","year":"0001"}],"tags":[{"title":"Https","uri":"https://gb.ytte.top/tags/https/"},{"title":"index","uri":"https://gb.ytte.top/tags/index/"},{"title":"JVM","uri":"https://gb.ytte.top/tags/jvm/"},{"title":"MySQL","uri":"https://gb.ytte.top/tags/mysql/"},{"title":"SpringBoot","uri":"https://gb.ytte.top/tags/springboot/"},{"title":"SpringCloud","uri":"https://gb.ytte.top/tags/springcloud/"},{"title":"Thread","uri":"https://gb.ytte.top/tags/thread/"},{"title":"typora","uri":"https://gb.ytte.top/tags/typora/"},{"title":"ZooKeeper","uri":"https://gb.ytte.top/tags/zookeeper/"},{"title":"域名","uri":"https://gb.ytte.top/tags/%E5%9F%9F%E5%90%8D/"},{"title":"基础","uri":"https://gb.ytte.top/tags/%E5%9F%BA%E7%A1%80/"},{"title":"谷粒商城","uri":"https://gb.ytte.top/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"}]}