{"categories":[{"title":"bolg","uri":"https://gb.ytte.top/categories/bolg/"},{"title":"git","uri":"https://gb.ytte.top/categories/git/"},{"title":"java","uri":"https://gb.ytte.top/categories/java/"},{"title":"JVM","uri":"https://gb.ytte.top/categories/jvm/"},{"title":"ZooKeeper","uri":"https://gb.ytte.top/categories/zookeeper/"},{"title":"数据库","uri":"https://gb.ytte.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"服务器","uri":"https://gb.ytte.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"杂项","uri":"https://gb.ytte.top/categories/%E6%9D%82%E9%A1%B9/"},{"title":"消息队列","uri":"https://gb.ytte.top/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"title":"计算机网络","uri":"https://gb.ytte.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"设计模式","uri":"https://gb.ytte.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"面试题","uri":"https://gb.ytte.top/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"项目","uri":"https://gb.ytte.top/categories/%E9%A1%B9%E7%9B%AE/"}],"posts":[{"content":"视频教程 ———— 尚硅谷\n2022-4-18 17:33:01\n 简介 设计模式常用的七大原则：\n 单一职责原则 接口隔离原则 依赖倒转原则 里氏替换原则 开闭原则ocp 迪米特法则 合成复用原则  单一职责原则  视频 p6 ———— 尚硅谷\n 概念 对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。 当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1,A2。\n接口隔离原则 依赖倒转原则 里氏替换原则 开闭原则ocp 迪米特法则 合成复用原则  搞定！\n人生无常，大肠包小肠！\n继续学习吧！\n","id":0,"section":"posts","summary":"\u003cp\u003e视频教程  ———— \u003ca href=\"https://www.bilibili.com/video/BV1G4411c7N4?spm_id_from=333.337.search-card.all.click\"\u003e尚硅谷\u003c/a\u003e\u003c/p\u003e","tags":["java"],"title":"设计模式","uri":"https://gb.ytte.top/2022/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","year":"2022"},{"content":"文段太长的情况请使用区域高亮标出重要文字 未做的在尾部表示 ：谁 todo 。例如姬祥todo 基础篇\n JDK 和 JRE 有什么区别？ JDK：Java Development Kit 的简称，java 开发⼯具包，提供了 java 的开发环境和运⾏环境。 JRE：Java Runtime Environment 的简称，java 运⾏环境，为 java 的运⾏提供了所需环境。 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac， java 程序调试和分析的⼯具。 == 和 equals 的区别是什么？ == 对于基本类型和引⽤类型 == 的作⽤效果是不同的，如下所示： 基本类型：⽐较的是值本身是否相同； 引⽤类型：⽐较的是引⽤地址是否相同；  equals equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals ⽅法，把它变成了值⽐较。\n3、两个对象的 hashCode()相同，则 equals()也不⼀定为 true 先看视频在回来看文字有助于理解：\n官方的解释中： 1）、hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的； 2）、如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同； 3）、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点； 4）、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。 通俗解释： 1、hashcode是用来查找的 例如内存中有这样的位置 0 1 2 3 4 5 6 7\n而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。 但如果用hashcode那就会使效率提高很多。 那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。\n2、但是如果两个类有相同的hashcode怎么办（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。 也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。\n那么。重写了equals()，为什么还要重写hashCode()呢？ 想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊 代码解释 public class HashTest { private int i; public int getI() { return i; } public void setI(int i) { this.i = i; } public int hashCode() { return i % 10; } public final static void main(String[] args) { HashTest a = new HashTest(); HashTest b = new HashTest(); a.setI(1); b.setI(1); Setset = new HashSet(); set.add(a); set.add(b); System.out.println(a.hashCode() == b.hashCode()); System.out.println(a.equals(b)); System.out.println(set); } } 结果： true false [com.ubs.sae.test.HashTest@1, com.ubs.sae.test.HashTest@1] 以上这个示例，我们只是重写了hashCode方法，从上面的结果可以看出，虽然两个对象的hashCode相等，但是实际上两个对象并不是相等；，我们没有重写equals方法，那么就会调用object默认的equals方法，是比较两个对象的引用是不是相同，显示这是两个不同的对象，两个对象的引用肯定是不同的。这里我们将生成的对象放到了HashSet中，而HashSet中只能够存放唯一的对象，也就是相同的（适用于equals方法）的对象只会存放一个，但是这里实际上是两个对象a,b都被放到了HashSet中。\n此时我们把equals方法给加上： public class HashTest { private int i; public int getI() { return i; } public void setI(int i) { this.i = i; } public boolean equals(Object object) { if (object == null) { return false; } if (object == this) { return true; } if (!(object instanceof HashTest)) { return false; } HashTest other = (HashTest) object; if (other.getI() == this.getI()) { return true; } return false; } public int hashCode() { return i % 10; } public final static void main(String[] args) { HashTest a = new HashTest(); HashTest b = new HashTest(); a.setI(1); b.setI(1); Setset = new HashSet(); set.add(a); set.add(b); System.out.println(a.hashCode() == b.hashCode()); System.out.println(a.equals(b)); System.out.println(set); } } 结果： true true [com.ubs.sae.test.HashTest@1] 从结果我们可以看出，现在两个对象就完全相等了，HashSet中也只存放了一份对象。\n4、关于字节 字节是我们常见的计算机中最小存储单元。计算机存储任何的数据，都是以字节的形式存储。 8个bit（二进制位） 0000-0000表示为1个字节，写成1 byte或者1 B。\n8 bit = 1 B 1024 B =1 KB 1024 KB =1 MB 1024 MB =1 GB 1024 GB = 1 TB ps：实际开发中可能会定义各种byte数组，要对空间大致有印象。 5、关于虚拟机(知道虚拟机是什么，作用是什么) JVM（Java Virtual Machine ）： Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 如下图： 图片: https://uploader.shimo.im/f/qVVm5cukxLZ2NvCX.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 6、java程序开发的三个步骤 1.编写源程序\n2.编译源程序 3.运行 例如：Hello.java 由javac命令编译成 Hello.class，即字节码文件，再由jvm编译解释执行运行。 7.数据类型（重要） Java的数据类型分为两大类： 基本数据类型：包括 整数 、浮点数 、字符 、布尔 。 (四类八种) 引用数据类型：包括 类 、数组 、接口 。 图片: https://uploader.shimo.im/f/1F4zAAzf9F76TNDz.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8\n long类型：建议数据后加L表示。 2.float类型：建议数据后加F表示。 3.ASCII码中，一个英文字母占一个字节的空间，一个中文汉字占两个字节的空间；2、UTF-8编码中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。 要求：要能记熟。多看 ps:之前面试博彦科技初级程序员，让写过，不要小视。 8.数据类型转换 将取值范围小的类型自动提升为范围大的类型 范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为 int 。 9.强制转换 基本数据类型 将取值范围大的类型 强制转换成 取值范围小的类型 ，byte，short，int，long，float，double 数值类型不要求显示强制类型转换，自动进行转换。 从其他数值类型转换为char类型时，必须进行强制转换。将char类型转换为其他数值类型时，除了byte、short必须强制转换之外，int、long、float、double都不用强制转换。 数据类型 变量名 =（数据类型）被转数据值； 引用类型 父类引用可以指向子类对象，子类引用不能指向父类对象。 把子类对象直接赋给父类引用叫做向上转型，向上转型不用强制转型，如Father f1=new Son()， 把指向子类对象的父类引用赋给子类引用叫做向下转型，要强制转型，如Son s1 = (Son)f1。向上转型会丢失子类特有的方法，但是子类override父类的方法，子类方法有效。 非继承类相互转换会报错 10.ASCII编码表 （是什么ASCII编码？） 图片: https://uploader.shimo.im/f/mYbZoRzlQsJhsRuB.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 记住常用的几个： 图片: https://uploader.shimo.im/f/uyGSR81YF2Bj3o92.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 11.运算符 %：取模运算，两个数字相除取余数 a++ ++a的区别 图片: https://uploader.shimo.im/f/aSeSH25fafT5nkCF.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 加号在拼接字符串中的作用： 图片: https://uploader.shimo.im/f/fmDy2yS3f6OvLUkU.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 逻辑与或非取反的符号：|| \u0026amp;\u0026amp; ！ 三元运算符：  图片: https://uploader.shimo.im/f/INeYgv8sLvokoyvV.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 12.方法的入门 图片: https://uploader.shimo.im/f/MoJeFPEd8znE6nTk.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 13.类型 if else switch语句 for循环 while循环 do-while循环 死循环（while(true)） 嵌套循环 break终止循环，continue结束本次循环，进行下一次循环 14.Idea,方法(day04) idea和方法的基本知识点就不赘述了 方法重载 图片: https://uploader.shimo.im/f/PrsEiT45GnoHFnBV.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 15.数组（day05） 1.数组的定义与访问 数组的定义（三种） 图片: https://uploader.shimo.im/f/1cD70Tv9Fk8bNHar.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 图片: https://uploader.shimo.im/f/prGpqtPRlOxAzkHR.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 图片: https://uploader.shimo.im/f/TFj1ikuz5wPzDW1d.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 数组的访问 数组名[索引] 数组的索引从0开始 2.数组原理内存图 图片: https://uploader.shimo.im/f/9CznENKAqQmSFWYm.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 图如下： 图片: https://uploader.shimo.im/f/BcBbjT1hcjOYWeX2.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 两个变量指向一个数组： 图片: https://uploader.shimo.im/f/s61jvjdUfpLCy1KY.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8\n3.数组的常见操作 数组越界异常 数组空指针异常 数组的遍历 图片: https://uploader.shimo.im/f/jlI4jv93TFYTLlLo.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 数组获取最大元素 数组反转 图片: https://uploader.shimo.im/f/sAA2abYxTEi1SZuE.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 import java.util.; public class RunoobTest { / 使用 java.util.Arrays.asList(array) 方法*/ static void reverse(Integer a[]) { Collections.reverse(Arrays.asList(a)); System.out.println(Arrays.asList(a)); } public static void main(String[] args) { Integer [] arr = {10, 20, 30, 40, 50}; reverse(arr); } }\n4.数组作为方法参数和返回值 数组作为方法参数传递，传递的参数是数组内存的地址。\nPs：方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.\n16.面向对象思想 面向对象思想概述 类与对象 类的定义 对象的使用 图片: https://uploader.shimo.im/f/jKKBoVBAsr61mNjj.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8\n类与对象的练习 对象内存图 成员变量和局部变量的区别 位置如下图： 图片: https://uploader.shimo.im/f/SvYFfH9w6upH3XFm.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 区别总结： 图片: https://uploader.shimo.im/f/x7VJYU3wLyxJVHr2.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 17.封装 封装的概述 封装的步骤 封装的操作-private关键字 封装优化-this关键字 封装优化-构造方法 图片: https://uploader.shimo.im/f/foM70PDYnN6QeVqj.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 标准代码-javaBean 图片: https://uploader.shimo.im/f/nbuuHpwlLQjR3tV0.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8\n18.api 图片: https://uploader.shimo.im/f/jNEMSKGibOHfos35.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 19.Scanner 20.Random 21.ArrayList 图片: https://uploader.shimo.im/f/oF6HdlRYATNJOqCc.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 常用方法 图片: https://uploader.shimo.im/f/7cCtFr7tu6KgYOjn.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 如何存储基本类型？得用包装类 图片: https://uploader.shimo.im/f/FdN7nnvKPkeZM7SL.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8\n22.String类 字符串的只创建后不能更改 因String对象是不可变的，所以可以被共享 \u0026ldquo;abc\u0026rdquo; 等效于 char[] data={ \u0026lsquo;a\u0026rsquo; , \u0026lsquo;b\u0026rsquo; , \u0026lsquo;c\u0026rsquo; } 。 构造方法 图片: https://uploader.shimo.im/f/jGvgMN3rIMXyLT72.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 判断功能方法 图片: https://uploader.shimo.im/f/8JD2j3tWFDhegNo4.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 获取功能的方法 图片: https://uploader.shimo.im/f/TfvINJJyUwN8gaJx.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 转换功能的方法 图片: https://uploader.shimo.im/f/eWQOgxT9nRAODOe2.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 分隔功能的方法 图片: https://uploader.shimo.im/f/t9MJ8VczKqjq3URu.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 23.static关键字 图片: https://uploader.shimo.im/f/LYlATNNzXKqLWwZK.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 定义和使用格式 静态原理图解 静态代码块 图片: https://uploader.shimo.im/f/ELUJ7iUOGHkf4azl.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 图片: https://uploader.shimo.im/f/VbuGPw5P06G4fKA4.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 24.Arrays类 图片: https://uploader.shimo.im/f/p2HaE6nS4nMqCPzg.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 操作数组的方法 图片: https://uploader.shimo.im/f/7xKgblfv79SG7Ef8.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 图片: https://uploader.shimo.im/f/yfFh3UwSz9cb2WTx.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 25.Maths类 图片: https://uploader.shimo.im/f/THpm2gXHwGt3Xjow.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 基本运算的方法 图片: https://uploader.shimo.im/f/2hQzyxaDfNkPZHGV.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 图片: https://uploader.shimo.im/f/Cl6cDfOVlWtxf7Vh.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 26.继承 图片: https://uploader.shimo.im/f/vInEI2dFeV0laMJw.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 继承的关键字是extend 访问变量时，注意理解super关键字和this关键字 继承只支持单继承，不能支持多继承 27.抽象类 图片: https://uploader.shimo.im/f/WJOq7i0lqDyoQOqy.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 关键字abstract 举例： public abstract void run()； 如果一个类包含抽象方法，那么该类一定是抽象类 继承抽象类的子类必须重写父类所有的抽象方法 抽象类不能创建对象 抽象类中可以有构造方法 抽象类中不一定有抽象方法 继承的综合案例：发红包 待补充详细~~~~~~\n28.接口 图片: https://uploader.shimo.im/f/18Sd9YuucQq29m13.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 关键字interface，它不是类，而是一种数据引用类型 重复的逻辑封装到私有方法上，供静态方法调用 接口中无法定义成员变量，但是可以定义常量 接口没有构造方法，无法创建对象 接口中，没有静态代码块 29.多态 多态的体现 图片: https://uploader.shimo.im/f/soVQudtwS68XFelO.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 当使用多态调用方法时，先检查父类中有没有此方法，如果没有则编译报错，如果有，执行的是子类的重写方法。 引用类型转换：当父类引用指向一个子类对象时，就是一个向上转型。 instanceof 关键字，判断某个对象是不是某个类型。 接口多态的实例\u0026mdash;-笔记本电脑\n30.final 不可改变，用于修饰类，方法，和变量 被修饰的类无法继承 被修饰的方法无法重写 被修饰的变量无法更改 31.权限修饰符 public protected default private 图片: https://uploader.shimo.im/f/w5gsghHMuIRQk4kh.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 32.内部类(工作中基本没用到过，略) 匿名内部类 图片: https://uploader.shimo.im/f/OGcJYziztiN2Z9OF.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 33.引用类型用法总结 class作为成员变量 interface作为成员变量 接口作为参数时，传递的是它的子类对象 接口作为返回值类型的时候，返回它的子类对象 34.发红包案例\u0026mdash;\u0026mdash;界面版本\n35.String类能被继承吗，为什么？ 不能被继承。在string类当中类本身被final修饰，而被final修饰的类、方法、变量都是都是不能被继承的 《编程思想》书当中说到： final类不能被继承，没有子类，final类中的方法默认是final的。\nfinal方法不能被子类的方法覆盖，但可以被继承。 final成员变量表示常量，只能被赋值一次，赋值后值不再改变。\nfinal不能用于修饰构造方法。\n36.各种集合差异 图片: https://uploader.shimo.im/f/1CkTo9gcL4VLRLhd.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 图片: https://uploader.shimo.im/f/MB1Q7RUC1izmBC3C.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 HashMap与HashTable的异同：==\u0026gt;超链接### 关于hash算法见下方高级篇 集合 1）、说说你对Java集合的理解 集合就是用存储相关数据的一种形式，主要包括两大接口Collection接口和Map接口以及相关的工具类（Iterator迭代器接口、Enumeration枚举类、Arrays和Colletions）。\n2）、ArrayList和LinkedList的区别 ArrayList是基于数组实现的，无序，查找快，增删慢，每次扩容为原来的0.5倍 Linkedlist是基于双向链表实现的，有序，查找慢，增删快，基于双向链表没有固定扩容大小，用多少扩多大，两头均可扩容 引申：扩容机制 姬祥todotooearly\n3）、它们都线程安全吗？如何得到线程安全的List？ 需要将list 的每个方法加上同步关键字。其中Vector是线程安全的，是基于数组实现的，效率慢，查找快，增删慢，每次扩容原来1倍的大小。\n4）、CopyOnWriteArrayList用过吗？优缺点？ReentrantReadWriteLock用过吗？优缺点？ 详细资料见===\u0026gt;CopyOnWriteArrayList\nCopyOnWriteArrayList 是满足 CopyOnWrite 的 ArrayList，CopyOnWriteArrayList 类的所有可变操作（add，set等等）都是通过创建底层数组的新副本来实现的。被修改的时候，是对原有数据进行一次拷贝，将修改的内容写入副本中。写完之后，再将修改完的副本替换成原来的数据，再将原来指向的内存指针指到新的内存，原来的内存就可以被回收，这样就可以保证写操作不会影响读操作。 读到旧的数据，因为开始读的那一刻已经确定了读的对象是旧对象。 CopyOnWriteList用于读多写少的并发场景。比如白名单，黑名单等场景。\n优点：读写分离，读时读取旧数据，写操作新的副本对象，并发读操作不影响并发写的操作。 缺点： ①、内存占用问题，读操作时复制新的副本对象，这时堆中就会同时存在两个CopyOnWriteArrayList对象，如果CopyOnWriteArrayList本身就是个大对象，再复制新副本 很有可能造FullGC，从而影响服务器的用户线程停顿。 ②、数据一致性问题：读时如若正在进行写操作，那读的就是旧对象。再等写操作完成就是新对象。如果在写数据的时候立马能读到写入的数据，CopyOnWriteArrayList就不适合了。\nReentrantReadWriteLock 详细资料===\u0026gt; java读写锁(ReentrantReadWriteLock) ReentrantReadWriteLock的锁策略有两种，分为公平策略和非公平策略，相比之下，非公平策略的吞吐量较大，所以ReentrantReadWriteLock默认使用的是非公平策略 总结： 当全局处于写锁的情况，一旦任何一个线程1获取了写锁，除了该线程自己，其它线程都将无法获取读锁和写锁，这时候，线程1再次请求一个读锁，这是允许的，但反过来如果一个线程先获取了读锁，再获取写锁则是不行的 当全局处于读锁状态，二者有区别。 公平策略下，线程1获取读锁，不允许后续不管读还是写获得锁；线程1再次获取读锁处于重入状态，且队列第一个不是写，紧随其后的其他读可以获得锁，至于数量不明 姬祥todo 非公平策略下，线程1获取读锁，队列中第一个如果是写，则不允许后续读抢锁。如果队列中第一个是读，紧随其后的其他读可以抢锁。线程1再次获取读锁，处于重入状态，这就和公平策略下相同。\n公平策略： 获取读锁情况： a. 如果当前全局处于无锁状态，则当前线程获取读锁 b. 如果当前全局处于读锁状态，且队列中没有等待线程，则当前线程获取读锁 c. 如果当前全局处于写锁占用状态（并且不是当前线程占有），则当前线程入队尾\n获取写锁，规则如下： h. 如果当前处于无锁状态，则当前线程获取写锁 i. 如果当前全局处于读锁状态，当前线程入队尾 j. 如果当前全局处于写锁状态，除非是重入获取写锁，否则入队尾 非公平策略： 获取读锁情况： a. 如果当前全局处于无锁状态，则当前线程获取读锁 b. 如果当前全局处于读锁状态，且队列中没有等待线程，则当前线程获取读锁 c. 如果当前全局处于写锁占用状态（并且不是当前线程占有），则当前线程入队尾 d. 如果当前全局处于读锁状态，且等待队列中第一个等待线程想获取写锁，那么当前线程能够获取到读锁的条件为：当前线程获取了写锁，还未释放；当前线程获取了读锁，这一次只是重入读锁而已；其它情况当前线程入队尾。之所以这样处理一方面是为了效率，一方面是为了避免想获取写锁的线程饥饿，老是得不到执行的机会 e. 如果当前全局处于读锁状态，且等待队列中第一个等待线程不是写锁，则当前线程可以抢占读锁\n获取写锁的情况同上。\n5）、Set是有序还是无序的？一定无序吗？ 既有无序，也有有序。HashSet无序，LinkedSet因为底层链表+哈希表，所以是有序的且唯一的。TreeSet是有序的，通过自然排序或者比较器排序。\n6）、TreeSet的底层实现 姬祥todo\n7）、把你所知道的HashMap的所有知识都说一下？（包括底层实现、扩容机制、1.7与1.8的区别、长度为什么是2的n次幂） 底层实现是哈希表，初始大小为11，每次扩容为原来的2n+1，jdk1.7中采用数组+链表，1.8中采用数组+链表+红黑树实现\n扩容机制，底层实现原理 姬祥todo\n8）、保证线程安全的Map是什么？ConcurrentHashMap聊一下？（和HashMap答题类似，不过重点要回答的是为什么线程安全） Hashtable和ConcurrentHashMap是线程安全的\n讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。 姬祥todo for jx jvm\n39.异常 异常分为哪几种？他们的父类是什么？ 图片: https://uploader.shimo.im/f/8uZzh3mPzKXsMhsc.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 异常的父类是Throwable类，Throwable的父类是object类。 Throwable类的子类分别是error和exception类。 error的出现，程序是无法运行的，只能交给程序员进行处理。 exception的出现，程序是可以继续运行，但是控制台会报错，分为两种异常，编译期异常和运行时异常。所有的异常都是在程序运行期间的情况，特别指明编译期异常是编译前预先处理的异常。 常见编译期异常：IOException和TimeoutException。 常见运行时异常：NullPointerException，ClassCastException， ArithmeticException，数组角标越界异常。\n受检异常与非受检异常的区别？ 详细解释见===\u0026gt;受检异常与非受检异常的区别### 非受检异常：Error、RuntimeException，是指不需要调用者显示捕获的异常。 受检异常：编译时异常IOException/SqlException，在没有捕获的情况下，会显示提示语法错误，是指需要调用者显示通过try-catch捕获的异常 Error可以捕获吗？ 有error程序会停止运行，不可以捕获。\n栈溢出和堆溢出是什么？OOM可以捕获吗？什么情况可以捕获？ 1)、 栈溢出和堆溢出是什么？ 姬祥todo 2）、 OOM可以捕获，但是没有必要 姬祥todo 3）、 姬祥todo\nUUID\n高级篇 1.Object类 Object类是java语言中的根类，是所有类的父类。 toString方法，返回该对象的字符串表示。经常 覆盖重写 equals方法，如果没有覆盖重写，则比较的是地址值，只要不是一个对象肯定不相等。 Objects类，空指针安全的。 图片: https://uploader.shimo.im/f/F9SIAvJL47iUTzcg.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8\n2.Date类 构造方法 图片: https://uploader.shimo.im/f/gDk3GI1wd2vJJI7P.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 把日期对象转换成对应的毫秒值： 图片: https://uploader.shimo.im/f/MKgcqgXA9gkpM848.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 打印结果： 图片: https://uploader.shimo.im/f/4gpK95vRhdi9aADP.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 DateFormart类（重要） DateFormart类为抽象类，常用它的子类SimpleDateFormat类 图片: https://uploader.shimo.im/f/rK6t6P0Wjaeh8LsV.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 使用方法： 图片: https://uploader.shimo.im/f/NrV0XJxQYfER4eDW.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 图片: https://uploader.shimo.im/f/rmEQoIR0EUiIZJxO.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 示例如下： format方法： 图片: https://uploader.shimo.im/f/n8JqttzGIqV9Bv8W.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 parse方法： 图片: https://uploader.shimo.im/f/kUWlFhWlbPwIqyaw.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8\nCanlender类 工作中没用过，略\u0026hellip;\u0026hellip;..\n3.System类（不重要） 图片: https://uploader.shimo.im/f/Cd0NYZSVpIWZ6cmM.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 示例： 图片: https://uploader.shimo.im/f/zd7RrdFta9JlyxsG.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 ps:不常用\n4.StringBuilder类（非常重要） 概述 图片: https://uploader.shimo.im/f/fqBAKoX3NV24OlND.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 构造方法 图片: https://uploader.shimo.im/f/8yMLJT1b7ohNDDUe.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 常用方法 图片: https://uploader.shimo.im/f/BQ9afeQqvVApBRK5.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 备注：该类重写了Object类中的toString方法\nString，Stringbuffer，StringBuilder的区别 String 是不可变的，而 StringBuffer 和 StringBuilder 是可变类。 StringBuffer 是线程安全和同步的，而 StringBuilder 不是。线程同步线程安全会造成速度降低 字符串连接运算符 (+) 在内部使用的是 StringBuilder 类。 对于非多线程环境中的字符串操作，我们一般使用 StringBuilder 否则使用 StringBuffer 类。 姬祥todo for jx jvm中new string\n包装类 包装类的作用 ①、集合中不能使用基本类型。 ②、方便类型之间的转换（如：string类型转换成int类型 int a= new Integer(\u0026ldquo;123\u0026rdquo;)） 常用的 图片: https://uploader.shimo.im/f/Gu7uR0MPZpzjOkAe.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 装箱与拆箱 图片: https://uploader.shimo.im/f/Pkmw4GmecTQXBmCu.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 自动装箱和自动拆箱 图片: https://uploader.shimo.im/f/ke73CTl0F7ZiG52y.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 基本类型和字符串之间的转换，这里只讲最简单的一种方式，直接加“”，如34+“” 除了Character类之外，其它所有的包装类都具有parseXxx静态方法可以将字符串参数转换成对应的基本类型 示例如下： 图片: https://uploader.shimo.im/f/TbpPHbinKRdYthdh.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8\n迭代器 获取迭代器 图片: https://uploader.shimo.im/f/tYN3gUcu1cuUQREB.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 迭代器方法 图片: https://uploader.shimo.im/f/XlLWcskNCPAnOsoz.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 使用方法(比较简单) 图片: https://uploader.shimo.im/f/Pe6u13wuvooRqiq1.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 增强for循环 图片: https://uploader.shimo.im/f/iifcFUbYsRq9wJLl.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8\n泛型(知道集合中怎么放泛型就行了) 概述 可以在类或方法中预支地使用未知的类型 使用泛型的好处 将运行时期的ClassCastException,转移到了编译时期变成了编译失败 2. 避免了类型强转的麻烦 泛型的定义和使用 在创建对象的时候确定泛型 调用方法是，确定泛型的类型 泛型的通配符 通配符的高级使用，受限泛型 图片: https://uploader.shimo.im/f/6spS5qREaQaDRfD2.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 示例： 图片: https://uploader.shimo.im/f/qvbzE4jRBukwePKd.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8\n集合的案例（斗地主）\n数据结构 常见的数据结构（栈、队列、数组链表、红黑树） 栈： stack，又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一段进行插入和删除操作，不允许再其他任何位置进行添加、查找、删除操作。 图片: https://uploader.shimo.im/f/ZapHwLHMNxmhOH0u.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 队列：queue，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一段进行插入，而在表的另一端进行删除。 简单的说，采用该结构的集合，对元素的存取有如下的特点： 先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。 队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。 图片: https://uploader.shimo.im/f/nle5buO62uU9zFUK.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 数组：Array，是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。 图片: https://uploader.shimo.im/f/SGamM8oYNpddpuJp.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 链表： 图片: https://uploader.shimo.im/f/JXQNlgOxRRjRurtK.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 图片: https://uploader.shimo.im/f/mSKBe7Y6c9k6M8pq.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8\nhashcode与hash算法 详细资料见===\u0026gt;超链接###\n反射 反射详细笔记===》反射——自己的笔记\n1）、反射是什么？举几个例子？\n图片: https://uploader.shimo.im/f/X8ClRTv4tZtxtmlq.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 在java注解，xml，properties配置文件，jdbc和springaop中都使用反射的原理\n在项目中，通过反射加载各功能模块的操作界面，不使用反射机制通过代码也可以实现，但是问题是在代码中将程序写死，当你再想扩展功能的时候你必须修改之前的代码才可以实现，就会违背代码的设计的开闭原则—对扩展开放，对修改关闭。但是使用反射就解决了这个问题，将按键对应的变量和其对应的类的全限定名称存放到数据库，在程序中从库中获取数据，对数据进行统一操作。扩展时只需要在数据库中对应位置添加写好的类的全限定名称即可。 在比如需要对某一些类进行自定义统一处理时，为了方便自己建立工具类，这时候就需要使用反射和泛型来实现统一化处理。\n2）、通过反射可以拿到类中的变量信息吗？ 可以拿到类的变量信息。 ①、通过Class类的方法getClass拿到类的Class对象 Class c1=Class.getClass(com.xx.User) ②、通过newInstance创建对象 object Object o1=c1.newInstance() ③、通过getDeclaredField(\u0026ldquo;变量名（属性名）\u0026quot;)来获得属性变量的Field field。 Field field=c1.getDeclaredField(\u0026ldquo;属性名\u0026rdquo;) ④、通过field.set(object,\u0026ldquo;值\u0026rdquo;)设置值 field.set(o1,\u0026ldquo;值\u0026rdquo;) ⑤、私有方法还需要在set之前关闭安全检测 field.setAccessiable(true)\n设计模式（一般与SpringAOP一同问） 姬祥todo\n多线程 链接===》https://shimo.im/docs/9030MPb0axF50Jqw/\n比较器\n并发篇 volatile tooearly\njava中的锁 与数据库锁 java锁： 详细资料===\u0026gt;java 中的锁 \u0026ndash; 偏向锁、轻量级锁、自旋锁、重量级锁 tooearly 详细资料===\u0026gt;java中各种锁 tooearly 概念： ①、死锁：至少两个线程，各自拥有资源，彼此还互相请求对方资源，造成无法继续进行的情况 图片: https://uploader.shimo.im/f/ITtHoVZD4KzLrDON.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8\njava常见锁分类：\n 乐观锁 VS 悲观锁 自旋锁 VS 适应性自旋锁 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁 公平锁 VS 非公平锁 可重入锁 VS 非可重入锁 独享锁 VS 共享锁  乐观锁 VS 悲观锁 对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。 而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。 乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。\n图片: https://uploader.shimo.im/f/U1GykgPADiG7tWFI.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhY2Nlc3NfcmVzb3VyY2UiLCJleHAiOjE2NTAwMTE1NjUsImZpbGVHVUlEIjoiOTEzSlZRR1hQVnRMWGEzRSIsImlhdCI6MTY1MDAxMTI2NSwidXNlcklkIjo2NjUzNTM5N30.0LRqIU3nKnunHokjPG99WgixJ7ki3OK2Vc83-tIxsW8 根据从上面的概念描述我们可以发现： 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。（效率低） 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。（通常数据库读写操作的时候使用版本号字段来控制数据统一，使用mybatis-plus乐观锁插件，并且在实体类version字段上加上@veision 注解，就可以可以自动检测版本号，自己的语句中不需要修改版本号，每次写操作都会将版本号加1）\nCAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。 CAS算法涉及到三个操作数： 需要读写的内存值 V。 进行比较的值 A。 要写入的新值 B。 当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。\n数据库锁： 详细视频===\u0026gt;锁与事务 MySQL中，采用了表锁，页锁，行锁（取决不同的存储引擎，mysql默认innodb引擎）\n事务的持久性：事务在进行，但是服务器宕机，再一次启动的时候进行回滚\n框架篇\nRabbitmq RabbitMQ 面试题 | ZC 的学习录 (zhangc233.github.io)\nJVM 举例栈溢出的情况？ StackoverflowError 栈设置成固定大小时，溢出就会出现StackoverflowError。 栈非固定大小时，不对增加不断扩容，先出现StackoverflowError，最后内存不足时会报错OOM内存溢出。\n调整栈大小，就能保证不出现溢出吗？ 不能，死循环即使给在大的空间也会溢出。\n分配的栈 内存越大越好吗？ 不对，给的太大，影响其他线程的内存，其他程序的内存。\n垃圾回收是否会涉及到虚拟机栈？ 不会的，栈只能出栈入栈，出栈即回收，无法GC线程来GC。\n方法中定义的局部变量是否线程安全？ 不一定\n安全： 方法内部定义并且内部消费掉 s1在内部定义，方法返回字符串，但是返回时返回新new一个或者s1.tostring，这样s1生命周期结束的情况是安全的。\n不安全： 多线程中作为形参传入方法中 内部定义，但是作为返回值返回出去，在其他线程中不安全。\n说一下JVM内存模型，有哪些区，分别干什么的？ java8 内存分代的改进 去除永久代，使用元空间（方法区的实现），放在内存中，非堆空间。\nJVM栈和堆的区别？堆的结构？为什么有两个Survivor区？   栈：运行时单位，解决如何运行程序。\n  堆：存储单位，解决如何存储处理数据。\n  堆结构：\n 新生代  Eden Survivor1 Survivor2   老年代    两个Survivor区是为了能使用标记复制算法，为了能解决碎片化问题。新生代与老年代比例1:2，然后新生代还划分成了Eden和s0、s1，比例8:1:1。如果没有复制算法，即只有一个survivor区，一次minorGC后，eden存活对象A放进survivor区，然后第二次MinorGC，倘若survivor第一次放入的对象A比较小且被第二次MinorGC清除，第二次由eden进入survivor的存活对象B又比较大，就只能存储在后方，这就造成了对象A的存储区域无法被利用，就造成了碎片化问题。\n  所以采用新生代采用复制算法即使用两个survivor区，每次只使用一个survivor区，将eden和survivor1存活对象都放入survivor2中，并且排列好，从而解决碎片化问题。\nEden和Survior的比例分配？ 8:1:1\n 8:2的原因：   大部分对象存活时间都不会很长，将其分配到Eden区，每次Eden满了触发MinorGC（STW时间较短），就很容易清除掉这些垃圾对象。Survior区小，是因为Survior只保存存活时间稍微长一些的对象，   1:1的原因：\n采用复制算法，两个空间大小要一样。\n  jm内存分区，为什么要有新生代和老年代 GC需要STW，有的对象存活时间长，有的短，GC不应该每次都去检查存活时间长的对象，这样就是浪费时间。\n什么时候对象会进入老年代？  对象太大，新生代所剩空间存储不下 在survivor存活时间超过阈值，就进入了老年代。  对象头信息里有哪些东西 对象在JVM中是怎么存储的 类元信息放进方法区中，new出的实例在对空闲当中。\n你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和g1   CMS ：\n====\u0026gt;跳转CMS\n  阶段：\n 初始标记（STW） 并发标记 重新标记（STW）（修正之前标记过的但并发标记期间又被用户线程修改过的垃圾对象，不包含并发标记期间新产生的垃圾对象） 并发清理（采用的标记清除算法，不需要移动对象，故可以采用并发清理） 重置线程    优点\n 主打的低延迟（采用并发标记，只有初始标记和重新标记会STW）。    缺点\n 采用的标记清除算法，会产生碎片。 只能和Serial和ParaNew一起使用。 无法清理并发标记期间新产生的垃圾。 cms挂掉了，就会使用Serial Old来做为替代，性能大幅度下降。      G1\n====\u0026gt;跳转G1\n  阶段：\n 年轻代GC 当堆内存使用到45% ，老年代并发标记过程 混合回收 有可能fullGC    优点\n  缺点\n    JVM GC算法有哪些，目前的JDK版本采用什么回收算法 G1回收器讲下回收过程 GC是什么？为什么要有GC? GC的两种判定方法？CMS 收集器与G1收集器的特点。 说一下GC算法，分代回收说下 垃圾收集策略和算法          搞定！\n人生无常，大肠包小肠！\n继续学习吧！\n","id":1,"section":"posts","summary":"","tags":["java"],"title":"面试题","uri":"https://gb.ytte.top/2022/04/15/%E9%9D%A2%E8%AF%95%E9%A2%98/","year":"2022"},{"content":"SpringCloud alibaba","id":2,"section":"posts","summary":"","tags":["SpringCloud"],"title":"SpringCloud alibaba","uri":"https://gb.ytte.top/2022/04/13/springcloud-alibaba/","year":"2022"},{"content":"IOC、DI xml====》xml配置文件注册bean类\n注解====》 注解开发-CSDN博客\n  IOC(Inversion of Control)：反转控制。由主动的 new 资源变为被动的接受资源\n即组件以一些预先定义好的方式(例如：setter 方法)接受来自于容器的资源注入。\n  DI(Dependency Injection)：依赖注入。\n  IOC 容器和 Bean 的配置 链接 2.1====》笔记 【金山文档】 尚硅谷 IOC和bean的配置\n@Resource 与@Autowired 的 区别  @Resource 默认是按照变量名称来装配注入的，只有当找不到与名称匹配的 bean 才会按照类型来装配注入； @Autowired 默认是按照类型装配注入的，如果想按照变量名称来转配注入，则需要结合@Qualifier 一起使用  todo 动态注册bean\n泛型依赖注入 链接 2.2====》 视频57~59——尚硅谷\n不懂就点击看视频\n使用场景：todo 解释：   单继承，自然很容易确定子类类型。\n  Spring中如果有继承且有泛型，Spring会通过泛型来确定子类的类型。\n  两个子类之间的依赖关系不需要在子类中去声明，而是在父类中进行了声明，而依赖的纽带就是 泛型类型，必须是相同的父类泛型类型才具有依赖关系。\n类似如图\n  举例： 我们创建三个Dao，BookDao和UserDao都继承BaseDao，并且二者都有一个save方法，各自的Service都调用各自的Dao的Save方法。\nDao：\nService：\nTest：\n这样必然是能执行成功的，但是很繁琐，有形式重复代码。\n现在使用泛型依赖注入。\n将BookService 和UserService都清空，都继承BaseService，代码都放在BaseService中。\n这样就成功的进行了泛型依赖注入，\n值得注意的是，BaseService不需要注入容器中；因为BookService 和UserService继承了BaseService，便可以时候用器save方法和@autowired （不懂就点击○演示 ）\n原理： 为什么BookService 能找到BaseDao——原理\nSpring中如果有继承且有泛型，Spring会通过泛型来确定子类的类型\nAOP 什么是AOP 面向切面编程：\n日常中权限校验、日志记录、统计等，这些代码会散落穿插在各个业务逻辑中，非常冗余且不利于维护。而且每次新的业务都需要新添加日志记录等，太繁琐，造成了高耦合低内聚。\nAOP将权限校验、日志记录等非业务代码完全提取出来，与业务代码分离，并寻找节点切入业务代码中：\nAOP要做三类事：  在哪里切入，也就是权限校验等非业务操作在哪些业务代码中执行。 在什么时候切入，是业务代码执行前还是执行后。 切入后做什么事，比如做权限校验、日志记录等。  AOP的体系可以梳理为下图：\n相关名称和概念 切点表达式：切入点就相当于数据库中的数据，切入点表达式就相当于与sql语句。\n  横切关注点：从每个方法中抽取出来的同一类非核心业务。\n  切面(Aspect)：封装横切关注点信息的类，每个关注点体现为一个通知方法。\n  通知(Advice)：切面的各个具体工作\n  目标(Target)：被通知的对象\n  代理(Proxy)：目标对象加了通知之后的代理对象\n  连接点(Joinpoint)：横切关注点在程序代码中的具体体现，对应程序执行的某个特定位置。例如：类某个方法调用前、调用后、方法捕获到异常后等。在应用程序中可以使用横纵两个坐标来定位一个具体的连接点如下图\n  切入点(pointcut)：真正使用通知方法的连接点。每个类的方法中都包含多个连接点。如果把连接点看作数据库中的记录，那么切入点就是查询条件——AOP可以通过切入点定位到特定的连接点。切点通过org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。\n  相关包依赖配置 手动 基础包：\n面向切面编程包：\nmaven \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在Springboot配置类中加@EnableAspectJAutoProxy 加不加都可。\n todo 看看原码配置与否的区别\n 注解 通知注解顺序  @Before @After @AfterReturning @AfterThrowing @Around  @Pointcut @Pointcut 注解，用来定义一个切点。其他通知注解，可以直接使用pointcut =“pointCut()”\n@Aspect @Component public class LogAspectHandler {  /** * 定义一个切面，拦截 com.ytte.controller 包和子包下的所有方法 */  @Pointcut(\u0026#34;execution(* com.ytte.controller..*.*(..))\u0026#34;)  public void pointCut() {} } @Pointcut 注解指定一个切点，定义需要拦截的东西，这里介绍两个常用的表达式：\n  execution()，\n  annotation()。\n  execution表达式：\n 切入点表达式的语法格式  execution([权限修饰符（可写可不写）] [返回值类型] [简单类名/全类名] [方法名] ([参数列表]))\n 举例说明     表达式 execution(* com.ytte.spring.ArithmeticCalculator.*(..))     含义 ArithmeticCalculator接口中声明的所有方法。第一个 “ * ”代表任意修饰符及任意返回值。第二个 “ * ”代表任意方法。“..”匹配任意数量、任意类型的参数。若目标类、接口与该切面类在同一个包中可以省略包名。       表达式 execution(public * ArithmeticCalculator.*(..))     含义 ArithmeticCalculator接口的所有公有方法       表达式 execution(public double ArithmeticCalculator.*(..))     含义 ArithmeticCalculator接口中返回double类型数值的方法       表达式 execution(public double ArithmeticCalculator.*(double, ..))     含义 第一个参数为double类型的方法。“..” 匹配任意数量、任意类型的参数。       表达式 execution(public double ArithmeticCalculator.*(double, double))     含义 参数类型为double，double类型的方法     在AspectJ中，切入点表达式可以通过 “\u0026amp;\u0026amp;”、“||”、“!”等操作符结合起来。     表达式 execution (* .add(int,..)) || execution( *.sub(int,..))     含义 任意类中第一个参数为int类型的add方法或sub方法    annotation() 表达式：\nannotation() 方式是针对某个注解来定义切点，比如我们对具有 @PostMapping 注解的方法做切面，可以如下定义切面：\n@Pointcut(\u0026#34;@annotation(org.springframework.web.bind.annotation.PostMapping)\u0026#34;) public void annotationPointcut() {} 然后使用该切面的话，就会切入注解是 @PostMapping 的所有方法。这种方式很适合处理 @GetMapping、@PostMapping、@DeleteMapping不同注解有各种特定处理逻辑的场景。\n针对自定义注解来定义切面。\n@Pointcut(\u0026#34;@annotation(com.example.demo.PermissionsAnnotation)\u0026#34;) private void permissionCheck() {} @Around Around增强处理有以下特点：\n  @Around可以自由选择增强动作与目标方法的执行顺序，可以在增强动作前后，甚至过程中执行目标方法。\n 当定义一个Around增强处理方法时，该方法的第一个形参必须是 ProceedingJoinPoint 类型（至少一个形参）。（ProceedingJoinPoint是JoinPoint子类）（注意是大写的P） 在增强处理方法体内调用ProceedingJoinPoint参数的procedd()方法才会执行目标方法。    @Around可以改变执行目标方法的参数值，也可以改变执行目标方法之后的返回值。\n 调用ProceedingJoinPoint的proceed方法时，还可以传入一个Object对象，该数组中的值将被传入目标方法作为实参。   如果传入的Object[ ]数组长度与目标方法所需要的参数个数不相等，或者Object[ ]数组元素与目标方法所需参数的类型不匹配，程序就会出现异常。\n   **@Around功能虽然强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturning就能解决的问题，就没有必要使用Around。**如果需要目标方法执行之前和之后共享某种状态数据，则应该考虑使用Around。\n使用场景：需要使用增强处理阻止目标的执行，或需要改变目标方法的返回值时，则只能使用Around增强处理了。\n例子   自定义注解类：\n@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface PermissionAnnotation{ }   定义接口类：\npackage com.example.demo;  import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import org.springframework.web.bind.annotation.*;  @RestController @RequestMapping(value = \u0026#34;/permission\u0026#34;) public class TestController {  @RequestMapping(value = \u0026#34;/check\u0026#34;, method = RequestMethod.POST)  @PermissionsAnnotation()  public JSONObject getGroupList(@RequestBody JSONObject request) {  return JSON.parseObject(\u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;SUCCESS\\\u0026#34;,\\\u0026#34;code\\\u0026#34;:200,\\\u0026#34;data\\\u0026#34;:\u0026#34; + request + \u0026#34;}\u0026#34;);  } }   唯一切面类：\npackage com.example.demo;  import com.alibaba.fastjson.JSONObject; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component;  @Aspect @Component @Order(1) public class PermissionAdvice {   @Pointcut(\u0026#34;@annotation(com.example.demo.PermissionsAnnotation)\u0026#34;)  private void permissionCheck() {  }   @Around(\u0026#34;permissionCheck()\u0026#34;) //（注意是大写的P）  public Object permissionCheck(ProceedingJoinPoint joinPoint) throws Throwable {  System.out.println(\u0026#34;===================开始增强处理===================\u0026#34;);   //获取请求参数，详见接口类  Object[] objects = joinPoint.getArgs();  Long id = ((JSONObject) objects[0]).getLong(\u0026#34;id\u0026#34;);  String name = ((JSONObject) objects[0]).getString(\u0026#34;name\u0026#34;);  System.out.println(\u0026#34;id1-\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#34; + id);  System.out.println(\u0026#34;name1-\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#34; + name);  \t// 修改入参  JSONObject object = new JSONObject();  object.put(\u0026#34;id\u0026#34;, 8);  object.put(\u0026#34;name\u0026#34;, \u0026#34;lisi\u0026#34;);  objects[0] = object;  \t// 将修改后的参数传入  return joinPoint.proceed(objects);  } }   结果：\n传入参数：{\u0026quot;id\u0026quot;:-8,\u0026quot;name\u0026quot;:\u0026quot;--lisi \u0026quot;}，响应结果表明：@Around截取到了接口的入参，并使接口返回了切面类中的结果。可看出对返回值进行了更改，。\n  @Before 注解指定的方法在切面切入目标方法之前执行，可以做一些 Log 处理，也可以做一些信息的统计，比如获取用户的请求 URL 以及用户的 IP 地址等等。\nJointPoint 可以用来获取一个签名，利用签名可以获取请求的包名、方法名，包括参数（通过joinPoint.getArgs() 获取）等。\n例如下面代码：\n pointCut()为1中定义的，这里是使用重复的切入点表达式@Pointcut\n import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import javax.servlet.http.HttpServletRequest;  @Aspect @Component @Slf4j public class LogAspectHandler {  /** * 在上面定义的切面方法之前执行该方法 * @param joinPoint jointPoint */  @Before(\u0026#34;pointCut()\u0026#34;)  public void doBefore(JoinPoint joinPoint) {  log.info(\u0026#34;====doBefore方法进入了====\u0026#34;);   // 获取签名  Signature signature = joinPoint.getSignature();  // 获取切入的全限定类名  String declaringTypeName = signature.getDeclaringTypeName();  // 获取即将执行的方法名  String funcName = signature.getName();  log.info(\u0026#34;即将执行方法为: {}，属于{}包\u0026#34;, funcName, declaringTypeName);   // 也可以用来记录一些信息，比如获取请求的 URL 和 IP  ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();  HttpServletRequest request = attributes.getRequest();  // 获取请求 URL  String url = request.getRequestURL().toString();  // 获取请求 IP  String ip = request.getRemoteAddr();  log.info(\u0026#34;用户请求的url为：{}，ip地址为：{}\u0026#34;, url, ip);  } } @After @After 注解和 @Before 注解相对应，指定的方法在切面切入目标方法之后执行，也可以做一些完成某方法之后的 Log 处理。\n@Aspect @Component @Slf4j public class LogAspectHandler {  /** * 定义一个切面，拦截 com.mutest.controller 包下的所有方法 */  @Pointcut(\u0026#34;execution(* com.mutest.controller..*.*(..))\u0026#34;)  public void pointCut() {}   /** * 在上面定义的切面方法之后执行该方法 * @param joinPoint jointPoint */  @After(\u0026#34;pointCut()\u0026#34;)  public void doAfter(JoinPoint joinPoint) {   log.info(\u0026#34;==== doAfter 方法进入了====\u0026#34;);  Signature signature = joinPoint.getSignature();  String method = signature.getName();  log.info(\u0026#34;方法{}已经执行完\u0026#34;, method);  } } 写个 Controller 测试一下执行结果，新建一个 AopController 如下：\n@RestController @RequestMapping(\u0026#34;/aop\u0026#34;) public class AopController {   @GetMapping(\u0026#34;/{name}\u0026#34;)  public String testAop(@PathVariable String name) {  return \u0026#34;Hello \u0026#34; + name;  } } 启动项目，在浏览器中访问 localhost:8080/aop/name，观察一下控制台的输出信息：\n====doBefore 方法进入了==== 即将执行方法为: testAop，属于com.itcodai.mutest.AopController包 用户请求的 url 为：http://localhost:8080/aop/name，ip地址为：0:0:0:0:0:0:0:1 ==== doAfter 方法进入了==== 方法 testAop 已经执行完 @AfterReturning @AfterReturning 注解和 @After 有些类似，区别在于 @AfterReturning 注解可以用来捕获切入方法执行完之后的返回值，对返回值进行业务逻辑上的增强处理(AfterReturning切面类拿到的是原方法的return 而不是原方法的参数，不能影响更改原方法的返回值ProceedingJoinPoint is only supported for around advice)，例如：\n@Aspect @Component @Slf4j public class LogAspectHandler {  /** * @param joinPoint joinPoint * @param result result */  @AfterReturning(pointcut = \u0026#34;pointCut()\u0026#34;, returning = \u0026#34;result\u0026#34;)  public void doAfterReturning(JoinPoint joinPoint, Object result) {   Signature signature = joinPoint.getSignature();  String classMethod = signature.getName();  log.info(\u0026#34;方法{}执行完毕，返回参数为：{}\u0026#34;, classMethod, result);  // 实际项目中可以根据业务做具体的返回值增强  log.info(\u0026#34;对返回参数进行业务上的增强：{}\u0026#34;, result + \u0026#34;增强版\u0026#34;);  } } 需要注意的是，在 @AfterReturning 注解 中，属性 returning 的值必须要和参数保持一致，否则会检测不到。该方法中的第二个入参就是被切方法的返回值，在 doAfterReturning 方法中可以对返回值进行增强，可以根据业务需要做相应的封装。测试一下：\n方法 testAop 执行完毕，返回参数为：Hello CSDN 对返回参数进行业务上的增强：Hello CSDN 增强版 @AfterThrowing 当方法抛出异常时，会进入 @AfterThrowing 注解的方法中执行。要注意的是 throwing 属性的值必须要和参数一致，否则会报错。该方法中的第二个入参即为抛出的异常。异常接受类型一定要Exception，写子类写小了AOP接受不到。 返回值也是如此，写Object\n@Aspect @Component @Slf4j public class LogAspectHandler {  /** * 在上面定义的切面方法执行抛异常时，执行该方法 * @param joinPoint jointPoint * @param ex ex */  @AfterThrowing(pointcut = \u0026#34;pointCut()\u0026#34;, throwing = \u0026#34;ex\u0026#34;)  public void afterThrowing(JoinPoint joinPoint, Exception ex) {  Signature signature = joinPoint.getSignature();  String method = signature.getName();  // 处理异常的逻辑  log.info(\u0026#34;执行方法{}出错，异常为：{}\u0026#34;, method, ex);  } } @Order   在同一个连接点上应用不止一个切面时，除非明确指定，否则它们的优先级是不确定的。\n  切面的优先级可以通过实现Ordered接口或利用@Order注解指定。\n  实现Ordered接口，getOrder()方法的返回值越小，优先级越高。\n  注意事项 AfterReturning与Around的区别   ProceedingJoinPoint的proceed方法，只能用在Around上，所以AfterReturning无法改变原方法的返回值\n  Around拿到的是原方法的参数，通过对参数的更改，来改变返回值；而AfterReturning拿到的是原方法的return\n  JoinPoint获取目标方法的信息 导包：（注意是大写的P） 视频 p72 ———— 尚硅谷\nimport org.aspectj.lang.JoinPoint; Object[] objects = joinPoint.getArgs();   获取方法签名（通过签名可以你获得方法所有信息）\n Signature signature = joinPoint.getSignature();   获取方法名\n String funcName = signature.getName();   获取切入的全限定类名\nString declaringTypeName = signature.getDeclaringTypeName();   Spring对通知方法的约束 补充：异常接受类型一定要Exception，写子类写小了AOP接受不到。返回值也是如此，写Object\n动态代理： aop 实质就是用了 jdk 的动态代理（需要对象实现了接口）\n代理设计模式的原理：**使用一个代理将对象包装起来，然后用该代理对象取代原始对象。**任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。\n不懂就点击○代码在这里\n作用：\n  动态代理主要用来做方法的增强，让你可以在不修改源码的情况下，增强一些方法，在方法执行前后做任何你想做的事情（甚至根本不去执行这个方法）。因为在InvocationHandler的invoke方法中，你可以直接获取正在调用方法对应的Method对象，具体应用的话，比如可以添加调用日志，做事务控制等。\n  还有一个有趣的作用是可以用作远程调用。比如现在有Java接口，这个接口的实现部署在其它服务器上，在编写客户端代码的时候，没办法直接调用接口方法，因为接口是不能直接生成对象的，这个时候就可以考虑代理模式（动态代理）了，通过Proxy.newProxyInstance代理一个该接口对应的InvocationHandler对象，然后在InvocationHandler的invoke方法内封装通讯细节就可以了。具体的应用，最经典的当然是Java标准库的RMI，其它比如hessian，各种webservice框架中的远程调用，大致都是这么实现的。\n  Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大。\n  可以实现AOP编程，实际上静态代理也可以实现，总的来说，AOP可以算作是代理模式的一个典型应用。\n  解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。\n  两个很大的问题（日常不使用动态代理的原因）：\n  代理对象和被代理对象的关联就在于实现了同一个接口，一旦被代理对象没有实现接口就不能进行动态代理（cglib 可以为没有接口的对象创建代理对象）\n  写着麻烦，每有一个被代理对象就需要写一个代理类\n  因此出现了 AOP\n 注意：\n 代理对象调用的方法也要是 public 修饰符，否则方法中获取不到注入的 bean，会报空指针错误。 AopContext.currentProxy ()可以获取到本类的代理对象   事务控制  链接 ====》 视频94——尚硅谷\n链接 ====》spring注解开发-事务管理\n链接 ====》[【金山文档】 尚硅谷]第08章 声明式事务\n 事务控制基于xml  链接 ====》视频115——尚硅谷\n @Transactional  链接 ====》 @Transactional注解详解-CSDN博客\n 几种属性 @Transactional(timeout=?) 设置事务处理超时时间为？秒，超时则会报异常 TransactionTimedOutException\n@Transactional(readOnly=true) 默认是 false，使用场景：方法内都是查询方法，使用 readOnly 可以优化事务，提高运行速度。 如果方法内不全是查询方法使用 readOnly 属性则会报错：TransientDataAccessResourceException。\n@Transactional(noRollbackFor={ArithmeticException.class}) noRollbackFor：设置哪些异常出现可以不回滚\nrollbackFor：设置哪些异常出现必须回滚\n  运行时异常会回滚\n  编译期异常事务不会回滚\n  隔离级别 链接 ====》 视频104——尚硅谷\n概念：   脏读（不允许发生）：（读取到了没有提交的数据）\n后者读到前者修改后的值后，前者将值回滚了，后者读到了没有意义数据。\n  不可重复读：\n在一个事务中多次读取同一个数据时，结果出现不一致。\n    幻读（被他人插入了新数据）：\n在一个事务中使用相同的 SQL 两次读取，第二次读取到了其他事务新插入的行。\n  各个隔离级别解决并发问题的能力 和 各种数据库产品对事务隔离级别的支持程度见下表\n    脏读 不可重复读 幻读 Oracle MySQL     READ UNCOMMITTED 读未提交 有 有 有 × √   READ COMMITTED 读已提交 无 有 有 √(默认) √   REPEATABLE READ 可重复读 无 无 有 × √(默认)   SERIALIZABLE 串行化 无 无 无 √ √    事务的传播行为 视频====》视频110~112——尚硅谷\n 默认值是第一种 required 和require_new  例子加深印象====》视频112——尚硅谷\n  required：事务的属性继承于大事务\n视频====》视频113——尚硅谷\n  注意：在@Transactional 注解的方法中，再调用本类中的其他方法 method2 时，那么 method2 方法上的@Transactional 注解是不！会！生！效！的！想要其生效，需要使用代理对象去调用本类方法\n原因：\n  Jdbc 链接 5.1====》【金山文档】 尚硅谷 第07章 JdbcTemplate\n链接 5.2====》视频84——尚硅谷\ntodo\n原码分析 链接 6.1====》 视频96——尚硅谷\ntodo\n参考  切面AOP——云深i不知处-CSDN博客 尚硅谷_第05章 AOP细节 (kdocs.cn) 尚硅谷_第04章 AOP概述 (kdocs.cn) xml配置文件注册bean类 注解开发-CSDN博客   搞定！\n人生无常，大肠包小肠！\n继续学习吧！\n","id":3,"section":"posts","summary":"","tags":["java"],"title":"Spring","uri":"https://gb.ytte.top/2022/04/08/spring/","year":"2022"},{"content":"SpringBoot 5. web开发 3. 请求参数处理 1. 普通参数与基本注解 1.1注解 视频====》尚硅谷雷神SpringBoot2_bilibili\n@PathVariable、\n@RequestHeader、\n@ModelAttribute、\n@RequestParam、\n@MatrixVariable（矩阵变量）、\n@CookieValue、\n@RequestBody\n@RestController public class ParameterTestController {    // car/2/owner/zhangsan  @GetMapping(\u0026#34;/car/{id}/owner/{username}\u0026#34;)  public Map\u0026lt;String,Object\u0026gt; getCar(@PathVariable(\u0026#34;id\u0026#34;) Integer id,  @PathVariable(\u0026#34;username\u0026#34;) String name,  @PathVariable Map\u0026lt;String,String\u0026gt; pv,  @RequestHeader(\u0026#34;User-Agent\u0026#34;) String userAgent,  @RequestHeader Map\u0026lt;String,String\u0026gt; header,  @RequestParam(\u0026#34;age\u0026#34;) Integer age,  @RequestParam(\u0026#34;inters\u0026#34;) List\u0026lt;String\u0026gt; inters,  @RequestParam Map\u0026lt;String,String\u0026gt; params,  @CookieValue(\u0026#34;_ga\u0026#34;) String _ga,  @CookieValue(\u0026#34;_ga\u0026#34;) Cookie cookie){    Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();  // map.put(\u0026#34;id\u0026#34;,id); // map.put(\u0026#34;name\u0026#34;,name); // map.put(\u0026#34;pv\u0026#34;,pv); // map.put(\u0026#34;userAgent\u0026#34;,userAgent); // map.put(\u0026#34;headers\u0026#34;,header);  map.put(\u0026#34;age\u0026#34;,age);  map.put(\u0026#34;inters\u0026#34;,inters);  map.put(\u0026#34;params\u0026#34;,params);  map.put(\u0026#34;_ga\u0026#34;,_ga);  System.out.println(cookie.getName()+\u0026#34;===\u0026gt;\u0026#34;+cookie.getValue());  return map;  }    @PostMapping(\u0026#34;/save\u0026#34;)  public Map postMethod(@RequestBody String content){  Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();  map.put(\u0026#34;content\u0026#34;,content);  return map;  }    //1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd  //2、SpringBoot默认是禁用了矩阵变量的功能  // 手动开启：原理。对于路径的处理。UrlPathHelper进行解析。  // removeSemicolonContent（移除分号内容）支持矩阵变量的  //3、矩阵变量必须有url路径变量才能被解析  @GetMapping(\u0026#34;/cars/{path}\u0026#34;)  public Map carsSell(@MatrixVariable(\u0026#34;low\u0026#34;) Integer low,  @MatrixVariable(\u0026#34;brand\u0026#34;) List\u0026lt;String\u0026gt; brand,  @PathVariable(\u0026#34;path\u0026#34;) String path){  Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();   map.put(\u0026#34;low\u0026#34;,low);  map.put(\u0026#34;brand\u0026#34;,brand);  map.put(\u0026#34;path\u0026#34;,path);  return map;  }   // /boss/1;age=20/2;age=10   @GetMapping(\u0026#34;/boss/{bossId}/{empId}\u0026#34;)  public Map boss(@MatrixVariable(value = \u0026#34;age\u0026#34;,pathVar = \u0026#34;bossId\u0026#34;) Integer bossAge,  @MatrixVariable(value = \u0026#34;age\u0026#34;,pathVar = \u0026#34;empId\u0026#34;) Integer empAge){  Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();   map.put(\u0026#34;bossAge\u0026#34;,bossAge);  map.put(\u0026#34;empAge\u0026#34;,empAge);  return map;   }  } @RequestPart() 文件上传接收\n","id":4,"section":"posts","summary":"","tags":["SpringBoot"],"title":"SpringBoot","uri":"https://gb.ytte.top/2022/04/06/springboot/","year":"2022"},{"content":"本篇为面试复习总结篇\n详情笔记跳转：https://www.processon.com/view/link/61cbc28e5653bb21ce5bb9c8\n常用参数    序号 参数 说明     1 -Xss 设置线程的最大栈空间   2 -Xms 堆空间的起始内存   3 -Xmx 堆空间的最大内存（超过最大内存将抛出OOM）2和3尽量设置一样   4 -XX:+PrintGCDetails 可开启打印查看GC细节         JVM与Java体系结构 1. Java虚拟机整体架构祥图 2.Java代码执行过程详图 类加载子系统  负责加载Class文件，Class文件开头有特定标识，魔术，咖啡杯壁 Classloader只负责class文件的加载，至于是否可运行，则由执行引擎决定  类加载过程  加载 链接 初始化  加载 加载器分类：\n 启动类加载器 扩展类加载器 系统类加载器  功能：\n将文件以二进制流形式加载进方法区，生成类元信息。（在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口）\n链接 功能：\n  验证\n 文件格式验证（ CA FE BA BE(魔数，Java虚拟机识别)） 元数据 字节码 符号引用    准备\n 为类变量分配内存，并且设置该类变量的初始值，即零值 另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。   不包含用final修饰的static（注意：不是static，而是被final修饰的static），因为final在编译的时候就会分配了，准备阶段会显示初始化 不会为实例变量（无static）分配初始化，类变量会分配在方法区中，实例变量会随着对象一起分配到Java堆中    解析\n将常量池内的符号引用转换为直接引用的过程，往往会伴随着JVM在执行完初始化之后再执行。\n  符号引用就是一组符号来描述引用的目标。符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中\n  直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄\n    初始化   初始化阶段是执行类构造器方法()的过程 为类变量赋予程序员在代码中定义的初始值。\n  如果没有类变量和静态代码块，也不会有clinit\n  ()不同于类的构造器（构造器是虚拟机视角下的()）\n  若该类具有父类，JVM会保证子类的()执行前，父类的()已经执行完毕\n  虚拟机必须保证一个类的()方法在多线程下被同步加\n  补充说明  （IP）解析阶段不一定，在某些情况下可以在初始化阶段之后再开始，为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定） Java虚拟机规范严格规定了，有且只有六种情况，必须立即对类进行初始化（主动使用）  遇到new,getstatic，putstatic或invokestatic这四条字节码指令时。 对类型进行反射调用，如果类型没有经过初始化，则需要触发初始化 初始化类的时候，发现父类没有初始化，则先触发父类初始化 虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会初始化这个主类 只用JDK7中新加入的动态语言支持，如果一个java.lang.invoke.MethodHandler实例最后的解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic，REF_newInvokeSpecial四种类型的方法句柄，并且这个方法对应的类没有进行初始化，则先触发其初始化 当一个接口中定了JDK8新加入的默认方法时，如果这个接口的实现类发生了初始化，要先将接口进行初始化    除了以上几种情况，其他使用类的方式被看做是对类的被动使用，都不会导致类的初始化\n类加载器的分类 jvm虚拟机规范中定义：除了引导类（启动类）加载器以外都是自定义加载器。但是我们通常认定除了启动类扩展类系统类加载器以外的是自定义加载器。\n对于用户来说定义器来说，默认使用系统类加载器进行加载\nJava的核心类库，使用引导类加载器进行加载\n代码获取类加载器 启动类加载器   用来加载Java核心类库，rt.jar,resources.jar,sun.boot.class.path路径下的内容\n  并不继承java.lang.ClassLoader，没有父加载器\n  Bootstrap启动类加载器只加载包名为java\\javax\\sun等开头的类\n​\t所以自定义String不会覆盖java 自身的String类\n  扩展类加载器  派生于ClassLoader类，父类加载器为启动类加载器。  系统类加载器  派生于ClassLoader类，父类加载器为扩展类加载器。 负责加载环境变量classpath或系统属性java.class.path指定路径下的类库。 该类加载器是程序中默认的类加载器，Java应用的类都是由它来完成加载。  自定义加载器   为什么要用自定义类加载器\n  隔离加载类\n例如使中间件的Jar包与应用程序Jar包不冲突\n  修改类加载的方式\n  扩展加载源\n  防止源码泄露\n对字节码进行加密，自定义类加载器实现解密\n    加载过程中的双亲委派机制 图示：\n概念：\nJava虚拟机对Class文件采用的是按需加载。加载class文件时，Java虚拟机使用的是双亲委派模式。\n  如果一个类加载器收到了类加载请求，它并不会自己先去加载。而是把这个请求委托给父类的加载器去执行。\n  如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器。\n  如果父类的加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，依次类推，这就是双亲委派模式。\n  例子：\n  比如在使用第三方包jdbc。jar包时，其中的spi核心接口类在rt.jar包中，rt.jar包由引导类加载器加载\n  而rt.jar接口的实现类在jdbc.jar包中，引导类加载器就会反向委托线程上下文类加载器（也就是系统类加载器）去加载\n  优势：\n  避免类的重复加载\n  保护程序安全，防止核心API被篡改\n​\tjava默认禁止自定义类放入引导类加载器加载的包下（java，javax等）默认自定义类没有这个权限，这也是为了引导类加载器\t的安全考虑。\n  补充：\n  沙箱安全机制就是如此。从而保证对Java核心源代码的保护。\n  在JVM中表示两个class对象，是否为同一个类存在两个必要条件\n 类的完整类名必须一致，包括包名 加载这个类的ClassLoader必须相同  换句话说,在JⅥ中,即使这两个类对象(class对象)来源同一个Class文件,被同一个虚拟机所加载,但只要加载它们的Classloader实例对象不同,那么这两个类对象也是不相等的。\n  对类加载器的引用：JVM必须知道一个类型哪个加载器加载的。如果是用户类加载器加载的，那么jvm会把class字节码文件被加载到内存的方法区当中，除此之外，JVM会将这个类加载器的一个引用作为类型信息的一部分，这个类的类加载器信息也会被保存在方法区中。当解析一个类型到另一个类型的引用的时候， jvm需要保证这两个类型的类加载器相同。\n  运行时数据区 概述 Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区\n  其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。\n  另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。\n    每个线程各自独享：独立包括程序计数器、栈、本地栈。\n  线程间共享：堆、堆外内存（永久代或元空间、代码缓存）\n  每个JVM只有一个runtime实例（runtime实例是单例的），所以才能多个线程之间共享，这个实例即运行时环境（java虚拟机运行时数据区）。\n  垃圾回收主要针对堆空间（95%）的回收和方法区（5%）jdk8中方法区变成了元数据区,使用的是本地内存（空间较小）但也会在溢出所以也要回收一下。pc计数器，栈，本地栈都是栈，回收操作顶多是入栈出栈。\n  在虚拟机栈中大都是对堆中的引用，具体存储的信息都是在堆当中存储。\n  jvm里每个线程都与操作系统的本地线程直接映射，二者生命周期相同。\n主要线程有：\n 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不 同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括\u0026quot;stop-the-world\u0026quot;的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性 操作的调度执行。 GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。 编译线程：这种线程在运行时会将字节码编译成到本地代码。 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。    程序计数器（PC寄存器）   运行时数据区中唯一不会出现OOM的区域，没有垃圾回收\n  如果线程执行的Java方法，则计数器记录正在执行的虚拟机字节码的下一条指令的地址，如果存在线程切换，能将程序代码在以后恢复到争取的位置。\n  如果正在执行的本地方法，这个计数器值则应为空。（undefined）\n  虚拟机栈 内存中的栈与堆：栈是运行时的单位，而堆是存储的单位，栈解决程序如何执行，如何处理数据。堆解决的是数据存储问题，即数据怎么放，放在哪里。\n概念   虚拟机栈的生命周期和线程的一致\n  主管Java程序的运行，保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回。\n  优点  快速有效的存储方式，访问速度仅次于程序计数器 栈不存在垃圾回收，但是存在OOM Java栈大小是动态或者固定不变的。  如果是动态扩展，无法申请到足够内存OOM 如果是固定，即在线程被创建以后就被固定下来，线程请求的栈容量超过固定值，则StackOverflowError   使用-Xss ，设置线程的最大栈空间。例如：-Xss1m、-Xss、1024k、-Xss1048576  存储单位  每个线程都有自己的栈，栈中的数据以栈帧格式存储，一个方法一个栈帧。 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各个数据信息 执行引擎运行的所有字节码指令只针对当前栈帧进行操作，当前在执行的方法就是当前帧。 先进后出，后进先出，先执行最上方的方法（栈帧）。期间如果调用了其他方法，对应的方法栈帧会被创建放在栈顶，成为新的当前帧。  运行原理  不同线程中包含的栈帧不允许存在相互引用。 Java方法有两种返回方式（调用了其他方法结束返回）  一种是正常的函数返回，使用return指令 另外一种是抛出异常，不管哪种方式，都会导致栈帧被弹出    内部结构  局部变量表 操作数栈 动态链接 方法返回地址 附加信息 方法的调用  局部变量表 ————概念————：\n 定义为一个数字数组，主要用于存储方法参数、定义在方法体内部的局部变量、数据类型信息（基本数据类型（8种），引用类型（reference）,return address 类型）。  基本类型变量存储值。 引用类型存储指向堆空间的地址。   局部变量表建立在线程的栈上，是线程私有的，也是方法私有的（一个栈帧一个局部变量表，生命周期跟随方法），因此不存在数据安全问题。 局部变量表容量大小是在编译期确定下来的。 最基本的存储单元是slot。32位为一个slot，64位类型（long和double）占用两个slot。  ————关于Slot————：\n  JVM虚拟机会为局部变量表中的每个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值\n  如果当前帧是由构造方法或者实例方法创建的（非静态方法），那么该对象引用this，会存放在index为0的slot处，其余的参数表顺序继续排列\n  局部变量表中的槽位是可以重复的，如果一个局部变量过了其作用域，那么其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位，从而达到节省资源的目的。\n  ————静态变量与局部变量对比及小结————：\n变量按照数据类型分类：\n 基本数据类型 引用数据类型  变量按照声明的位置：\n  成员变量，在使用前经历过初始化过程\n  类变量（静态变量）\n链接的准备阶段给类变量默认赋值，初始化阶段显示赋值，即静态代码块赋值\n  实例变量（非静态变量）\n随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值\n    局部变量\n在使用前，必须进显式赋值，否则编译不通过\n  ————补充————：\n 在栈帧中，与性能调优关系最密切的部分，就是局部变量表，方法执行时，虚拟机使用局部变量表完成方法的传递。 只要被局部变量表中直接或间接引用的对象都不会被回收，所以局部变量表中的变量也是重要的垃圾回收根节点。  2022-4-12 21:47:06\n 操作数栈 Java虚拟机的解释引擎是基于栈的执行引擎，其中栈就是操作数栈\n————概念————：\n 当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的 每一个操作数栈会拥有一个明确的栈深度，用于存储数值，最大深度在编译期就定义好 栈中，32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度 操作数栈并非采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成一次数据访问  ————作用————：\n  如果被调用方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新程序计数器中下一条需要执行的字节码指令地址。\n  主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间\n  ————栈顶缓存技术————：\n由于操作数是存储在内存中，频繁的进行内存读写操作影响执行速度，将栈顶元素全部缓存到物理CPU的寄存器中，依此降低对内存的读写次数，提升执行引擎的执行效率。\n动态链接 视频 p55 ———— 尚硅谷\n————概念————：\n 是指向常量池的方法引用（动态链接保存这个引用，方便方法字节码访问常量池） 每一个栈帧内部都包含一个指向运行时常量池中，该帧所属方法的引用 描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的。在java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（字面量序号），保存在class文件的常量池中。  ————作用————：\n 动态链接的作用就是为了将所有的变量和方法的符号引用转换为常量池中调用方法的直接引用（直接引用地址）。  ————补充————：\n左边是符号引用#1等等。=右边的是直接引用。有时也会符号A引用符号B，然后符号引用B再=直接饮用\n常量池、运行时常量池： 常量池在字节码文件中，运行时常量池，在运行时的方法区中\n在常亮池当中往往会有（）V，是无返回值类型，同时也是无参数的，这个()V往往可以被多次引用\n为什么需要常量池呢？ 像system，父类，string等等这些类不能都写在该类中，所以采用常量池来引用。就是为了提供一些符号和常量，便于指令的识别与引用，减小编译文件的大小。\ninvokedynamic指令：\ntodo\n方法返回地址   存放调用该方法的pc寄存器的值\n就是讲pc寄存器里存放的下一条指令的地址当做返回，交给执行引擎，告诉他下一条指令执行什么\n  异常退出的，返回地址是通过异常表来确定。正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值\n  本质上，方法的退出就是当前栈帧出栈的过程。此时需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器值等，让调用者方法继续执行下去。\n附加信息 允许携带与Java虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息。不确定有，可选情况。\n方法的调用 静态链接 编译期期间，将调用方的符号引用转为直接引用的过程称为静态链接（运行期间保持不变）\n动态的链接 如果被调用的方法无法再编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接\n方法的绑定 绑定是一个字段、方法、或者类在符号引用被替换为直接引用的过程。仅仅发生一次。\n  早期绑定\n被调用的目标方法如果再编译期可知，且运行期保持不变\n  晚期绑定\n被调用的方法在编译期无法被确定，只能够在程序运行期根据实际的类型绑定相关的方法。\n  虚方法和非虚方法 Java中任何一个普通方法都具备虚函数的特征（运行期确认，具备晚期绑定的特点），C++中则使用关键字virtual来显式定义。\n如果在java程序中，不希望某个方法拥有虚函数的特征，则可以使用关键字final来标记这个方法\n 非虚方法    如果方法在编译期就确定了具体的调用版本，则这个版本在运行时是不可变的。这样的方法称为非虚方法\n  **静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法（子类重写后通过super调用父类方法，这就是确定下来的。）**对应着多态图中所述。\n  虚方法  其他方法称为虚方法\n如果有一个方法，子类没有重写对应父类方法，但是在子类直接调用了对应父类方法，没有加上supe。这样会被认定为调用自己的方法（但是子类并没有对应方法）。所以不能确定该方法。因此只能在运行期间才能确定该方法，所以标注为invokevirtual虚方法。\n虚——方法表  面向对象的编程中，会很频繁的使用动态分配，如果每次动态分配的过程都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率，因此为了提高性能，JVM采用在类的方法区建立一个虚方法表，使用索引表来代替查找\n每个类都有一个虚方法表，表中存放着各个方法的实际入口\n虚方法表会在类加载的链接阶段被创建，并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法也初始化完毕。\n多态  当使用多态方式调用方法时，首先检查父类中是否有该方法   如果没有，则编译错误； 如果有，再去调用子类的同名方法  多态的好处   可以使程序有良好的扩展，并可以对所有类的对象进行通用处理  如果不采用多态的形式，Show方法参数类型就会有两种，这时候就需要重载show方法才能分别接受Cat和dog类型的参数。\n方法调用指令 todo\n方法重写的本质 todo\n堆 概述  一个JVM实例只存在一个堆内存 Java堆区在JVM启动的时候即被创建，其空间大小也就确认了。堆内存的大小是可调节的。 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（TLAB）。 所有的对象实例都在堆分配内存。 方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。 堆是GC执行垃圾回收的重点区域。 gc线程开始即表明用户线程需要暂停（Stop the world）。 现代垃圾收集器大部分都基于分代收集理论设计。  堆空间细分为：  约定   新生区=新生代=年轻代 养老区=老年区=老年代 永久区=永久代（是方法区 的实现）  Java7及之前  Java8及之后  -XX:+PrintGCDetails 可开启打印查看方法区实现\n设置堆内存的大小与OOM 参数  -Xms ：表示堆空间的起始内存。 -Xmx：表示堆空间的最大内存，超过最大内存将抛出OOM。  通常将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾会后清理完堆区后，不需要重新分隔计算堆区的大小，从而提高性能\n默认情况下初始内存大小为物理电脑内存大小/64，最大内存大小为物理电脑内存1/4\n查看堆参数    cmd命令\n jps命令（查看当前程序运行的进程） jstat -gc 进程号（查看JVM在gc时的统计信息）    加运行参数\n  -XX:+PrintGCDetails\n年轻代与老年代  一般只能使用Eden区 和一个Survivor区，两个Survivor区只能使用其一。 新生代与老年代空间默认比例1:2 在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是：8:1:1（实际是6:1:1，因为有自适应机制） 几乎所有的Java对象都是在Eden区被new出来的。Eden放不了的大对象，直接会进入老年代。 新生代80%的对象都是朝生夕死  图解对象分配一般过程   new的对象在为超过Eden区内存大小的情况下，先放在Eden区。\n  当创建新对象，Eden空间填满时，会触发Minor GC，将Eden和幸存者区中不再被其他对象引用的对象进行销毁。 幸存者区满的时候不会触发minorGC，但是minorGC会回收幸存者区。\n  minorGC将Eden中剩余的对象移到幸存者0区。再加载新的对象放到Eden区\n  再次触发垃圾回收，此时上次幸存者下来的，在幸存者0区的，如果没有回收，就会放到幸存者1区。\n  再次经历垃圾回收，又会将幸存者重新放回幸存者0区，依次类推。\n  设置一个年龄计数器参数，默认是15次，超过15次minorGC，则会将幸存者区幸存下来的转去老年区.\n  总结：    针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to。\n  频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间搜集。\n  直接进入老年的几种可能性：\n  对象实例占用内存太大，新生代放不下，直接进入老年代。\n  幸存者区中未满15阈值时或者幸存者区满时都是有可能直接进入老年代。\n    对象分配特殊过程  触发YGC，幸存者区就会进行回收，不会主动进行回收。  超大对象eden放不下，就要看Old区大小是否可以放下，old区也放不下，需要FullGC（MajorGC），再者就OOM。这两GC概念还是有区别的。下面详解\n三个GC  MinorGC MajorGC FullGC  （性能调用主要针对MajorFC和FullGC,因为二者所需要暂停用户线程的时间最长，所以调优目的就是使二者的发生次数减少）\n不同回收器分类 MinorGC 新生代收集\nEden空间填满时，会触发Minor GC，将Eden和幸存者区中不再被其他对象引用的对象进行销毁。幸存者区满的时候不会触发minorGC，但是minorGC会回收幸存者区。\nMajorGC 老年代收集\n 指发生在老年代的GC，对象从老年代消失，我们说“MajorGC”“FullGC”发生了 出现了MajorGC，经常会伴随至少一次MinorGC；也就是老年代空间不足，会先尝试触发MinorGC，如果之后空间还不足，则触发MajorGC。 如果MajorGC后，内存还不足，就报OOM了  FullGC 整堆收集：收集整个Java堆和方法区的垃圾收集\n  调用System.gc()时，系统建议执行FullGC，但是不必然执行。\n  老年代空间不足。\n  方法区空间（非堆）不足。\n  通过MinorGC后进入老年代的平均大小，大于老年代的可用内存\n  由Eden区，Survivor 0区向Survivor 1区复制时，对象的大小大于To可用内存，则把改对象转存到老年代，且老年代的可用内存小于该对象的大小。\n  FullGC是开发或调优中尽量要避免的，这样暂停时间会短一些。\n  内存分配策略  如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor区容纳，则被移动到Survivor空间中，并将对象年龄设置为1，对象再Survivor区每熬过一次MinorGC，年龄就+1，当年龄增加到一定程度（默认为15，不同Jvm，GC都所有不同）时，就会被晋升到老年代中。 优先分配到Eden 大对象直接分配到老年代 长期存活的对象分配到老年代 动态对象年龄分配。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。 空间分配担保  在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间，是否大于新生代所有对象的总空间。 jdk6update24之后，HandlePromotionFailure参数设置成了true，且不能改变。 只要老年代的连续空间大于新生代对象总大小，或者历次晋升的平均大小，就会进行MinorGC，否则进行FullGC。    为对象分配内存TLAB  概念  Thread Local Allocation Buffer\n堆区是线程共享区域，任何线程都可以访问到堆区的共享数据。由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度\n从内存模型而不是垃圾收集的角度，对Eden区域进行划分，JVM为每个线程分配了一个私有缓存区域，包含在Eden空间中。多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题（只能解决一部分问题，因为TLAB只占用了1%Eden空间，一旦对象过大就只能放在Eden中）， 同时还能够提升内存分配的吞吐量，因此我们将这种内存分配方式成为快速分配策略。\n默认情况下，TLAB空间内存非常小，仅占有整个Eden空间的1%，通过-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。\n一旦对象在TLAB空间分配内存失败，JVM就会尝试通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存\n2022-4-14\n 堆是分配对象的唯一选择吗 需要注意的是，只有服务器在server模式下才能使用逃逸分析，一般64位系统默认开启逃逸分析其次 HotSpot中并未没有应用栈上分配，只是进行了标量替换（进行了标量替换，自然就没有了聚合量，也自然就没有new对象，所以就没有对象实例的创建就不会放在堆空间中）\n逃逸分析 当一个对象在方法中定义后，对象只在方法内部消费掉，则认为没有发生逃逸；如果没有被消费掉，被外部方法引用了，则认为发生逃逸，例如作为调用参数传递到其他地方中：\n堆总结  新生代中Eden区过大，survivor区过小的情况  会使得MinorGC后存留的大部分对象不能进入survivor区进行年龄计数，直接进入了老年代，导致内存分配策略失效（年龄计数失效）影响性能。\n新生代中Eden区过小，survivor区过大的情况  这种情况会使得频繁进行MinorGC，性能也会大大下降。\n","id":5,"section":"posts","summary":"\u003cp\u003e本篇为面试复习总结篇\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.processon.com/view/link/61cbc28e5653bb21ce5bb9c8\"\u003e详情笔记跳转\u003c/a\u003e：https://www.processon.com/view/link/61cbc28e5653bb21ce5bb9c8\u003c/p\u003e","tags":["JVM"],"title":"JVM上篇","uri":"https://gb.ytte.top/2022/04/05/jvm%E4%B8%8A%E7%AF%87/","year":"2022"},{"content":"同步更新：\n SpringMVC笔记_YTTE的博客-CSDN博客  一、SpringMVC简介 1、什么是MVC 2、什么是SpringMVC 3、SpringMVC的特点  Spring 家族原生产品，与 IOC 容器等基础设施无缝对接 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求  二、HelloWorld 1、开发环境 IDE：idea 2019.2\n构建工具：maven3.5.4\n服务器：tomcat7\nSpring版本：5.3.1\n2、创建maven工程 a\u0026gt;添加web模块 b\u0026gt;打包方式：war c\u0026gt;引入依赖 \u0026lt;dependencies\u0026gt;  \u0026lt;!-- SpringMVC --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;5.3.1\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;   \u0026lt;!-- 日志 --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;   \u0026lt;!-- ServletAPI --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt;  \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt;  \u0026lt;/dependency\u0026gt;   \u0026lt;!-- Spring5和Thymeleaf整合包 --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.thymeleaf\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;thymeleaf-spring5\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;3.0.12.RELEASE\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。\n3、配置web.xml 注册SpringMVC的前端控制器DispatcherServlet\na\u0026gt;默认配置方式 此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为\u0026lt;servlet-name\u0026gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml\n\u0026lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --\u0026gt; \u0026lt;servlet\u0026gt;  \u0026lt;servlet-name\u0026gt;springMVC\u0026lt;/servlet-name\u0026gt;  \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt;  \u0026lt;servlet-name\u0026gt;springMVC\u0026lt;/servlet-name\u0026gt;  \u0026lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --\u0026gt;  \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; ==b\u0026gt;扩展配置方式==(一般采用这种方式) 可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间\n\u0026lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --\u0026gt; \u0026lt;servlet\u0026gt;  \u0026lt;servlet-name\u0026gt;springMVC\u0026lt;/servlet-name\u0026gt;  \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt;  \u0026lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --\u0026gt;  \u0026lt;init-param\u0026gt;  \u0026lt;!-- contextConfigLocation为固定值 --\u0026gt;  \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt;  \u0026lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --\u0026gt;  \u0026lt;param-value\u0026gt;classpath:springMVC.xml\u0026lt;/param-value\u0026gt;  \u0026lt;/init-param\u0026gt;  \u0026lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做 而这些操作放在第一次请求时才执行会严重影响访问速度 因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时 --\u0026gt;  \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt;  \u0026lt;servlet-name\u0026gt;springMVC\u0026lt;/servlet-name\u0026gt;  \u0026lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --\u0026gt;  \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;  注：\n\u0026lt;url-pattern\u0026gt;标签中使用/和/*的区别：\n/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求\n因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面\n/*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法\n 4、创建请求控制器 由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器\n请求控制器中每一个处理请求的方法成为控制器方法\n因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在\n@Controller public class HelloController {  } 5、创建springMVC的配置文件 在resource目录下创建springMVC.xml 56\n\u0026lt;!-- 自动扫描包 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.atguigu.mvc.controller\u0026#34;/\u0026gt;  \u0026lt;!-- 配置Thymeleaf视图解析器 --\u0026gt; \u0026lt;bean id=\u0026#34;viewResolver\u0026#34; class=\u0026#34;org.thymeleaf.spring5.view.ThymeleafViewResolver\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;order\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;characterEncoding\u0026#34; value=\u0026#34;UTF-8\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;templateEngine\u0026#34;\u0026gt;  \u0026lt;bean class=\u0026#34;org.thymeleaf.spring5.SpringTemplateEngine\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;templateResolver\u0026#34;\u0026gt;  \u0026lt;bean class=\u0026#34;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver\u0026#34;\u0026gt;   \u0026lt;!-- 视图前缀 --\u0026gt;  \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/templates/\u0026#34;/\u0026gt;   \u0026lt;!-- 视图后缀 --\u0026gt;  \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.html\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;templateMode\u0026#34; value=\u0026#34;HTML5\u0026#34;/\u0026gt;  \u0026lt;property name=\u0026#34;characterEncoding\u0026#34; value=\u0026#34;UTF-8\u0026#34; /\u0026gt;  \u0026lt;/bean\u0026gt;  \u0026lt;/property\u0026gt;  \u0026lt;/bean\u0026gt;  \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  \u0026lt;!-- 处理静态资源，例如html、js、css、jpg 若只设置该标签，则只能访问静态资源，其他请求则无法访问 此时必须设置\u0026lt;mvc:annotation-driven/\u0026gt;解决问题 这个开启，就表示访问静态资源时，SpringMVC会先去找，找不到这个资源，就默认的Servlet去找 再找不到就报错404 DefaultServletHttpRequestHandler --\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt;  \u0026lt;!-- 开启mvc注解驱动 --\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt;  \u0026lt;mvc:message-converters\u0026gt;  \u0026lt;!-- 处理响应中文内容乱码 --\u0026gt;  \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;defaultCharset\u0026#34; value=\u0026#34;UTF-8\u0026#34; /\u0026gt;  \u0026lt;property name=\u0026#34;supportedMediaTypes\u0026#34;\u0026gt;  \u0026lt;list\u0026gt;  \u0026lt;value\u0026gt;text/html\u0026lt;/value\u0026gt;  \u0026lt;value\u0026gt;application/json\u0026lt;/value\u0026gt;  \u0026lt;/list\u0026gt;  \u0026lt;/property\u0026gt;  \u0026lt;/bean\u0026gt;  \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt; 6、测试HelloWorld a\u0026gt;实现对首页的访问 在请求控制器中创建处理请求的方法\n// @RequestMapping注解：处理请求和控制器方法之间的映射关系 // @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径 // localhost:8080/springMVC/ @RequestMapping(\u0026#34;/\u0026#34;) public String index() {  //设置视图名称  return \u0026#34;index\u0026#34;; } b\u0026gt;通过超链接跳转到指定页面 在主页index.html中设置超链接\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;  \u0026lt;h1\u0026gt;首页\u0026lt;/h1\u0026gt;  \u0026lt;a th:href=\u0026#34;@{/hello}\u0026#34;\u0026gt;HelloWorld\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在请求控制器中创建处理请求的方法\n@RequestMapping(\u0026#34;/hello\u0026#34;) public String HelloWorld() {  return \u0026#34;target\u0026#34;; } 7、总结 浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面\n三、@RequestMapping注解 1、功能 从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。\nSpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。\n2、位置 @RequestMapping标识一个类：设置映射请求的请求路径的初始信息\n@RequestMapping标识一个方法：设置映射请求请求路径的具体信息\n@Controller @RequestMapping(\u0026#34;/test\u0026#34;) public class RequestMappingController {  \t//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping  @RequestMapping(\u0026#34;/testRequestMapping\u0026#34;)  public String testRequestMapping(){  return \u0026#34;success\u0026#34;;  }  } 3、属性 @RequestMapping注解的value属性通过请求的请求地址匹配请求映射\n@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求\n@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射\n\u0026lt;a th:href=\u0026#34;@{/testRequestMapping}\u0026#34;\u0026gt;测试@RequestMapping的value属性--\u0026gt;/testRequestMapping\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;a th:href=\u0026#34;@{/test}\u0026#34;\u0026gt;测试@RequestMapping的value属性--\u0026gt;/test\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; @RequestMapping(  value = {\u0026#34;/testRequestMapping\u0026#34;, \u0026#34;/test\u0026#34;} ) public String testRequestMapping(){  return \u0026#34;success\u0026#34;; } 4、method属性 @RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射\n@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求\n若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method \u0026lsquo;POST\u0026rsquo; not supported\n\u0026lt;a th:href=\u0026#34;@{/test}\u0026#34;\u0026gt;测试@RequestMapping的value属性--\u0026gt;/test\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;form th:action=\u0026#34;@{/test}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;  \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; @RequestMapping(  value = {\u0026#34;/testRequestMapping\u0026#34;, \u0026#34;/test\u0026#34;},  method = {RequestMethod.GET, RequestMethod.POST} ) public String testRequestMapping(){  return \u0026#34;success\u0026#34;; }  注：\n1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解\n处理get请求的映射\u0026ndash;\u0026gt;@GetMapping\n处理post请求的映射\u0026ndash;\u0026gt;@PostMapping\n处理put请求的映射\u0026ndash;\u0026gt;@PutMapping\n处理delete请求的映射\u0026ndash;\u0026gt;@DeleteMapping\n2、常用的请求方式有get，post，put，delete\n但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理\n若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到\n 5、params属性（了解） @RequestMapping注解的params属性通过请求的请求参数匹配请求映射\n@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系\n\u0026ldquo;param\u0026rdquo;：要求请求映射所匹配的请求必须携带param请求参数\n\u0026ldquo;!param\u0026rdquo;：要求请求映射所匹配的请求必须不能携带param请求参数\n\u0026ldquo;param=value\u0026rdquo;：要求请求映射所匹配的请求必须携带param请求参数且param=value\n\u0026ldquo;param!=value\u0026rdquo;：要求请求映射所匹配的请求必须携带param请求参数但是param!=value\n\u0026lt;a th:href=\u0026#34;@{/test(username=\u0026#39;admin\u0026#39;,password=123456)\u0026#34;\u0026gt;测试@RequestMapping的params属性--\u0026gt;/test\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; @RequestMapping(  value = {\u0026#34;/testRequestMapping\u0026#34;, \u0026#34;/test\u0026#34;}  ,method = {RequestMethod.GET, RequestMethod.POST}  ,params = {\u0026#34;username\u0026#34;,\u0026#34;password!=123456\u0026#34;} ) public String testRequestMapping(){  return \u0026#34;success\u0026#34;; }  注：\n若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions \u0026ldquo;username, password!=123456\u0026rdquo; not met for actual request parameters: username={admin}, password={123456}\n 6、headers属性（了解） @RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射\n@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系\n\u0026ldquo;header\u0026rdquo;：要求请求映射所匹配的请求必须携带header请求头信息\n\u0026ldquo;!header\u0026rdquo;：要求请求映射所匹配的请求必须不能携带header请求头信息\n\u0026ldquo;header=value\u0026rdquo;：要求请求映射所匹配的请求必须携带header请求头信息且header=value\n\u0026ldquo;header!=value\u0026rdquo;：要求请求映射所匹配的请求必须携带header请求头信息且header!=value\n若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到\n7、SpringMVC支持ant风格的路径 ？：表示任意的单个字符\n*：表示任意的0个或多个字符\n**：表示任意的一层或多层目录\n注意：在使用**时，只能使用/**/xxx的方式\n8、SpringMVC支持路径中的占位符（重点） 原始方式：/deleteUser?id=1\nrest方式：/deleteUser/1\nSpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参\n\u0026lt;a th:href=\u0026#34;@{/testRest/1/admin}\u0026#34;\u0026gt;测试路径中的占位符--\u0026gt;/testRest\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; @RequestMapping(\u0026#34;/testRest/{id}/{username}\u0026#34;) public String testRest(@PathVariable(\u0026#34;id\u0026#34;) String id, @PathVariable(\u0026#34;username\u0026#34;) String username){  System.out.println(\u0026#34;id:\u0026#34;+id+\u0026#34;,username:\u0026#34;+username);  return \u0026#34;success\u0026#34;; } //最终输出的内容为--\u0026gt;id:1,username:admin 四、SpringMVC获取请求参数 1、通过ServletAPI获取 将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象\n@RequestMapping(\u0026#34;/testParam\u0026#34;) public String testParam(HttpServletRequest request){  String username = request.getParameter(\u0026#34;username\u0026#34;);  String password = request.getParameter(\u0026#34;password\u0026#34;);  System.out.println(\u0026#34;username:\u0026#34;+username+\u0026#34;,password:\u0026#34;+password);  return \u0026#34;success\u0026#34;; } 2、通过控制器方法的形参获取请求参数 在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参\n\u0026lt;a th:href=\u0026#34;@{/testParam(username=\u0026#39;admin\u0026#39;,password=123456)}\u0026#34;\u0026gt;测试获取请求参数--\u0026gt;/testParam\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; @RequestMapping(\u0026#34;/testParam\u0026#34;) public String testParam(String username, String password){  System.out.println(\u0026#34;username:\u0026#34;+username+\u0026#34;,password:\u0026#34;+password);  return \u0026#34;success\u0026#34;; }  注：\n若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数\n若使用字符串数组类型的形参，此参数的数组中包含了每一个数据\n若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果\n 3、@RequestParam @RequestParam是将请求参数和控制器方法的形参创建映射关系\n@RequestParam注解一共有三个属性：\n  value：指定为形参赋值的请求参数的参数名\n  required：设置是否必须传输此请求参数，默认值为true\n若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter \u0026lsquo;xxx\u0026rsquo; is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null\n  defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为\u0026quot;\u0026ldquo;时，则使用默认值为形参赋值\n  4、@RequestHeader @RequestHeader是将请求头信息和控制器方法的形参创建映射关系\n@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam\n5、@CookieValue @CookieValue是将cookie数据和控制器方法的形参创建映射关系\n@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam\n6、通过POJO获取请求参数 可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值\n\u0026lt;form th:action=\u0026#34;@{/testpojo}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;  用户名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt;  密码：\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br\u0026gt;  性别：\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;男\u0026#34;\u0026gt;男\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;女\u0026#34;\u0026gt;女\u0026lt;br\u0026gt;  年龄：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;br\u0026gt;  邮箱：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;br\u0026gt;  \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; @RequestMapping(\u0026#34;/testpojo\u0026#34;) public String testPOJO(User user){  System.out.println(user);  return \u0026#34;success\u0026#34;; } //最终结果--\u0026gt;User{id=null, username=\u0026#39;张三\u0026#39;, password=\u0026#39;123\u0026#39;, age=23, sex=\u0026#39;男\u0026#39;, email=\u0026#39;123@qq.com\u0026#39;} 7、解决获取请求参数的乱码问题 解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册\n\u0026lt;!--配置springMVC的编码过滤器--\u0026gt; \u0026lt;filter\u0026gt;  \u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt;  \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt;  \u0026lt;init-param\u0026gt;  \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt;  \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt;  \u0026lt;/init-param\u0026gt;  \u0026lt;init-param\u0026gt;  \u0026lt;param-name\u0026gt;forceResponseEncoding\u0026lt;/param-name\u0026gt;  \u0026lt;param-value\u0026gt;true\u0026lt;/param-value\u0026gt;  \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt;  \u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt;  \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;  注：\nSpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效\n 五、域对象共享数据 1、使用ServletAPI向request域对象共享数据 @RequestMapping(\u0026#34;/testServletAPI\u0026#34;) public String testServletAPI(HttpServletRequest request){  request.setAttribute(\u0026#34;testScope\u0026#34;, \u0026#34;hello,servletAPI\u0026#34;);  return \u0026#34;success\u0026#34;; } 2、使用ModelAndView向request域对象共享数据 @RequestMapping(\u0026#34;/testModelAndView\u0026#34;) public ModelAndView testModelAndView(){  /** * ModelAndView有Model和View的功能 * Model主要用于向请求域共享数据 * View主要用于设置视图，实现页面跳转 */  ModelAndView mav = new ModelAndView();  //向请求域共享数据  mav.addObject(\u0026#34;testScope\u0026#34;, \u0026#34;hello,ModelAndView\u0026#34;);  //设置视图，实现页面跳转  mav.setViewName(\u0026#34;success\u0026#34;);  return mav; } 3、使用Model向request域对象共享数据 @RequestMapping(\u0026#34;/testModel\u0026#34;) public String testModel(Model model){  model.addAttribute(\u0026#34;testScope\u0026#34;, \u0026#34;hello,Model\u0026#34;);  return \u0026#34;success\u0026#34;; } 4、使用map向request域对象共享数据 @RequestMapping(\u0026#34;/testMap\u0026#34;) public String testMap(Map\u0026lt;String, Object\u0026gt; map){  map.put(\u0026#34;testScope\u0026#34;, \u0026#34;hello,Map\u0026#34;);  return \u0026#34;success\u0026#34;; } 5、使用ModelMap向request域对象共享数据 @RequestMapping(\u0026#34;/testModelMap\u0026#34;) public String testModelMap(ModelMap modelMap){  modelMap.addAttribute(\u0026#34;testScope\u0026#34;, \u0026#34;hello,ModelMap\u0026#34;);  return \u0026#34;success\u0026#34;; } 6、Model、ModelMap、Map的关系 Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的\npublic interface Model{}\rpublic class ModelMap extends LinkedHashMap\u0026lt;String, Object\u0026gt; {}\rpublic class ExtendedModelMap extends ModelMap implements Model {}\rpublic class BindingAwareModelMap extends ExtendedModelMap {} 7、向session域共享数据 @RequestMapping(\u0026#34;/testSession\u0026#34;) public String testSession(HttpSession session){  session.setAttribute(\u0026#34;testSessionScope\u0026#34;, \u0026#34;hello,session\u0026#34;);  return \u0026#34;success\u0026#34;; } 8、向application域共享数据 @RequestMapping(\u0026#34;/testApplication\u0026#34;) public String testApplication(HttpSession session){ \tServletContext application = session.getServletContext();  application.setAttribute(\u0026#34;testApplicationScope\u0026#34;, \u0026#34;hello,application\u0026#34;);  return \u0026#34;success\u0026#34;; } 六、SpringMVC的视图 SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户\nSpringMVC视图的种类很多，默认有转发视图和重定向视图\n当工程引入jstl的依赖，转发视图会自动转换为JstlView\n若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView\n1、ThymeleafView 当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转\n@RequestMapping(\u0026#34;/testHello\u0026#34;) public String testHello(){  return \u0026#34;hello\u0026#34;; } 2、转发视图 SpringMVC中默认的转发视图是InternalResourceView\nSpringMVC中创建转发视图的情况：\n当控制器方法中所设置的视图名称以\u0026quot;forward:\u0026ldquo;为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀\u0026quot;forward:\u0026ldquo;去掉，剩余部分作为最终路径通过转发的方式实现跳转\n例如\u0026quot;forward:/\u0026quot;，\u0026ldquo;forward:/employee\u0026rdquo;\n@RequestMapping(\u0026#34;/testForward\u0026#34;) public String testForward(){  return \u0026#34;forward:/testHello\u0026#34;; } 3、重定向视图 SpringMVC中默认的重定向视图是RedirectView\n当控制器方法中所设置的视图名称以\u0026quot;redirect:\u0026ldquo;为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀\u0026quot;redirect:\u0026ldquo;去掉，剩余部分作为最终路径通过重定向的方式实现跳转\n例如\u0026quot;redirect:/\u0026quot;，\u0026ldquo;redirect:/employee\u0026rdquo;\n@RequestMapping(\u0026#34;/testRedirect\u0026#34;) public String testRedirect(){  return \u0026#34;redirect:/testHello\u0026#34;; }  注：\n重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径\n 4、视图控制器view-controller 当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示\n\u0026lt;!-- path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称 --\u0026gt; \u0026lt;mvc:view-controller path=\u0026#34;/testView\u0026#34; view-name=\u0026#34;success\u0026#34;\u0026gt;\u0026lt;/mvc:view-controller\u0026gt;  注：\n当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：\n\u0026lt;mvc:annotation-driven /\u0026gt;\n 七、RESTful 1、RESTful简介 REST：Representational State Transfer，表现层资源状态转移。\na\u0026gt;资源 资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。\nb\u0026gt;资源的表述 资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。\nc\u0026gt;状态转移 状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。\n2、RESTful的实现 具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。\n它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。\nREST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。\n   操作 传统方式 REST风格     查询操作 getUserById?id=1 user/1\u0026ndash;\u0026gt;get请求方式   保存操作 saveUser user\u0026ndash;\u0026gt;post请求方式   删除操作 deleteUser?id=1 user/1\u0026ndash;\u0026gt;delete请求方式   更新操作 updateUser user\u0026ndash;\u0026gt;put请求方式    3、==HiddenHttpMethodFilter== 由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？\nSpringMVC 提供了 HiddenHttpMethodFilter 帮助我们**==将 POST 请求==转换为 DELETE 或 PUT 请求**\nHiddenHttpMethodFilter 处理put和delete请求的条件：\n==a\u0026gt;当前请求的请求方式必须为post==\n==b\u0026gt;当前请求必须传输请求参数_method==\n满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式\n在web.xml中注册HiddenHttpMethodFilter\n\u0026lt;filter\u0026gt;  \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilter\u0026lt;/filter-name\u0026gt;  \u0026lt;filter-class\u0026gt;org.springframework.web.filter.HiddenHttpMethodFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt;  \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilter\u0026lt;/filter-name\u0026gt;  \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;  ==注：==\n==目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter==\n==在web.xml中注册时，必须先注册CharacterEncodingFilter（写在前面），再注册HiddenHttpMethodFilter==\n==原因：==\n  ==在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的==\n  ==request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作==\n  ==而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：==\n  ==String paramValue = request.getParameter(this.methodParam); ==\n 八、RESTful案例 1、准备工作 和传统 CRUD 一样，实现对员工信息的增删改查。\n  搭建环境\n  准备实体类\npackage com.atguigu.mvc.bean;  public class Employee {   private Integer id;  private String lastName;   private String email;  //1 male, 0 female  private Integer gender;   public Integer getId() {  return id;  }   public void setId(Integer id) {  this.id = id;  }   public String getLastName() {  return lastName;  }   public void setLastName(String lastName) {  this.lastName = lastName;  }   public String getEmail() {  return email;  }   public void setEmail(String email) {  this.email = email;  }   public Integer getGender() {  return gender;  }   public void setGender(Integer gender) {  this.gender = gender;  }   public Employee(Integer id, String lastName, String email, Integer gender) {  super();  this.id = id;  this.lastName = lastName;  this.email = email;  this.gender = gender;  }   public Employee() {  } }   准备dao模拟数据\npackage com.atguigu.mvc.dao;  import java.util.Collection; import java.util.HashMap; import java.util.Map;  import com.atguigu.mvc.bean.Employee; import org.springframework.stereotype.Repository;   @Repository public class EmployeeDao {   private static Map\u0026lt;Integer, Employee\u0026gt; employees = null;   static{  employees = new HashMap\u0026lt;Integer, Employee\u0026gt;();   employees.put(1001, new Employee(1001, \u0026#34;E-AA\u0026#34;, \u0026#34;aa@163.com\u0026#34;, 1));  employees.put(1002, new Employee(1002, \u0026#34;E-BB\u0026#34;, \u0026#34;bb@163.com\u0026#34;, 1));  employees.put(1003, new Employee(1003, \u0026#34;E-CC\u0026#34;, \u0026#34;cc@163.com\u0026#34;, 0));  employees.put(1004, new Employee(1004, \u0026#34;E-DD\u0026#34;, \u0026#34;dd@163.com\u0026#34;, 0));  employees.put(1005, new Employee(1005, \u0026#34;E-EE\u0026#34;, \u0026#34;ee@163.com\u0026#34;, 1));  }   private static Integer initId = 1006;   public void save(Employee employee){  if(employee.getId() == null){  employee.setId(initId++);  }  employees.put(employee.getId(), employee);  }   public Collection\u0026lt;Employee\u0026gt; getAll(){  return employees.values();  }   public Employee get(Integer id){  return employees.get(id);  }   public void delete(Integer id){  employees.remove(id);  } }   2、功能清单    功能 URL 地址 请求方式     访问首页√ / GET   查询全部数据√ /employee GET   删除√ /employee/2 DELETE   跳转到添加数据页面√ /toAdd GET   执行保存√ /employee POST   跳转到更新数据页面√ /employee/2 GET   执行更新√ /employee PUT    3、具体功能：访问首页 a\u0026gt;配置view-controller \u0026lt;mvc:view-controller path=\u0026#34;/\u0026#34; view-name=\u0026#34;index\u0026#34;/\u0026gt; b\u0026gt;创建页面 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; \u0026gt;  \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;首页\u0026lt;/h1\u0026gt; \u0026lt;a th:href=\u0026#34;@{/employee}\u0026#34;\u0026gt;访问员工信息\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4、具体功能：查询所有员工数据 a\u0026gt;控制器方法 @RequestMapping(value = \u0026#34;/employee\u0026#34;, method = RequestMethod.GET) public String getEmployeeList(Model model){  Collection\u0026lt;Employee\u0026gt; employeeList = employeeDao.getAll();  model.addAttribute(\u0026#34;employeeList\u0026#34;, employeeList);  return \u0026#34;employee_list\u0026#34;; } b\u0026gt;创建employee_list.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;Employee Info\u0026lt;/title\u0026gt;  \u0026lt;script type=\u0026#34;text/javascript\u0026#34; th:src=\u0026#34;@{/static/js/vue.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;   \u0026lt;table border=\u0026#34;1\u0026#34; cellpadding=\u0026#34;0\u0026#34; cellspacing=\u0026#34;0\u0026#34; style=\u0026#34;text-align: center;\u0026#34; id=\u0026#34;dataTable\u0026#34;\u0026gt;  \u0026lt;tr\u0026gt;  \u0026lt;th colspan=\u0026#34;5\u0026#34;\u0026gt;Employee Info\u0026lt;/th\u0026gt;  \u0026lt;/tr\u0026gt;  \u0026lt;tr\u0026gt;  \u0026lt;th\u0026gt;id\u0026lt;/th\u0026gt;  \u0026lt;th\u0026gt;lastName\u0026lt;/th\u0026gt;  \u0026lt;th\u0026gt;email\u0026lt;/th\u0026gt;  \u0026lt;th\u0026gt;gender\u0026lt;/th\u0026gt;  \u0026lt;th\u0026gt;options(\u0026lt;a th:href=\u0026#34;@{/toAdd}\u0026#34;\u0026gt;add\u0026lt;/a\u0026gt;)\u0026lt;/th\u0026gt;  \u0026lt;/tr\u0026gt;  \u0026lt;tr th:each=\u0026#34;employee : ${employeeList}\u0026#34;\u0026gt;  \u0026lt;td th:text=\u0026#34;${employee.id}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt;  \u0026lt;td th:text=\u0026#34;${employee.lastName}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt;  \u0026lt;td th:text=\u0026#34;${employee.email}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt;  \u0026lt;td th:text=\u0026#34;${employee.gender}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt;  \u0026lt;td\u0026gt;  \u0026lt;a class=\u0026#34;deleteA\u0026#34; @click=\u0026#34;deleteEmployee\u0026#34; th:href=\u0026#34;@{\u0026#39;/employee/\u0026#39;+${employee.id}}\u0026#34;\u0026gt;delete\u0026lt;/a\u0026gt;  \u0026lt;a th:href=\u0026#34;@{\u0026#39;/employee/\u0026#39;+${employee.id}}\u0026#34;\u0026gt;update\u0026lt;/a\u0026gt;  \u0026lt;/td\u0026gt;  \u0026lt;/tr\u0026gt;  \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 5、具体功能：删除 a\u0026gt;创建处理delete请求方式的表单 \u0026lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --\u0026gt; \u0026lt;form id=\u0026#34;delete_form\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;  \u0026lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --\u0026gt;  \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;_method\u0026#34; value=\u0026#34;delete\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; b\u0026gt;删除超链接绑定点击事件 引入vue.js\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; th:src=\u0026#34;@{/static/js/vue.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 删除超链接\n\u0026lt;a class=\u0026#34;deleteA\u0026#34; @click=\u0026#34;deleteEmployee\u0026#34; th:href=\u0026#34;@{\u0026#39;/employee/\u0026#39;+${employee.id}}\u0026#34;\u0026gt;delete\u0026lt;/a\u0026gt; 通过vue处理点击事件\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt;  var vue = new Vue({  el:\u0026#34;#dataTable\u0026#34;,  methods:{  //event表示当前事件  deleteEmployee:function (event) {  //通过id获取表单标签  var delete_form = document.getElementById(\u0026#34;delete_form\u0026#34;);  //将触发事件的超链接的href属性为表单的action属性赋值  delete_form.action = event.target.href;  //提交表单  delete_form.submit();  //阻止超链接的默认跳转行为  event.preventDefault();  }  }  }); \u0026lt;/script\u0026gt; c\u0026gt;控制器方法 @RequestMapping(value = \u0026#34;/employee/{id}\u0026#34;, method = RequestMethod.DELETE) public String deleteEmployee(@PathVariable(\u0026#34;id\u0026#34;) Integer id){  employeeDao.delete(id);  return \u0026#34;redirect:/employee\u0026#34;; } 6、具体功能：跳转到添加数据页面 a\u0026gt;配置view-controller \u0026lt;mvc:view-controller path=\u0026#34;/toAdd\u0026#34; view-name=\u0026#34;employee_add\u0026#34;\u0026gt;\u0026lt;/mvc:view-controller\u0026gt; b\u0026gt;创建employee_add.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;Add Employee\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;  \u0026lt;form th:action=\u0026#34;@{/employee}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;  lastName:\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;lastName\u0026#34;\u0026gt;\u0026lt;br\u0026gt;  email:\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;br\u0026gt;  gender:\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt;male  \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;0\u0026#34;\u0026gt;female\u0026lt;br\u0026gt;  \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;add\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/form\u0026gt;  \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 7、具体功能：执行保存 a\u0026gt;控制器方法 @RequestMapping(value = \u0026#34;/employee\u0026#34;, method = RequestMethod.POST) public String addEmployee(Employee employee){  employeeDao.save(employee);  return \u0026#34;redirect:/employee\u0026#34;; } 8、具体功能：跳转到更新数据页面 a\u0026gt;修改超链接 \u0026lt;a th:href=\u0026#34;@{\u0026#39;/employee/\u0026#39;+${employee.id}}\u0026#34;\u0026gt;update\u0026lt;/a\u0026gt; b\u0026gt;控制器方法 @RequestMapping(value = \u0026#34;/employee/{id}\u0026#34;, method = RequestMethod.GET) public String getEmployeeById(@PathVariable(\u0026#34;id\u0026#34;) Integer id, Model model){  Employee employee = employeeDao.get(id);  model.addAttribute(\u0026#34;employee\u0026#34;, employee);  return \u0026#34;employee_update\u0026#34;; } c\u0026gt;创建employee_update.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt;  \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;  \u0026lt;title\u0026gt;Update Employee\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;  \u0026lt;form th:action=\u0026#34;@{/employee}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;  \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;_method\u0026#34; value=\u0026#34;put\u0026#34;\u0026gt;  \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;id\u0026#34; th:value=\u0026#34;${employee.id}\u0026#34;\u0026gt;  lastName:\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;lastName\u0026#34; th:value=\u0026#34;${employee.lastName}\u0026#34;\u0026gt;\u0026lt;br\u0026gt;  email:\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;email\u0026#34; th:value=\u0026#34;${employee.email}\u0026#34;\u0026gt;\u0026lt;br\u0026gt;  \u0026lt;!-- th:field=\u0026#34;${employee.gender}\u0026#34;可用于单选框或复选框的回显 若单选框的value和employee.gender的值一致，则添加checked=\u0026#34;checked\u0026#34;属性 --\u0026gt;  gender:\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34; th:field=\u0026#34;${employee.gender}\u0026#34;\u0026gt;male  \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;0\u0026#34; th:field=\u0026#34;${employee.gender}\u0026#34;\u0026gt;female\u0026lt;br\u0026gt;  \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;update\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/form\u0026gt;  \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 9、具体功能：执行更新 a\u0026gt;控制器方法 @RequestMapping(value = \u0026#34;/employee\u0026#34;, method = RequestMethod.PUT) public String updateEmployee(Employee employee){  employeeDao.save(employee);  return \u0026#34;redirect:/employee\u0026#34;; } 八、HttpMessageConverter HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文\nHttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，\nResponseEntity\n1、@RequestBody @RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值\n\u0026lt;form th:action=\u0026#34;@{/testRequestBody}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;  用户名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt;  密码：\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br\u0026gt;  \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; @PostMapping(\u0026#34;/testRequestBody\u0026#34;) public String testRequestBody(@RequestBody String requestBody){  System.out.println(\u0026#34;requestBody:\u0026#34;+requestBody);  return \u0026#34;success\u0026#34;; } 输出结果：\nrequestBody:username=admin\u0026amp;password=123456\n2、RequestEntity RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息\n@PostMapping(\u0026#34;/testRequestEntity\u0026#34;) public String testRequestEntity(@RequestEntity \u0026lt;String\u0026gt; requestEntity){  System.out.println(\u0026#34;requestHeader:\u0026#34;+requestEntity.getHeaders());  System.out.println(\u0026#34;requestBody:\u0026#34;+requestEntity.getBody());  return \u0026#34;success\u0026#34;; } 输出结果： requestHeader:[host:\u0026ldquo;localhost:8080\u0026rdquo;, connection:\u0026ldquo;keep-alive\u0026rdquo;, content-length:\u0026ldquo;27\u0026rdquo;, cache-control:\u0026ldquo;max-age=0\u0026rdquo;, sec-ch-ua:\u0026rdquo;\u0026rdquo; Not A;Brand\u0026rdquo;;v=\u0026ldquo;99\u0026rdquo;, \u0026ldquo;Chromium\u0026rdquo;;v=\u0026ldquo;90\u0026rdquo;, \u0026ldquo;Google Chrome\u0026rdquo;;v=\u0026ldquo;90\u0026quot;\u0026rdquo;, sec-ch-ua-mobile:\u0026quot;?0\u0026rdquo;, upgrade-insecure-requests:\u0026ldquo;1\u0026rdquo;, origin:\u0026ldquo;http://localhost:8080\u0026rdquo;, user-agent:\u0026ldquo;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36\u0026rdquo;] requestBody:username=admin\u0026amp;password=123\n3、@ResponseBody @ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器\n@RequestMapping(\u0026#34;/testResponseBody\u0026#34;) @ResponseBody public String testResponseBody(){  return \u0026#34;success\u0026#34;; } 结果：浏览器页面显示success\n4、SpringMVC处理json @ResponseBody处理json的步骤：\na\u0026gt;导入jackson的依赖\n \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;2.12.1\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt; \u0026lt;!--或者 --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.2.76\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt; b\u0026gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串\n\u0026lt;mvc:annotation-driven /\u0026gt; c\u0026gt;在处理器方法上使用@ResponseBody注解进行标识\nd\u0026gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串\n@RequestMapping(\u0026#34;/testResponseUser\u0026#34;) @ResponseBody public User testResponseUser(){  return new User(1001,\u0026#34;admin\u0026#34;,\u0026#34;123456\u0026#34;,23,\u0026#34;男\u0026#34;); } 浏览器的页面中展示的结果：\n{\u0026ldquo;id\u0026rdquo;:1001,\u0026ldquo;username\u0026rdquo;:\u0026ldquo;admin\u0026rdquo;,\u0026ldquo;password\u0026rdquo;:\u0026ldquo;123456\u0026rdquo;,\u0026ldquo;age\u0026rdquo;:23,\u0026ldquo;sex\u0026rdquo;:\u0026ldquo;男\u0026rdquo;}\n5、SpringMVC处理ajax a\u0026gt;请求超链接：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \t\u0026lt;a th:href=\u0026#34;@{/testAjax}\u0026#34; @click=\u0026#34;testAjax\u0026#34;\u0026gt;testAjax\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/div\u0026gt; b\u0026gt;通过vue和axios处理点击事件：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; th:src=\u0026#34;@{/static/js/vue.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; th:src=\u0026#34;@{/static/js/axios.min.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt;  var vue = new Vue({  el:\u0026#34;#app\u0026#34;,  methods:{  testAjax:function (event) {  axios({  method:\u0026#34;post\u0026#34;,  url:event.target.href,  params:{  username:\u0026#34;admin\u0026#34;,  password:\u0026#34;123456\u0026#34;  }  }).then(function (response) {  alert(response.data);  });  event.preventDefault();  }  }  }); \u0026lt;/script\u0026gt; c\u0026gt;控制器方法：\n@RequestMapping(\u0026#34;/testAjax\u0026#34;) @ResponseBody public String testAjax(String username, String password){  System.out.println(\u0026#34;username:\u0026#34;+username+\u0026#34;,password:\u0026#34;+password);  return \u0026#34;hello,ajax\u0026#34;; } 6、@RestController注解 @RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解\n7、ResponseEntity ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文\n九、文件上传和下载 1、文件下载 使用ResponseEntity实现下载文件的功能\n@RequestMapping(\u0026#34;/testDown\u0026#34;) public ResponseEntity\u0026lt;byte[]\u0026gt; testResponseEntity(HttpSession session) throws IOException {  //获取ServletContext对象  ServletContext servletContext = session.getServletContext();  //获取服务器中文件的真实路径  String realPath = servletContext.getRealPath(\u0026#34;/static/img/1.jpg\u0026#34;);  //创建输入流  InputStream is = new FileInputStream(realPath);  //创建字节数组  byte[] bytes = new byte[is.available()];  //将流读到字节数组中  is.read(bytes);  //创建HttpHeaders对象设置响应头信息  MultiValueMap\u0026lt;String, String\u0026gt; headers = new HttpHeaders();  //设置要下载方式以及下载文件的名字  headers.add(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;filename=1.jpg\u0026#34;);  //设置响应状态码  HttpStatus statusCode = HttpStatus.OK;  //创建ResponseEntity对象  ResponseEntity\u0026lt;byte[]\u0026gt; responseEntity = new ResponseEntity\u0026lt;\u0026gt;(bytes, headers, statusCode);  //关闭输入流  is.close();  return responseEntity; } 2、文件上传 文件上传要求form表单的请求方式必须为post，并且添加属性enctype=\u0026ldquo;multipart/form-data\u0026rdquo;\nSpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息\n上传步骤：\na\u0026gt;添加依赖：\n\u0026lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --\u0026gt; \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;commons-fileupload\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;commons-fileupload\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; b\u0026gt;在SpringMVC的配置文件中添加配置：\n\u0026lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--\u0026gt; \u0026lt;bean id=\u0026#34;multipartResolver\u0026#34; class=\u0026#34;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; c\u0026gt;控制器方法：\n@RequestMapping(\u0026#34;/testUp\u0026#34;) public String testUp(MultipartFile photo, HttpSession session) throws IOException {  //获取上传的文件的文件名  String fileName = photo.getOriginalFilename();  //处理文件重名问题  String hzName = fileName.substring(fileName.lastIndexOf(\u0026#34;.\u0026#34;));  fileName = UUID.randomUUID().toString() + hzName;  //获取服务器中photo目录的路径  ServletContext servletContext = session.getServletContext();  String photoPath = servletContext.getRealPath(\u0026#34;photo\u0026#34;);  File file = new File(photoPath);  if(!file.exists()){  file.mkdir();  }  String finalPath = photoPath + File.separator + fileName;  //实现上传功能  photo.transferTo(new File(finalPath));  return \u0026#34;success\u0026#34;; } 十、拦截器 1、拦截器的配置 SpringMVC中的拦截器用于拦截控制器方法的执行\nSpringMVC中的拦截器需要实现HandlerInterceptor\nSpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：\n\u0026lt;bean class=\u0026#34;com.atguigu.interceptor.FirstInterceptor\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;ref bean=\u0026#34;firstInterceptor\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --\u0026gt; \u0026lt;mvc:interceptor\u0026gt;  \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt;  \u0026lt;mvc:exclude-mapping path=\u0026#34;/testRequestEntity\u0026#34;/\u0026gt;  \u0026lt;ref bean=\u0026#34;firstInterceptor\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;!-- 以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求 --\u0026gt; 2、拦截器的三个抽象方法 SpringMVC中的拦截器有三个抽象方法：\npreHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法\npostHandle：控制器方法执行之后执行postHandle()\nafterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()\n3、多个拦截器的执行顺序 拦截器的使用80~81\na\u0026gt;若每个拦截器的preHandle()都返回true\n此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：\npreHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行\nb\u0026gt;若某个拦截器的preHandle()返回了false\npreHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行\n十一、异常处理器 1、基于配置的异常处理 SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver\nHandlerExceptionResolver接口的实现类有：\n DefaultHandlerExceptionResolver 这是SpringMVC默认的异常处理器我们不能使用，其父类是顶层的HandlerExceptionResolver SimpleMappingExceptionResolver 这个是给我自定义使用异常处理器，用于出现异常返回新的modelandview 并跳转到指定页面。  SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：\n\u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\u0026#34;\u0026gt;  \u0026lt;property name=\u0026#34;exceptionMappings\u0026#34;\u0026gt;  \u0026lt;props\u0026gt;  \u0026lt;!-- properties的键表示处理器方法执行过程中出现的异常 properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面 --\u0026gt;  \u0026lt;prop key=\u0026#34;java.lang.ArithmeticException\u0026#34;\u0026gt;error\u0026lt;/prop\u0026gt;  \u0026lt;/props\u0026gt;  \u0026lt;/property\u0026gt;  \u0026lt;!-- exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享 --\u0026gt;  \u0026lt;property name=\u0026#34;exceptionAttribute\u0026#34; value=\u0026#34;ex\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; ==2、基于注解的异常处理== //@ControllerAdvice将当前类标识为异常处理的组件 @ControllerAdvice public class ExceptionController {   //@ExceptionHandler用于设置所标识方法处理的异常  @ExceptionHandler(ArithmeticException.class)  //ex表示当前请求处理中出现的异常对象  public String handleArithmeticException(Exception ex, Model model){  model.addAttribute(\u0026#34;ex\u0026#34;, ex);  return \u0026#34;error\u0026#34;;  }  } ==十二、注解配置SpringMVC== 使用配置类和注解代替web.xml和SpringMVC配置文件的功能\n1、创建初始化类，代替web.xml 在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。\npublic class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer {   /** * 指定spring的配置类 * @return */  @Override  protected Class\u0026lt;?\u0026gt;[] getRootConfigClasses() {  return new Class[]{SpringConfig.class};  }   /** * 指定SpringMVC的配置类 * @return */  @Override  protected Class\u0026lt;?\u0026gt;[] getServletConfigClasses() {  return new Class[]{WebConfig.class};  }   /** * 指定DispatcherServlet的映射规则，即url-pattern * @return */  @Override  protected String[] getServletMappings() {  return new String[]{\u0026#34;/\u0026#34;};  }   /** * 添加过滤器 * @return */  @Override  protected Filter[] getServletFilters() {  CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();  encodingFilter.setEncoding(\u0026#34;UTF-8\u0026#34;);  encodingFilter.setForceRequestEncoding(true);  HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();  return new Filter[]{encodingFilter, hiddenHttpMethodFilter};  } } 2、创建SpringConfig配置类，代替spring的配置文件 @Configuration public class SpringConfig { \t//ssm整合之后，spring的配置信息写在此类中 } 3、创建WebConfig配置类，代替SpringMVC的配置文件 @Configuration //扫描组件 @ComponentScan(\u0026#34;com.atguigu.mvc.controller\u0026#34;) //开启MVC注解驱动 @EnableWebMvc public class WebConfig implements WebMvcConfigurer {   //使用默认的servlet处理静态资源  @Override  public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {  configurer.enable();  }   //配置文件上传解析器  @Bean  public CommonsMultipartResolver multipartResolver(){  return new CommonsMultipartResolver();  }   //配置拦截器  @Override  public void addInterceptors(InterceptorRegistry registry) {  FirstInterceptor firstInterceptor = new FirstInterceptor();  registry.addInterceptor(firstInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;);  }   //配置视图控制   /*@Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026#34;/\u0026#34;).setViewName(\u0026#34;index\u0026#34;); }*/   //配置异常映射  /*@Override public void configureHandlerExceptionResolvers(List\u0026lt;HandlerExceptionResolver\u0026gt; resolvers) { SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties prop = new Properties(); prop.setProperty(\u0026#34;java.lang.ArithmeticException\u0026#34;, \u0026#34;error\u0026#34;); //设置异常映射 exceptionResolver.setExceptionMappings(prop); //设置共享异常信息的键 exceptionResolver.setExceptionAttribute(\u0026#34;ex\u0026#34;); resolvers.add(exceptionResolver); }*/   //配置生成模板解析器  @Bean  public ITemplateResolver templateResolver() {  WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();  // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得  ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(  webApplicationContext.getServletContext());  templateResolver.setPrefix(\u0026#34;/WEB-INF/templates/\u0026#34;);  templateResolver.setSuffix(\u0026#34;.html\u0026#34;);  templateResolver.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;);  templateResolver.setTemplateMode(TemplateMode.HTML);  return templateResolver;  }   //生成模板引擎并为模板引擎注入模板解析器  @Bean  public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {  SpringTemplateEngine templateEngine = new SpringTemplateEngine();  templateEngine.setTemplateResolver(templateResolver);  return templateEngine;  }   //生成视图解析器并未解析器注入模板引擎  @Bean  public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {  ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();  viewResolver.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;);  viewResolver.setTemplateEngine(templateEngine);  return viewResolver;  }   } 4、测试功能 @RequestMapping(\u0026#34;/\u0026#34;) public String index(){  return \u0026#34;index\u0026#34;; } 十三、SpringMVC执行流程 1、SpringMVC常用组件  DispatcherServlet：前端控制器，不需要工程师开发，由框架提供  作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求\n HandlerMapping：处理器映射器，不需要工程师开发，由框架提供  作用：根据请求的url、method等信息查找Handler，即控制器方法\n Handler：处理器，需要工程师开发  作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理\n HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供  作用：通过HandlerAdapter对处理器（控制器方法）进行执行\n ViewResolver：视图解析器，不需要工程师开发，由框架提供  作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView\n View：视图  作用：将模型数据通过页面展示给用户\n2、DispatcherServlet初始化过程 DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。\na\u0026gt;初始化WebApplicationContext 所在类：org.springframework.web.servlet.FrameworkServlet\nprotected WebApplicationContext initWebApplicationContext() {  WebApplicationContext rootContext =  WebApplicationContextUtils.getWebApplicationContext(getServletContext());  WebApplicationContext wac = null;   if (this.webApplicationContext != null) {  // A context instance was injected at construction time -\u0026gt; use it  wac = this.webApplicationContext;  if (wac instanceof ConfigurableWebApplicationContext) {  ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;  if (!cwac.isActive()) {  // The context has not yet been refreshed -\u0026gt; provide services such as  // setting the parent context, setting the application context id, etc  if (cwac.getParent() == null) {  // The context instance was injected without an explicit parent -\u0026gt; set  // the root application context (if any; may be null) as the parent  cwac.setParent(rootContext);  }  configureAndRefreshWebApplicationContext(cwac);  }  }  }  if (wac == null) {  // No context instance was injected at construction time -\u0026gt; see if one  // has been registered in the servlet context. If one exists, it is assumed  // that the parent context (if any) has already been set and that the  // user has performed any initialization such as setting the context id  wac = findWebApplicationContext();  }  if (wac == null) {  // No context instance is defined for this servlet -\u0026gt; create a local one  // 创建WebApplicationContext  wac = createWebApplicationContext(rootContext);  }   if (!this.refreshEventReceived) {  // Either the context is not a ConfigurableApplicationContext with refresh  // support or the context injected at construction time had already been  // refreshed -\u0026gt; trigger initial onRefresh manually here.  synchronized (this.onRefreshMonitor) {  // 刷新WebApplicationContext  onRefresh(wac);  }  }   if (this.publishContext) {  // Publish the context as a servlet context attribute.  // 将IOC容器在应用域共享  String attrName = getServletContextAttributeName();  getServletContext().setAttribute(attrName, wac);  }   return wac; } b\u0026gt;创建WebApplicationContext 所在类：org.springframework.web.servlet.FrameworkServlet\nprotected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) {  Class\u0026lt;?\u0026gt; contextClass = getContextClass();  if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {  throw new ApplicationContextException(  \u0026#34;Fatal initialization error in servlet with name \u0026#39;\u0026#34; + getServletName() +  \u0026#34;\u0026#39;: custom WebApplicationContext class [\u0026#34; + contextClass.getName() +  \u0026#34;] is not of type ConfigurableWebApplicationContext\u0026#34;);  }  // 通过反射创建 IOC 容器对象  ConfigurableWebApplicationContext wac =  (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);   wac.setEnvironment(getEnvironment());  // 设置父容器  wac.setParent(parent);  String configLocation = getContextConfigLocation();  if (configLocation != null) {  wac.setConfigLocation(configLocation);  }  configureAndRefreshWebApplicationContext(wac);   return wac; } c\u0026gt;DispatcherServlet初始化策略 FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件\n所在类：org.springframework.web.servlet.DispatcherServlet\nprotected void initStrategies(ApplicationContext context) {  initMultipartResolver(context);  initLocaleResolver(context);  initThemeResolver(context);  initHandlerMappings(context);  initHandlerAdapters(context);  initHandlerExceptionResolvers(context);  initRequestToViewNameTranslator(context);  initViewResolvers(context);  initFlashMapManager(context); } 3、DispatcherServlet调用组件处理请求 a\u0026gt;processRequest() FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)\n所在类：org.springframework.web.servlet.FrameworkServlet\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)  throws ServletException, IOException {   long startTime = System.currentTimeMillis();  Throwable failureCause = null;   LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();  LocaleContext localeContext = buildLocaleContext(request);   RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();  ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);   WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);  asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());   initContextHolders(request, localeContext, requestAttributes);   try { \t// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写  doService(request, response);  }  catch (ServletException | IOException ex) {  failureCause = ex;  throw ex;  }  catch (Throwable ex) {  failureCause = ex;  throw new NestedServletException(\u0026#34;Request processing failed\u0026#34;, ex);  }   finally {  resetContextHolders(request, previousLocaleContext, previousAttributes);  if (requestAttributes != null) {  requestAttributes.requestCompleted();  }  logResult(request, response, failureCause, asyncManager);  publishRequestHandledEvent(request, response, startTime, failureCause);  } } b\u0026gt;doService() 所在类：org.springframework.web.servlet.DispatcherServlet\n@Override protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {  logRequest(request);   // Keep a snapshot of the request attributes in case of an include,  // to be able to restore the original attributes after the include.  Map\u0026lt;String, Object\u0026gt; attributesSnapshot = null;  if (WebUtils.isIncludeRequest(request)) {  attributesSnapshot = new HashMap\u0026lt;\u0026gt;();  Enumeration\u0026lt;?\u0026gt; attrNames = request.getAttributeNames();  while (attrNames.hasMoreElements()) {  String attrName = (String) attrNames.nextElement();  if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {  attributesSnapshot.put(attrName, request.getAttribute(attrName));  }  }  }   // Make framework objects available to handlers and view objects.  request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());  request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);  request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);  request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());   if (this.flashMapManager != null) {  FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);  if (inputFlashMap != null) {  request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));  }  request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());  request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);  }   RequestPath requestPath = null;  if (this.parseRequestPath \u0026amp;\u0026amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) {  requestPath = ServletRequestPathUtils.parseAndCache(request);  }   try {  // 处理请求和响应  doDispatch(request, response);  }  finally {  if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {  // Restore the original attribute snapshot, in case of an include.  if (attributesSnapshot != null) {  restoreAttributesAfterInclude(request, attributesSnapshot);  }  }  if (requestPath != null) {  ServletRequestPathUtils.clearParsedRequestPath(request);  }  } } c\u0026gt;doDispatch() 所在类：org.springframework.web.servlet.DispatcherServlet\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {  HttpServletRequest processedRequest = request;  HandlerExecutionChain mappedHandler = null;  boolean multipartRequestParsed = false;   WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);   try {  ModelAndView mv = null;  Exception dispatchException = null;   try {  processedRequest = checkMultipart(request);  multipartRequestParsed = (processedRequest != request);   // Determine handler for the current request.  /* mappedHandler：调用链 包含handler、interceptorList、interceptorIndex handler：浏览器发送的请求所匹配的控制器方法 interceptorList：处理控制器方法的所有拦截器集合 interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行 */  mappedHandler = getHandler(processedRequest);  if (mappedHandler == null) {  noHandlerFound(processedRequest, response);  return;  }   // Determine handler adapter for the current request.  // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法  HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());   // Process last-modified header, if supported by the handler.  String method = request.getMethod();  boolean isGet = \u0026#34;GET\u0026#34;.equals(method);  if (isGet || \u0026#34;HEAD\u0026#34;.equals(method)) {  long lastModified = ha.getLastModified(request, mappedHandler.getHandler());  if (new ServletWebRequest(request, response).checkNotModified(lastModified) \u0026amp;\u0026amp; isGet) {  return;  }  } \t // 调用拦截器的preHandle()  if (!mappedHandler.applyPreHandle(processedRequest, response)) {  return;  }   // Actually invoke the handler.  // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象  mv = ha.handle(processedRequest, response, mappedHandler.getHandler());   if (asyncManager.isConcurrentHandlingStarted()) {  return;  }   applyDefaultViewName(processedRequest, mv);  // 调用拦截器的postHandle()  mappedHandler.applyPostHandle(processedRequest, response, mv);  }  catch (Exception ex) {  dispatchException = ex;  }  catch (Throwable err) {  // As of 4.3, we\u0026#39;re processing Errors thrown from handler methods as well,  // making them available for @ExceptionHandler methods and other scenarios.  dispatchException = new NestedServletException(\u0026#34;Handler dispatch failed\u0026#34;, err);  }  // 后续处理：处理模型数据和渲染视图  processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);  }  catch (Exception ex) {  triggerAfterCompletion(processedRequest, response, mappedHandler, ex);  }  catch (Throwable err) {  triggerAfterCompletion(processedRequest, response, mappedHandler,  new NestedServletException(\u0026#34;Handler processing failed\u0026#34;, err));  }  finally {  if (asyncManager.isConcurrentHandlingStarted()) {  // Instead of postHandle and afterCompletion  if (mappedHandler != null) {  mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);  }  }  else {  // Clean up any resources used by a multipart request.  if (multipartRequestParsed) {  cleanupMultipart(processedRequest);  }  }  } } d\u0026gt;processDispatchResult() private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,  @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,  @Nullable Exception exception) throws Exception {   boolean errorView = false;   if (exception != null) {  if (exception instanceof ModelAndViewDefiningException) {  logger.debug(\u0026#34;ModelAndViewDefiningException encountered\u0026#34;, exception);  mv = ((ModelAndViewDefiningException) exception).getModelAndView();  }  else {  Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);  mv = processHandlerException(request, response, handler, exception);  errorView = (mv != null);  }  }   // Did the handler return a view to render?  if (mv != null \u0026amp;\u0026amp; !mv.wasCleared()) {  // 处理模型数据和渲染视图  render(mv, request, response);  if (errorView) {  WebUtils.clearErrorRequestAttributes(request);  }  }  else {  if (logger.isTraceEnabled()) {  logger.trace(\u0026#34;No view rendering, null ModelAndView returned.\u0026#34;);  }  }   if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {  // Concurrent handling started during a forward  return;  }   if (mappedHandler != null) {  // Exception (if any) is already handled..  // 调用拦截器的afterCompletion()  mappedHandler.triggerAfterCompletion(request, response, null);  } } 4、SpringMVC的执行流程   用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。\n  DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：\n  a) 不存在\ni. 再判断是否配置了mvc:default-servlet-handler\nii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iU6JzFgp-1646050920658)(img/img006.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qfdefStX-1646050920658)(img/img007.png)]\niii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Uo3X7qdr-1646050920659)(img/img008.png)]\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ffuv1zYA-1646050920659)(img/img009.png)]\nb) 存在则执行下面的流程\n 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。\n  DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。\n  如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】\n  提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：\n  a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\nb) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等\nc) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\nd) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中\n Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。\n  此时将开始执行拦截器的postHandle(\u0026hellip;)方法【逆向】。\n  根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。\n  渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。\n  = null); } }\n// Did the handler return a view to render?\rif (mv != null \u0026amp;\u0026amp; !mv.wasCleared()) {\r// 处理模型数据和渲染视图\rrender(mv, request, response);\rif (errorView) {\rWebUtils.clearErrorRequestAttributes(request);\r}\r}\relse {\rif (logger.isTraceEnabled()) {\rlogger.trace(\u0026quot;No view rendering, null ModelAndView returned.\u0026quot;);\r}\r}\rif (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\r// Concurrent handling started during a forward\rreturn;\r}\rif (mappedHandler != null) {\r// Exception (if any) is already handled..\r// 调用拦截器的afterCompletion()\rmappedHandler.triggerAfterCompletion(request, response, null);\r}\r }\n\r### 4、SpringMVC的执行流程\r1) 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。\r2) DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：\ra) 不存在\ri. 再判断是否配置了mvc:default-servlet-handler\rii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\r[外链图片转存中...(img-iU6JzFgp-1646050920658)]\r[外链图片转存中...(img-qfdefStX-1646050920658)]\riii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误\r[外链图片转存中...(img-Uo3X7qdr-1646050920659)]\r[外链图片转存中...(img-ffuv1zYA-1646050920659)]\rb) 存在则执行下面的流程\r3) 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。\r4) DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。\r5) 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】\r6) 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：\ra) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\rb) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等\rc) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\rd) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中\r7) Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。\r8) 此时将开始执行拦截器的postHandle(...)方法【逆向】。\r9) 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。\r10) 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。\r11) 将渲染结果返回给客户端。  搞定！\n人生无常，大肠包小肠！\n继续学习吧！\n","id":6,"section":"posts","summary":"","tags":["Spring Mvc"],"title":"Spring Mvc","uri":"https://gb.ytte.top/2022/04/05/spring-mvc/","year":"2022"},{"content":"总结 查询 部门薪水   部门里最高薪水\nIN临时表\n  部门里三高薪水\n关联子查询\n  ==尽量不要==使用关联子查询，复杂度O(n²)。\n题目  2022-3-31\n部门里最高薪水 这里也可以使用关联子查询，但是复杂度O(n²)。\nCreate table If Not Exists Employee (id int, name varchar(255), salary int, departmentId int); Create table If Not Exists Department (id int, name varchar(255)); Truncate table Employee; insert into Employee (id, name, salary, departmentId) values (\u0026#39;1\u0026#39;, \u0026#39;Joe\u0026#39;, \u0026#39;85000\u0026#39;, \u0026#39;1\u0026#39;); insert into Employee (id, name, salary, departmentId) values (\u0026#39;2\u0026#39;, \u0026#39;Henry\u0026#39;, \u0026#39;80000\u0026#39;, \u0026#39;2\u0026#39;); insert into Employee (id, name, salary, departmentId) values (\u0026#39;3\u0026#39;, \u0026#39;Sam\u0026#39;, \u0026#39;60000\u0026#39;, \u0026#39;2\u0026#39;); insert into Employee (id, name, salary, departmentId) values (\u0026#39;4\u0026#39;, \u0026#39;Max\u0026#39;, \u0026#39;90000\u0026#39;, \u0026#39;1\u0026#39;); insert into Employee (id, name, salary, departmentId) values (\u0026#39;5\u0026#39;, \u0026#39;Janet\u0026#39;, \u0026#39;69000\u0026#39;, \u0026#39;1\u0026#39;); insert into Employee (id, name, salary, departmentId) values (\u0026#39;6\u0026#39;, \u0026#39;Randy\u0026#39;, \u0026#39;85000\u0026#39;, \u0026#39;1\u0026#39;); insert into Employee (id, name, salary, departmentId) values (\u0026#39;7\u0026#39;, \u0026#39;Will\u0026#39;, \u0026#39;70000\u0026#39;, \u0026#39;1\u0026#39;); Truncate table Department; insert into Department (id, name) values (\u0026#39;1\u0026#39;, \u0026#39;IT\u0026#39;); insert into Department (id, name) values (\u0026#39;2\u0026#39;, \u0026#39;Sales\u0026#39;); 因为 Employee 表包含 Salary 和 DepartmentId 字段，我们可以以此在部门内查询最高工资。\n\tSELECT \tdepartmentid, \tMAX( salary ) \tFROM \temployee \tGROUP BY \tdepartmentid 注意：有可能有多个员工同时拥有最高工资，所以最好在这个查询中不包含雇员名字的信息。\n| DepartmentId | MAX(Salary) | |--------------|-------------| | 1 | 90000 | | 2 | 80000 | 然后，我们可以把表 Employee 和 Department 连接，再在这张临时表里用 IN 语句查询部门名字和工资的关系。（打破之前的思想：原本以为只能单字段IN，实际可以多字段IN）\nSELECT \td1.NAME AS Department, \te1.NAME Employee, \te1.salary Salary FROM \tEmployee e1 \tJOIN Department d1 ON e1.departmentId = d1.id WHERE \t( e1.departmentid, e1.salary ) IN (  SELECT  departmentid,  MAX( salary )  FROM  employee  GROUP BY  departmentid \t) 部门里三高薪水 Create table If Not Exists Employee (id int, name varchar(255), salary int, departmentId int); Create table If Not Exists Department (id int, name varchar(255)); Truncate table Employee; insert into Employee (id, name, salary, departmentId) values (\u0026#39;1\u0026#39;, \u0026#39;Joe\u0026#39;, \u0026#39;85000\u0026#39;, \u0026#39;1\u0026#39;); insert into Employee (id, name, salary, departmentId) values (\u0026#39;2\u0026#39;, \u0026#39;Henry\u0026#39;, \u0026#39;80000\u0026#39;, \u0026#39;2\u0026#39;); insert into Employee (id, name, salary, departmentId) values (\u0026#39;3\u0026#39;, \u0026#39;Sam\u0026#39;, \u0026#39;60000\u0026#39;, \u0026#39;2\u0026#39;); insert into Employee (id, name, salary, departmentId) values (\u0026#39;4\u0026#39;, \u0026#39;Max\u0026#39;, \u0026#39;90000\u0026#39;, \u0026#39;1\u0026#39;); insert into Employee (id, name, salary, departmentId) values (\u0026#39;5\u0026#39;, \u0026#39;Janet\u0026#39;, \u0026#39;69000\u0026#39;, \u0026#39;1\u0026#39;); insert into Employee (id, name, salary, departmentId) values (\u0026#39;6\u0026#39;, \u0026#39;Randy\u0026#39;, \u0026#39;85000\u0026#39;, \u0026#39;1\u0026#39;); insert into Employee (id, name, salary, departmentId) values (\u0026#39;7\u0026#39;, \u0026#39;Will\u0026#39;, \u0026#39;70000\u0026#39;, \u0026#39;1\u0026#39;); Truncate table Department; insert into Department (id, name) values (\u0026#39;1\u0026#39;, \u0026#39;IT\u0026#39;); insert into Department (id, name) values (\u0026#39;2\u0026#39;, \u0026#39;Sales\u0026#39;);  方法一：（关联子查询）  公司里前 3 高的薪水意味着有不超过 3 个工资比这些值大。\nselect e1.Name as \u0026#39;Employee\u0026#39;, e1.Salary from Employee e1 where 3 \u0026gt; (  select count(distinct e2.Salary)  from Employee e2  where e2.Salary \u0026gt; e1.Salary ); 在这个代码里，我们统计了有多少人的工资比 e1.Salary 高，所以样例的输出应该如下所示。\n| Employee | Salary | |----------|--------| | Henry | 80000 | | Max | 90000 | | Randy | 85000 | 然后，我们需要把表 Employee 和表 Department 连接来获得部门信息。\nSELECT  d.Name AS \u0026#39;Department\u0026#39;, e1.Name AS \u0026#39;Employee\u0026#39;, e1.Salary FROM  Employee e1  JOIN  Department d ON e1.DepartmentId = d.Id WHERE  3 \u0026gt; (SELECT  COUNT(DISTINCT e2.Salary)  FROM  Employee e2  WHERE  e2.Salary \u0026gt; e1.Salary  AND e1.DepartmentId = e2.DepartmentId  ) ;   方法二：使用mysql8中的DENSE_RANK()函数，按DepartmentId字段隔离排序Salary。\nDENSE_RANK() OVER ( PARTITION BY DepartmentId ORDER BY Salary DESC ) 效果如下：\n+----------------+-------------+--------+------------+ | sales_employee | fiscal_year | sale | sales_rank | +----------------+-------------+--------+------------+ | John | 2016 | 200.00 | 1 | | Alice | 2016 | 150.00 | 2 | | Bob | 2016 | 100.00 | 3 | | Bob | 2017 | 150.00 | 1 | | John | 2017 | 150.00 | 1 | | Alice | 2017 | 100.00 | 2 | | John | 2018 | 250.00 | 1 | | Alice | 2018 | 200.00 | 2 | | Bob | 2018 | 200.00 | 2 | +----------------+-------------+--------+------------+ 9 rows in set (0.01 sec)   SELECT B.Name AS Department, A.Name AS Employee, A.Salary FROM (SELECT DENSE_RANK() OVER (partition by DepartmentId order by Salary desc) AS ranking,DepartmentId,Name,Salary  FROM Employee) AS A JOIN Department AS B ON A.DepartmentId=B.id WHERE A.ranking\u0026lt;=3  搞定！\n人生无常，大肠包小肠！\n继续学习吧！\n","id":7,"section":"posts","summary":"","tags":["mysql","题目"],"title":"Mysql Exercises and Summaries","uri":"https://gb.ytte.top/2022/03/31/mysql-exercises-and-summaries/","year":"2022"},{"content":" 搞定！\n人生无常，大肠包小肠！\n继续学习吧！\n","id":8,"section":"posts","summary":"","tags":["mysql"],"title":"MySql基础","uri":"https://gb.ytte.top/2022/03/24/mysql%E5%9F%BA%E7%A1%80/","year":"2022"},{"content":"顺序io随机io\n回表查询\nMySQL高级 sql数据：\n  course表\n  8\nCREATE TABLE `course` (  `id` int NOT NULL AUTO_INCREMENT,  `course_id` int NOT NULL,  `course_name` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE,  KEY `idx` (`id`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=201 DEFAULT CHARSET=utf8mb3;   5.7\nCREATE TABLE `course` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `course_id` int(11) NOT NULL,  `course_name` varchar(40) DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE,  KEY `idx` (`id`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=201 DEFAULT CHARSET=utf8;     student_info表\n  8\nCREATE TABLE `student_info` (  `id` int NOT NULL AUTO_INCREMENT,  `student_id` int NOT NULL,  `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,  `course_id` int NOT NULL,  `class_id` int DEFAULT NULL,  `create_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,  PRIMARY KEY (`id`) USING BTREE,  KEY `idx_sid` (`student_id`),  KEY `idx_cre_time` (`create_time`) ) ENGINE=InnoDB AUTO_INCREMENT=1000001 DEFAULT CHARSET=utf8mb3;   5.7\nCREATE TABLE `student_info` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `student_id` int(11) NOT NULL,  `name` varchar(20) DEFAULT NULL,  `course_id` int(11) NOT NULL,  `class_id` int(11) DEFAULT NULL,  `create_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,  PRIMARY KEY (`id`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=1000001 DEFAULT CHARSET=utf8;     存储过程，为course增加100条数据；为student_info 增加100w条数据。\nset global log_bin_trust_function_creators=TRUE;  DELIMITER // CREATE FUNCTION rand_string ( n INT ) RETURNS VARCHAR ( 255 ) BEGIN \tDECLARE \tchars_str VARCHAR ( 100 ) DEFAULT \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ\u0026#39;; \tDECLARE \treturn_str VARCHAR ( 255 ) DEFAULT \u0026#39;\u0026#39;; \tDECLARE \ti INT DEFAULT 0; \tWHILE \ti \u0026lt; n DO \tSET return_str = CONCAT( \treturn_str, \tSUBSTRING( chars_str, FLOOR( 1+RAND ()* 52 ), 1 )); \tSET i = i + 1;  \tEND WHILE; \tRETURN return_str;  END // DELIMITER;    DELIMITER // CREATE FUNCTION rand_num ( from_num INT, to_num INT ) RETURNS INT ( 11 ) BEGIN \tDECLARE \ti INT DEFAULT 0;  \tSET i = FLOOR( \tfrom_num + RAND()*( \tto_num - from_num + 1 \t)); \tRETURN i;  END // DELIMITER;  show variables like \u0026#39;log_bin_trust_function_creators\u0026#39;; set global log_bin_trust_function_creators=1;  DELIMITER // CREATE PROCEDURE insert_course ( max_num INT ) BEGIN \tDECLARE \ti INT DEFAULT 0;  \tSET autocommit = 0; \tREPEAT  \tSET i = i + 1; \tINSERT INTO course ( course_id, course_name ) \tVALUES \t( \trand_num ( 10000, 10100 ), \trand_string ( 6 )); \tUNTIL i = max_num \tEND REPEAT; \tCOMMIT;  END // DELIMITER;   DELIMITER // CREATE PROCEDURE insert_stu ( max_num INT ) BEGIN \tDECLARE \ti INT DEFAULT 0;  \tSET autocommit = 0; \tREPEAT  \tSET i = i + 1; \tINSERT INTO student_info ( course_id, class_id, student_id, NAME ) \tVALUES \t( \trand_num ( 10000, 10100 ), \trand_num ( 10000, 10200 ), \trand_num ( 1, 200000 ), \trand_string ( 6 )); \tUNTIL i = max_num \tEND REPEAT; \tCOMMIT;  END // DELIMITER;  CALL insert_course(100);  CALL insert_stu(1000000);   索引的创建与设计原则 索引的必要使用场景 字段的数值有唯一性的限制 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。\n说明：唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。\n频繁作为 WHERE 查询条件的字段 某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。\n比如查询 student_id =144324的时候\nSELECT course_id ,class_id, `name`,create_time,student_id FROM student_info WHERE student_id =144324   在student_id不加索引的情况下，100w条数据，耗时为350ms左右，即在百毫秒级\nALTER TABLE student_info ADD INDEX idx_sid(student_id)  SHOW INDEX FROM student_info #查看是否添加成功   在添加索引的情况下，耗时为22ms，降了一个数量级，这是很客观的。\n   经常 GROUP BY 和 ORDER BY 的列 索引就是让数据按照某种顺序进行存储或检索，因此当我们使用GROUP BY对数据进行分组查询，或者使用ORDER BY对数据进行排序的时候，就需要对分组或者排序的字段进行索引，从而减少排序的时间。如果待排序的列有多个，那么可以在这些列上建立组合索引。\nGROUP BY eg：在100w条数据中，按照student_id对学生选修课程进行分组，显示不同的student_id和课程数量，显示100个。\nSELECT student_id ,COUNT(*) AS num FROM student_info GROUP BY student_id LIMIT 100  DROP INDEX idx_sid ON student_info SHOW INDEX FROM student_info  在不加索引的情况下，耗时850毫秒。 在加索引的情况下（这里使用的是2）当中的idx_sid索引），耗时21毫秒。  ORDER BY ORDER BY单独使用的情况与GROUP BY差不多\nORDER BY和GROUP BY同时使用的情况 ==由于GROUP BY先执行，且GROUP BY为先排序再分组，所以主要耗时就集中在GROUP BY上。==\n使用以下三种情况来观察不同索引状况下，sql执行的速度差异\n 三种情况：  ​\t①. student_id和create_time分别建立索引\n​\t②. student_id和create_time建立联合索引，且student_id在前\n​\t③. student_id和create_time建立联合索引，且create_time在前\nSELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info GROUP BY\tstudent_id ORDER BY\tcreate_time desc LIMIT 100 不加除主键索引以外的其他索引的情况下，耗时约==0.8~1s==\n 两种版本：  ​\t①. MySQL 5.7.5及以上功能依赖检测功能\n​\t②. MySQL 5.7.5以下无依赖检测功能\n执行上方代码后MySQL 5.7.5及以上会报错\nsql_mode=only_full_group_by #出现问题 MySQL 5.7.5及以上由于sql_mode=only_full_group_by是默认开启依赖检测功能，所以HAVING条件或ORDER BY列表的查询引用在GROUP BY子句中。 简单来说就是：输出的结果是叫target list，就是select后面跟着的字段，还有一个地方group by column，就是group by后面跟着的字段。由于开启ONLY_FULL_GROUP_BY的设置，如果一个字段没有在target list和group by字段中同时出现，或者是聚合函数的值的话，那么这条sql查询是被mysql认为非法的，会报错误。\n但是如果同时GROUP BY student_id，create_time 这两个字段，就失去了本例的作用。所以需要MySQL 5.7.5及以上的需要关闭依赖检测功能\n具体解析链接====》文档——石墨\nselect @@global.sql_mode #查看sql_mode详细  set @@global.sql_mode =\u0026#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\u0026#39;; #去掉ONLY_FULL_GROUP_BY，重新设置值，对于新建的数据库有效 8.0中还要去掉NO_AUTO_CREATE_USER  set global sql_mode=\u0026#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\u0026#39;; #对于已存在的数据库，则需要在对应的数据下执行 继续测试\n  添加单列student_id索引和create_time索引\n​\t5.7中：\n耗时6s左右，添加索引就是将这些时间提前消耗掉，让客户查询的时候减少查询时间。\nALTER TABLE student_info ADD INDEX idx_sid(student_id);  ALTER TABLE student_info ADD INDEX idx_cre_time(create_time DESC); 这里 EXPLAIN 后会发现只使用了student_id 的索引idx_sid（单列索引的情况，只使用语句执行过程第一个索引）所以这里只使用了索引idx_sid，而idx_cre_time压根没用到。\nSHOW INDEX FROM student_info  EXPLAIN  SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info GROUP BY\tstudent_id ORDER BY\tcreate_time DESC LIMIT 100; 各自单列索引的情况下，耗时大约1.5s（上面不加索引的情况下耗时1s）\n​\t8.0中\n==todo 不明原因，未得到解决，上述方式在5.7中大约需要1.5s左右，而在8.0中需要几分钟的时间。==\n  联合索引的情况① ：\n先删除除主键外其他的单列索引\nidx_sid_cre_time(student_id,create_time)，student_id在前\n​\t5.7：\nALTER TABLE student_info ADD INDEX idx_sid_cre_time(student_id,create_time);  SHOW INDEX FROM student_info;  EXPLAIN  SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info GROUP BY\tstudent_id ORDER BY\tcreate_time DESC LIMIT 100; 耗时约==300ms==左右（未加索引1s左右，单列索引1.5s左右）\n8.0：\nDROP INDEX idx_sid ON student_info ; DROP INDEX idx_cre_time ON student_info; DROP INDEX idx_sid_cre_time ON student_info;  ALTER TABLE student_info ADD INDEX idx_sid_cre_time(student_id,create_time DESC);  SHOW INDEX FROM student_info;  EXPLAIN  SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info GROUP BY\tstudent_id ORDER BY\tcreate_time DESC LIMIT 100;   索引不加DESC时，耗时约==800ms==左右（不加索引1s左右，单列索引几分钟）\n  索引加DESC时，耗时约==300ms==左右（不加索引1s左右，单列索引几分钟）\n    联合索引的情况② ：\nidx_cre_sid_time(create_time,student_id)，create_time在前\n在语句执行中，先进行group by 所以此时如果存在idx_sid(student_id)的话，会优先使用group by student_id的student_id索引（idx_sid），这样就变成了使用单列索引，联合索引idx_sid_cre_time就不起作用了。\n如果不存在idx_sid，只有联合索引idx_cre_sid_time：\n​ 5.7：\nDROP INDEX idx_sid ON student_info ; DROP INDEX idx_cre_time ON student_info; DROP INDEX idx_sid_cre_time ON student_info;  ALTER TABLE student_info ADD INDEX idx_cre_sid_time(create_time,student_id);  SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info GROUP BY\tstudent_id ORDER BY\tcreate_time DESC LIMIT 100; 耗时约==800ms左右== （未加索引1s左右，单列索引1.5s左右，idx_sid_cre_time索引耗时约300ms）\n​ 8.0 ：\nDROP INDEX idx_sid ON student_info ; DROP INDEX idx_cre_time ON student_info; DROP INDEX idx_sid_cre_time ON student_info; DROP INDEX idx_cre_sid_time ON student_info;  ALTER TABLE student_info ADD INDEX idx_cre_sid_time(create_time DESC,student_id);  SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info GROUP BY\tstudent_id ORDER BY\tcreate_time DESC LIMIT 100;   索引不加DESC时，耗时约==1s==左右（不加索引1s左右，单列索引几分钟，idx_sid_cre_time索引800ms左右）\n  索引加DESC时，耗时约==1s==左右（不加索引1s左右，单列索引几分钟，idx_sid_cre_time索引300ms左右）\n    UPDATE、DELETE 的 WHERE 条件列 对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。\n原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。\nDISTINCT 字段需要创建索引 有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。\n比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行\nSQL 语句：\nSELECT DISTINCT(student_id) FROM `student_info`; 运行结果（600637 条记录，运行时间 0.683s ）：\n如果我们对 student_id 创建索引，再执行 SQL 语句：\nSELECT DISTINCT(student_id) FROM `student_info`; 运行结果（600637 条记录，运行时间 0.010s ）：\nSQL 查询效率有了提升，同时显示出来的 student_id 还是按照 递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。\n多表 JOIN 连接操作时，创建索引注意事项 首先， ==连接表的数量尽量不要超过 3 张==，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。\n其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。\n最后，==类似字符串和int比较时，会存在隐式转换，即使用了函数，一旦使用了函数就会让索引失效。 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。==比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。\n举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：\nSELECT course_id, name, student_info.student_id, course_name FROM student_info JOIN course ON student_info.course_id = course.course_id WHERE name = \u0026#39;462eed7ac6e791292a79\u0026#39;; 运行结果（1 条数据，运行时间 0.189s ）：\n这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。\n使用列的类型小的创建索引 使用字符串前缀创建索引 创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引\ncreate table shop(address varchar(120) not null);  alter table shop add index(address(12)); 问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字\n段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？\n先看一下字段在全部数据中的选择度：\nselect count(distinct address) / count(*) from shop; 通过不同长度去计算，与全表的选择性对比：\n公式：\ncount(distinct left(列名, 索引长度))/count(*) 例如：\nselect count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度 count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度 count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度 count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度 from shop; 引申另一个问题：索引列前缀对排序的影响\n拓展：Alibaba《Java开发手册》\n==在 varchar 字段上建立索引时，必须指定索引长度，根据实际文本区分度决定索引长度。==\n说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达 90% 以上 ，可以使用\n count(distinct left(列名, 索引长度))/count(*)的区分度来确定。\n区分度高(散列性高)的列适合作为索引 使用最频繁的列放到联合索引的左侧 在多个字段都要创建索引的情况下，联合索引优于单值索引 限制索引的数目 哪些情况不适合创建索引  WHERE条件（包括GROUP BY、ORDER BY)里用不到的字段不需要创建索引 数据量小的表最好不要使用索引 有大量重复数据的列上不要建立索引  比如性别。   避免对经常更新的表创建过多的索引 不建议用无序的值作为索引  例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。   删除不再使用或者很少使用的索引 不要定义冗余或重复的索引  性能分析工具的使用 数据库服务器的优化步骤 视频 p134————尚硅谷\n一般数据库遇到问题需要调优的时候需要经历一下几个过程。\n整个流程划分成观察（show status）和行动（Action）字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。如图：\nmysql优化的效果是随着成本提高而降低的：\n查看系统性能参数 视频 p134 ———— 尚硅谷\n在MySQL中，可以使用 SHOW STATUS 语句查询一些MySQL数据库服务器的 ==性能参数== 、 ==执行频率== 。\n语法如下：\nSHOW [GLOBAL|SESSION] STATUS LIKE \u0026#39;参数\u0026#39;;    参数 意译     Connections 连接MySQL服务器的次数   Uptime MySQL服务器的上线时间   Slow_queries 慢查询的次数   Innodb_rows_read Select查询返回的行数   Innodb_rows_inserted 执行INSERT操作插入的行数   Innodb_rows_updated 执行UPDATE操作更新的行数   Innodb_rows_deleted 执行DELETE操作删除的行数   Com_select 查询操作的次数   Com_insert 插入操作的次数。对于批量插入的 INSERT 操作，只累加一次   Com_update 更新操作的次数   Com_delete 删除操作的次数    统计SQL的查询成本 视频 p134 ———— 尚硅谷\nlast_query_cost.\n需要在原始命令行中输入查询，Navicat中查询的last_query_cost不正确\n如果我们想要查询 id=900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：\n耗时在0.01s左右\nSELECT student_id, class_id, NAME, create_time FROM student_info WHERE id = 900001; 然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：\n如果我们想要查询 id 在 900001 到 9000100 之间的学生记录：\n耗时在0.04s左右\nSELECT student_id, class_id, NAME, create_time FROM student_info WHERE id BETWEEN 900001 AND 901000; 然后再看下查询优化器的成本，这时我们大概需要进行 400 个页的查询。\n你能看到页的数量是刚才的 400 倍，但是查询的效率并没有明显的数量级变化，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了==顺序读取==的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量（last_query_cost）增加了不少 ，但是通过缓冲池的机制，并 没有增加多少查询时间 。\n**使用场景：**它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。\n定位执行慢的SQL：慢查询日志 视频 p135————尚硅谷\nMySQL的慢查询日志，用来记录在MySQL中响==应时间超过阀值==的语句，具体指运行时间超过==long_query._time==值的SQL,则会被记录到慢查询日志中。long_query._time的默认值为==10==，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。\n它的主要作用是，帮助我们发现那些执行时间特别长的SQL查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合explain进行全面分析。\n默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。\n慢查询日志支持将日志记录写入文件。\nmyisam中会自动存储一个所有数据的数量的变量，所以与innodb相比，count(*)执行的速度会快于innodb。\n补充说明： 除了上述变量，控制慢查询日志的还有一个系统变量：min_examined_row_limit。这个变量的意思是，查询 扫描过的最少记录数。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询 扫描过的记录数大于等于这个变量的值，并且查询执行时间超过long_query_.time的值，那么，这个查询就 被记录到慢查询日志中；反之，则不被记录到慢查询日志中。\n这个值默认是0。与long-query_.time=10合在一起，表示只要查询的执行时间超过10秒钟，哪怕一个记录也 没有扫描过，都要被记录到慢查询日志中。你也可以根据需要，通过修改“y.ii”文件，来修改查询时长，或 者通过SET指令，用SQL语句修改“min_examined_.row_limit\u0026quot;的值。\n日常开发需注意的结论： ①converting HEAP to MyISAM:查询结果太大，内存不够，数据往磁盘上搬了。 ②Creating tmp table：创建临时表。先拷贝数据到l临时表，用完后再删除临时表。 ③Copying to tmp table on disk：把内存中临时表复制到磁盘上，警惕！ ④1 ocked。 如果在show profilei诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。 注意： 不过SHOW PROFILE命令将被弃用，我们可以从information_schema中的profiling数据表进行查看。\n查看SQL执行成本：show profile 分析查询语句：explain 概述 定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。DESCRIBE语句 的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。 MySQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户 端请求的Qury提供它认为最优的执行计划（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分 最耗费时间)。\n这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来 具体执行查询等等。MySQL为我们提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划，大家看懂 EXPLAIN语句的各个输出项，可以有针对性的提升我们查询语句的性能。\n官网介绍\nhttps://dev.mysql.com/doc/refman/5.7/en/explain-output.html\nhttps://dev.mysql.com/doc/refman/8.0/en/explain-output.html\n版本情况\n  MySQL 5.6.3以前只能 EXPLAIN SELECT ；MYSQL 5.6.3以后就可以 EXPLAIN SELECT，UPDATE， DELETE\n  在5.7以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示filtered 需要使用 explain extended 命令。在5.7版本后，默认explain直接显示partitions和 filtered中的信息\n  基本语法 EXPLAIN 或 DESCRIBE语句的语法形式如下：\nEXPLAIN SELECT select_options #或者 DESCRIBE SELECT select_options 如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：\nmysql\u0026gt; EXPLAIN SELECT 1; EXPLAIN 语句输出的各个列的作用如下：\n数据准备 建表 CREATE TABLE s1 ( \tid INT AUTO_INCREMENT, \tkey1 VARCHAR ( 100 ), \tkey2 INT, \tkey3 VARCHAR ( 100 ), \tkey_part1 VARCHAR ( 100 ), \tkey_part2 VARCHAR ( 100 ), \tkey_part3 VARCHAR ( 100 ), \tcommon_field VARCHAR ( 100 ), \tPRIMARY KEY ( id ), \tINDEX idx_key1 ( key1 ), \tUNIQUE INDEX idx_key2 ( key2 ), \tINDEX idx_key3 ( key3 ), \tINDEX idx_key_part ( key_part1, key_part2, key_part3 ) ) ENGINE = INNODB CHARSET = utf8;  CREATE TABLE s2 ( \tid INT AUTO_INCREMENT, \tkey1 VARCHAR ( 100 ), \tkey2 INT, \tkey3 VARCHAR ( 100 ), \tkey_part1 VARCHAR ( 100 ), \tkey_part2 VARCHAR ( 100 ), \tkey_part3 VARCHAR ( 100 ), \tcommon_field VARCHAR ( 100 ), \tPRIMARY KEY ( id ), \tINDEX idx_key1 ( key1 ), \tUNIQUE INDEX idx_key2 ( key2 ), \tINDEX idx_key3 ( key3 ), \tINDEX idx_key_part ( key_part1, key_part2, key_part3 ) ) ENGINE = INNODB CHARSET = utf8; 设置参数 log_bin_trust_function_creators 创建函数，假如报错，需开启如下命令：允许创建函数设置：\nset global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。 创建函数 DELIMITER // CREATE FUNCTION rand_string1 ( n INT ) RETURNS VARCHAR ( 255 ) BEGIN \tDECLARE \tchars_str VARCHAR ( 100 ) DEFAULT \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ\u0026#39;; \tDECLARE \treturn_str VARCHAR ( 255 ) DEFAULT \u0026#39;\u0026#39;; \tDECLARE \ti INT DEFAULT 0; \tWHILE \ti \u0026lt; n DO \t\tSET return_str = CONCAT( \treturn_str, \tSUBSTRING( chars_str, FLOOR( 1+RAND ()* 52 ), 1 )); \t\tSET i = i + 1; \t\tEND WHILE; \tRETURN return_str; \tEND // DELIMITER; 创建存储过程 创建往s1表中插入数据的存储过程：\nDELIMITER // CREATE PROCEDURE insert_s1 ( \tIN min_num INT ( 10 ), \tIN max_num INT ( 10 )) BEGIN \tDECLARE \ti INT DEFAULT 0; \t\tSET autocommit = 0; \tREPEAT \t\tSET i = i + 1; \tINSERT INTO s1 \tVALUES \t( \t( min_num + i ), \trand_string1 ( 6 ), \t( min_num + 30 * i + 5 ), \trand_string1 ( 6 ), \trand_string1 ( 10 ), \trand_string1 ( 5 ), \trand_string1 ( 10 ), \trand_string1 ( 10 )); \tUNTIL i = max_num \tEND REPEAT; \tCOMMIT; \tEND // DELIMITER; 创建往s2表中插入数据的存储过程：\nDELIMITER // CREATE PROCEDURE insert_s2 ( \tIN min_num INT ( 10 ), \tIN max_num INT ( 10 )) BEGIN \tDECLARE \ti INT DEFAULT 0; \t\tSET autocommit = 0; \tREPEAT \t\tSET i = i + 1; \tINSERT INTO s2 \tVALUES \t( \t( min_num + i ), \trand_string1 ( 6 ), \t( min_num + 30 * i + 5 ), \trand_string1 ( 6 ), \trand_string1 ( 10 ), \trand_string1 ( 5 ), \trand_string1 ( 10 ), \trand_string1 ( 10 )); \tUNTIL i = max_num \tEND REPEAT; \tCOMMIT; \tEND // DELIMITER; 调用存储过程 CALL insert_s1(10001,10000); CALL insert_s2(10001,10000); 即可完成s1与s2中1w条数据的插入\nEXPLAIN各列作用  table：表名 id：在一个大的查询语句中每个SELECT关键字都对应一个唯一的id select_type：查询的类型 partition(略)：匹配的分区信息 type：针对单表的访问方法 possible_keys和key：可能用到的索引 和 实际上使用的索引 key_len：实际使用到的索引长度(即：字节数) ref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息。 rows：预估的需要读取的记录条数 filtered: 某个表经过搜索条件过滤后剩余记录条数的百分比 Extra:一些额外的信息（更准确的理解MySQL到底将如何执行给定的查询语句）  table #1. table：表名 #查询的每一行记录都对应着一个单表 EXPLAIN SELECT * FROM s1;  #s1:驱动表 s2:被驱动表 （mysql会根据优化器优化，不一定s1:驱动表 s2:被驱动表，有可能反过来） EXPLAIN SELECT * FROM s1 INNER JOIN s2; id #2. id：在一个大的查询语句中每个SELECT关键字都对应一个唯一的id  SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;;   SELECT * FROM s1 INNER JOIN s2  ON s1.key1 = s2.key1  WHERE s1.common_field = \u0026#39;a\u0026#39;;   SELECT * FROM s1  WHERE key1 IN (SELECT key3 FROM s2);   SELECT * FROM s1 UNION SELECT * FROM s2;   EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;;   EXPLAIN SELECT * FROM s1 INNER JOIN s2;   EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = \u0026#39;a\u0026#39;;   ######查询优化器可能对涉及子查询的查询语句进行重写,转变为多表查询的操作########  # 子查询的复杂度是n方，多表查询是n+n，所以优化器将能优化成多表查询的子查询给优化了，  # 所以这里查询到的id只有1，而不是几个select几个不同的id  EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = \u0026#39;a\u0026#39;);   #Union去重 union需要建立零时表去组合去重工作，  #所以会多出一行id为空table为\u0026lt;union1,2\u0026gt; select_type为UNION RESULT------------------------------  EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;  #UNION ALL不会创建零时表  EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2; id如果相同，可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行\n关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好\nselect_type #3. select_type：SELECT关键字对应的那个查询的类型,确定小查询在整个大查询中扮演了一个什么角色   # 查询语句中不包含`UNION`或者子查询的查询都算作是`SIMPLE`类型---------------------------  EXPLAIN SELECT * FROM s1;    #连接查询也算是`SIMPLE`类型--------------------------------------------------------  EXPLAIN SELECT * FROM s1 INNER JOIN s2;    #对于包含`UNION`或者`UNION ALL`或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个  #查询的`select_type`值就是`PRIMARY`-----------------------------------------------    #对于包含`UNION`或者`UNION ALL`的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询  #以外，其余的小查询的`select_type`值就是`UNION`--------------------------------------   #`MySQL`选择使用临时表来完成`UNION`查询的去重工作，针对该临时表的查询的`select_type`就是  #`UNION RESULT`-----------------------------------------------------------------  EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;   EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;   #子查询：-------------------------------------------------------------------------  #如果包含子查询的查询语句不能够转为对应的`semi-join`的形式（子查询会默认转化为多表连接的方式，  #但也有不能转化的情况），并且该子查询是不相关子查询。  # in 在非相关子查询中会被优化器转变成多表连接查询，降低复杂度；  #如下方所说在相关子查询中`select_type`就是`DEPENDENT SUBQUERY`，这时候in会被转变为Exist。  #该子查询的第一个`SELECT`关键字代表的那个查询的`select_type`就是`SUBQUERY`  EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = \u0026#39;a\u0026#39;;    #如果包含子查询的查询语句不能够转为对应的`semi-join`的形式，并且该子查询是相关子查询，  #则该子查询的第一个`SELECT`关键字代表的那个查询的`select_type`就是`DEPENDENT SUBQUERY`  EXPLAIN SELECT * FROM s1  WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = \u0026#39;a\u0026#39;;  #注意的是，select_type为`DEPENDENT SUBQUERY`的查询可能会被执行多次。--------------------    #在包含`UNION`或者`UNION ALL`的大查询中，如果各个小查询都依赖于外层查询的话，那除了  #最左边的那个小查询之外，其余的小查询的`select_type`的值就是`DEPENDENT UNION`。  EXPLAIN SELECT * FROM s1  WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = \u0026#39;a\u0026#39; UNION SELECT key1 FROM s1 WHERE key1 = \u0026#39;b\u0026#39;);    #对于包含`派生表`的查询，该派生表对应的子查询的`select_type`就是`DERIVED` （从新生成的表中获取数据）  EXPLAIN SELECT *  FROM (SELECT key1, COUNT(*) AS c FROM s1 GROUP BY key1) AS derived_s1 WHERE c \u0026gt; 1;    #当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，  #该子查询对应的`select_type`属性就是`MATERIALIZED`  EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2); #子查询被转为了物化表 partition(略) type system ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL\n # 5. type：针对单表的访问方法   #当表中`只有一条记录`并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，  #那么对该表的访问方法就是`system`。  CREATE TABLE t(i INT) ENGINE=MYISAM;  INSERT INTO t VALUES(1);   EXPLAIN SELECT * FROM t;   #换成InnoDB  CREATE TABLE tt(i INT) ENGINE=INNODB;  INSERT INTO tt VALUES(1);  EXPLAIN SELECT * FROM tt;    #当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是`const`  EXPLAIN SELECT * FROM s1 WHERE id = 10005;   #表中key是有索引的，但是这里查询到的是ALL没有索引的情况，原因是，key3是varchar类型，我们给的值是  #int类型，所以会进行隐式转换，这就会用到函数，一用到函数，索引就会失效，所以显示的为ALL  EXPLAIN SELECT * FROM s1 WHERE key3 = 10066;    #在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的  #（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则  #对该被驱动表的访问方法就是`eq_ref`  EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;    #当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是`ref`  EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;;    #当对普通二级索引进行等值匹配查询，该索引列的值也可以是`NULL`值时，那么对该表的访问方法  #就可能是`ref_or_null`  EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39; OR key1 IS NULL;    #单表访问方法时在某些场景下可以使用`Intersection`、`Union`、  #`Sort-Union`这三种索引合并的方式来执行查询  #二者都是单列索引，默认情况下式使用一个索引，如果是取并集，就会将两个索引合并，index_merge  EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39; OR key3 = \u0026#39;a\u0026#39;;    #`unique_subquery`是针对在一些包含`IN`子查询的查询语句中，如果查询优化器决定将`IN`子查询  #转换为`EXISTS`子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的`type`  #列的值就是`unique_subquery`  EXPLAIN SELECT * FROM s1  WHERE key2 IN (SELECT id FROM s2 WHERE s1.key1 = s2.key1) OR key3 = \u0026#39;a\u0026#39;;    #如果使用索引获取某些`范围区间`的记录，那么就可能使用到`range`访问方法  EXPLAIN SELECT * FROM s1 WHERE key1 IN (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;);   #同上  EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;a\u0026#39; AND key1 \u0026lt; \u0026#39;b\u0026#39;;    #当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是`index`  EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = \u0026#39;a\u0026#39;;    #最熟悉的全表扫描  EXPLAIN SELECT * FROM s1; 总结：\n结果值从最好到最坏依次是：==system \u0026gt; const \u0026gt; eq_ref \u0026gt; ref== \u0026gt; fulltext \u0026gt; ref_or_null \u0026gt; index_merge \u0026gt;unique_subquery \u0026gt; index_subquery \u0026gt; ==range \u0026gt; index \u0026gt; ALL== 其中比较重要的几个提取出来。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴开发手册要求）\npossible_keys和key #6. possible_keys和key：可能用到的索引 和 实际上使用的索引   EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39; AND key3 = \u0026#39;a\u0026#39;;  key_len #7. key_len：实际使用到的索引长度(即：字节数) # 帮你检查`是否充分的利用上了索引`，`值越大越好`,主要针对于联合索引，有一定的参考意义。  EXPLAIN SELECT * FROM s1 WHERE id = 10005;    EXPLAIN SELECT * FROM s1 WHERE key2 = 10126;  # varchar 100 utf8一个字符占三个字节，所以是300， 记录真正长度（用来观看查询） 2字节（记录303）， 记录是否为null 1字节 所以303  EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;;  #303  EXPLAIN SELECT * FROM s1 WHERE key_part1 = \u0026#39;a\u0026#39;;   #606联合索引的情况下，数字越大查询到的页记录就少，就越精准，所以越大越好  EXPLAIN SELECT * FROM s1 WHERE key_part1 = \u0026#39;a\u0026#39; AND key_part2 = \u0026#39;b\u0026#39;;   EXPLAIN SELECT * FROM s1 WHERE key_part1 = \u0026#39;a\u0026#39; AND key_part2 = \u0026#39;b\u0026#39; AND key_part3 = \u0026#39;c\u0026#39;;   EXPLAIN SELECT * FROM s1 WHERE key_part3 = \u0026#39;a\u0026#39;;  #练习： #varchar(10)变长字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)  #varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)  #char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)  #char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1) 众所周知，记录是以行的形式进行保存的，Mysql5.1以后，行的保存格式默认为Compact格式。行记录Compact格式为：\n变长字段NULL标志位记录头信息列1数据列2数据列3数据\u0026hellip;\n第一个变长字段是记录这行的总字段长度，如果行记录的字段总长小于255字节，变长字段就占一个字节(一个字节有8位，8位的二进制最多能表示到255)。当大于255时，变长字段的长度就是两个字节。Mysql规定变成字段不超过两个字节，就意味着行的段总长最多不能超过65535个字节(两个字节有16位，16位最多能表示65535)。\nref  # 8. ref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息。  #比如只是一个常数或者是某个列。   EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39;;    EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;    EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1); rows # 9. rows：预估的需要读取的记录条数  # `值越小越好` ，越小，数据就更有可能在同一个叶中，进行的io次数就会越少  EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39;; filtered # 10. filtered: 某个表经过搜索条件过滤后剩余记录条数的百分比   #如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用  #到对应索引的搜索条件外的其他搜索条件的记录有多少条。  EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39; AND common_field = \u0026#39;a\u0026#39;;    #对于单表查询来说，这个filtered列的值没什么意义，我们`更关注在连接查询  #中驱动表对应的执行计划记录的filtered值`，它决定了被驱动表要执行的次数(即：rows * filtered)  EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = \u0026#39;a\u0026#39;;  Extra #11. Extra:一些额外的信息  #更准确的理解MySQL到底将如何执行给定的查询语句   #当查询语句的没有`FROM`子句时将会提示该额外信息  EXPLAIN SELECT 1;    #查询语句的`WHERE`子句永远为`FALSE`时将会提示该额外信息  EXPLAIN SELECT * FROM s1 WHERE 1 != 1;    #当我们使用全表扫描来执行对某个表的查询，并且该语句的`WHERE`  #子句中有针对该表的搜索条件时，在`Extra`列中会提示上述额外信息。没有索引的时候显示useing where  EXPLAIN SELECT * FROM s1 WHERE common_field = \u0026#39;a\u0026#39;;    #当使用索引访问来执行对某个表的查询，并且该语句的`WHERE`子句中  #有除了该索引包含的列之外的其他搜索条件时，在`Extra`列中也会提示上述额外信息。  EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39; AND common_field = \u0026#39;a\u0026#39;;    #当查询列表处有`MIN`或者`MAX`聚合函数，但是并没有符合`WHERE`子句中  #的搜索条件的记录时，将会提示该额外信息  EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = \u0026#39;abcdefg\u0026#39;;  #Select tables optimized away  EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = \u0026#39;NlPros\u0026#39;; #NlPros 是 s1表中key1字段真实存在的数据   #select * from s1 limit 10;   #当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以  #使用覆盖索引的情况下，在`Extra`列将会提示该额外信息。比方说下边这个查询中只  #需要用到`idx_key1`而不需要回表操作：  EXPLAIN SELECT key1,id FROM s1 WHERE key1 = \u0026#39;a\u0026#39;;    #有些搜索条件中虽然出现了索引列，但却不能使用到索引  #看课件理解索引条件下推  #有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询： #SELECT FROM s1 WHERE key1 \u0026gt;\u0026#39;z\u0026#39;AND key1 LIKE \u0026#39;%a\u0026#39; #其中的key1\u0026gt;\u0026#39;z\u0026#39;可以使用到索引，但是key1 LIKE%a\u0026#39;却无法使用到索引，在以前版本的MySQL中 #是按照下边步骤来执行这个查询的：  #1.先根据key1\u0026gt;\u0026#39;z\u0026#39;这个条件，从二级索引1dx_key1中获取到对应的二级索引记录。 #2.根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合 #key1LIKE\u0026#39;%a\u0026#39;这个条件，将符合条件的记录加入到最后的结果集。  #但是虽然key1 LIKE\u0026#39;%a\u0026#39;不能组成范围区间参与range访问方法的执行，但这个条件毕竟只涉及到了 #key1列，所以MySQL把上边的步骤改进了一下：  #1.先根据key1\u0026gt;\u0026#39;z\u0026#39;这个条件，定位到二级索引idx_key1中对应的二级索引记录。 #2.对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足key1 LIKE\u0026#39;%à\u0026#39;这个条件， #如果这个条件不满足，则该二级索引记录压根儿就没必要回表。 #3.对于满足key1LIKE\u0026#39;%a\u0026#39;这个条件的二级索引记录执行回表操作。 #我们说回表操作其实是一个随机I0，,比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表 ##操作的成本。MySQL把他们的这个改进称之为索引条件下推（英文名：Index Condition Pushdown)。 #如果在查询语句的执行过程中将要使用索引条件下推这个特性，在Extra列中将会显示Using index #condition,比如这样：  EXPLAIN SELECT * FROM s1 WHERE key1 \u0026gt; \u0026#39;z\u0026#39; AND key1 LIKE \u0026#39;%a\u0026#39;;    #在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为  #其分配一块名叫`join buffer`的内存块来加快查询速度，也就是我们所讲的`基于块的嵌套循环算法`  #见课件说明  EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;    #当我们使用左（外）连接时，如果`WHERE`子句中包含要求被驱动表的某个列等于`NULL`值的搜索条件，  #而且那个列又是不允许存储`NULL`值的，那么在该表的执行计划的Extra列就会提示`Not exists`额外信息  EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;    #如果执行计划的`Extra`列出现了`Using intersect(...)`提示，说明准备使用`Intersect`索引  #合并的方式执行查询，括号中的`...`表示需要进行索引合并的索引名称；  #如果出现了`Using union(...)`提示，说明准备使用`Union`索引合并的方式执行查询；  #出现了`Using sort_union(...)`提示，说明准备使用`Sort-Union`索引合并的方式执行查询。  EXPLAIN SELECT * FROM s1 WHERE key1 = \u0026#39;a\u0026#39; OR key3 = \u0026#39;a\u0026#39;;    #当我们的`LIMIT`子句的参数为`0`时，表示压根儿不打算从表中读出任何记录，将会提示该额外信息  EXPLAIN SELECT * FROM s1 LIMIT 0;    #有一些情况下对结果集中的记录进行排序是可以使用到索引的。  #比如：  EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;    #很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）  #进行排序，MySQL把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：`filesort`）。   #如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的`Extra`列中显示`Using filesort`提示  EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;    #在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们  #在执行许多包含`DISTINCT`、`GROUP BY`、`UNION`等子句的查询过程中，如果不能有效利用索引来完成  #查询，MySQL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行  #计划的`Extra`列将会显示`Using temporary`提示  EXPLAIN SELECT DISTINCT common_field FROM s1;   #EXPLAIN SELECT DISTINCT key1 FROM s1;   #同上。  EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field;   #执行计划中出现`Using temporary`并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以  #我们`最好能使用索引来替代掉使用临时表`。比如：扫描指定的索引idx_key1即可  EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;  #json格式的explain EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = \u0026#39;a\u0026#39;; 小结\n EXPLAIN不考虑各种Cache EXPLAIN不能显示MySQL在执行查询时所作的优化工作 EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况 部分统计信息是估算的，并非精确值  EXPLAIN的进一步使用 EXPLAIN****四种输出格式\n这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：\n传统格式 ， JSON格式 ， TREE格式 以及可 视化输出 。用户可以根据需要选择适用于自己的格式。\n索引优化与查询优化 todo\n 2022-3-29 19:27:294\n数据库的设计规范 为什么需要数据库设计 数据库的范式设计越高阶，冗余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式(1NF)。在第一范式的基础上进一步满足更多规范要求的称为第二范式(2NF),其余范式以次类推。一般来说，在关系型数据库设计中，最高也就遵循到BCNF,普遍还是3NF。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规侧也就是反规范化。\n范 式 范式简介 **在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。**可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。范式的定义会使用到主键和候选键，数据库中的键(Ky)）由一个或者多个属性组成。\n范式都包括哪些 目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。\n键和相关属性的概念 数据表中常用的几种键和属性的定义：\n 超键：能唯一标识元组的属性集叫做超键。 候选键：如果超键不包括多余的属性，那么这个超键就是候选键。 主键：用户可以从候选键中选择一个作为主键。 外键：如果数据表R1中的某属性集不是R1的主键，而是另一个数据表R2的主键，那么这个属性集就是数据表R1的外键。 主属性：包含在任一候选键中的属性称为主属性。 非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性。  通常，我们也将候选键称之为“码”，把主键也称为“主码”。因为键可能是由多个属性组成的，针对单个属性，我 们还可以用主属性和非主属性来进行区分\n举例：\n这里有两个表：\n球员表(player) ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号\n球队表(team) ：球队编号 | 主教练 | 球队所在地\n 超键 ：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。 候选键 ：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。 主键 ：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。 外键 ：球员表中的球队编号。 主属性 、 非主属性 ：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。  第一范式(1st NF) 第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值为不可再次拆分的最小数据单元。我们在设计某个字段的时候，对于字段X来说，不能把字段X拆分成字段X-1和字段X-2。事实上，任何的DBMS都会满足第一范式的要求，不会将字段进行拆分。\n举例1：\n假设一家公司要存储员工的姓名和联系方式。它创建一个如下表：\n该表不符合 1NF ，因为规则说“表的每个属性必须具有原子（单个）值”，lisi和zhaoliu员工的emp_mobile 值违反了该规则。为了使表符合 1NF ，我们应该有如下表数据：\n属性的原子性是 主观的 。例如，城市全称是否需要分开呢？答案取决于业务。\n第二范式(2nd NF) 第二范式要求，在满足第一范式的基础上，还要**满足数据表里的每一条数据记录，都是可唯一标识的（要有主键）。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。**如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。(要求中的主键，其实可以拓展替换为候选键)。\n==举例1==：\n成绩表 （学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课程号也不能决定成绩，所以（学号，课程号）→成绩 就是 完全依赖关系 。\n==举例2==：\n比赛表 player_game ，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：\n(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分) 但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：\n姓名年龄完全取决于球员编号，和比赛编号没有关系，同理比赛时间, 比赛场地。\n(球员编号) → (姓名，年龄) (比赛编号) → (比赛时间, 比赛场地) 对于非主属性来说，并非完全依赖候选键。这样会产生一下问题：\n 数据冗余 ：  如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。\n  插入异常 ：\n如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。\n  删除异常 ：\n如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删除掉。\n  更新异常 ：\n如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调整，否则就会出现一场比赛时间不同的情况。\n  因此我们可以把球员比赛表设计为下面的三张表：\n 1NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，一张表只表达一个意思。\n 第三范式(3rdNF) 第三范式是在第二范式的基础上，要求数据表中不能存有非主属性A依赖于非主属性B,非主属性B依赖于主键C的情况，即存在“A→B→C”的决定关系)，通俗地讲，==所有非主键属性之间不能有依赖关系，必须相互独立。==\n这里的主键可以拓展为候选键。\n商品类别名称依赖于商品类别编号，不符合第三范式。\n符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括：“每个非键属性依赖于键，依赖于整个键，并且除了键别无他物”。\n小结 关于数据表的设计，有三个范式要遵循。\n  第一范式(1NF),==确保每列保持原子性== 数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。\n  第二范式(2NF),==确保每列都和主键完全依赖==\n尤其在复合主键的情况下，非主键部分不应该依赖于部分主键。\n  第三范式(3NF)==确保每列都和主键列直接相关，而不是间接相关==\n  范式的优点：数据的标准化有助于消除数据库中的数据冗余，第三范式(3N)通常被认为在性能、扩展性和数据完整性方面达到了最好的平衡。\n  范式的缺点：范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。\n  反范式化 视频 p153——尚硅谷\n有的时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这时候，我们就要**遵循业务优先的原则，首先满足业务需求，再尽量减少冗余。**顶多违反第二三范式，第一范式还是要遵循的。\n如果数据库中的数据量比较大，系统的UV和PV访问频次比较高，三大范式在一定程度上会影响数据库的读性能。因此反范式优化也是一种优化思路。此时，可以通过在数据表中增加冗余字段来提高数据库的读性能。\n  为满足某种商业目标 , 数据库性能比规范化数据库更重要 在数据规范化的同时 , 要综合考虑数据库的性能 通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间 通过在给定的表中插入计算列，以方便查询     举例1：\n第三范式当中举例，如果需要经常查询商品的名称，大可将增加冗余的字段商品名称。\n  反范式的新问题  存储 空间变大 了 一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致 若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 消耗系统资源 在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加 复杂  反范式的适用场景 当冗余信息有价值或者能 大幅度提高查询效率 的时候，我们才会采取反范式的优化。\n  增加冗余字段的建议\n只有满足这两个条件，才可以考虑增加==冗余字段==。\n 这个冗余字段==不需要经常进行修改；== 这个冗余字段==查询的时候不可或缺。==    历史快照、历史数据的需要\n  在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的 订单收货信息 都属于历史快照 ，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。\n 反范式优化也常用在 数据仓库的设计中，因为数据仓库通常 存储历史数据 ，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。\n我简单总结下数据仓库和数据库在使用上的区别：\n  数据库设计的目的在于捕获数据，而数据仓库设计的目的在于分析数据；\n  数据库对数据的增删改实时性要求强，需要存储在线的用户数据，而数据仓库存储的一般是历史数据：\n  数据库设计需要尽量避免冗余，但为了提高查询效率也允许一定的冗余度，而数据仓库在设计上更偏向采用反范式设计\n   BCNF(巴斯范式) 视频 p154 ———— 尚硅谷\n巴斯范式(BCNF),也叫做巴斯-科德范式(Boyce-Codd Normal Form)。BCNF被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是修正的第三范式。\n若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BC范式。\n一般来说，一个数据库设计符合3NF或BCNF就可以了。\n举例1：\n在这个表中，一个仓库只有一个管理员，同时一个管理员也只管理一个仓库。我们先来梳理下这些属性之间的依赖关系。\n仓库名决定了管理员，管理员也决定了仓库名，同时（仓库名，物品名）的属性集合可以决定数量这个属性。这样，我们就可以找到数据表的候选键。\n 候选键 ：是（管理员，物品名）和（仓库名，物品名），然后我们从候选键中选择一个作为 主键 ，比如（仓库名，物品名）。 主属性 ：包含在任一候选键中的属性，也就是仓库名，管理员和物品名。 非主属性 ：数量这个属性。  符合三范式\n我们需要根据范式的等级，从低到高来进行判断。\n 首先，数据表每个属性都是原子性的，符合 1NF 的要求； 其次，数据表中非主属性”数量“都与候选键全部依赖，（仓库名，物品名）决定数量，（管理员，物品名）决定数量。因此，数据表符合 2NF 的要求； 最后，数据表中的非主属性，不传递依赖于候选键。因此符合 3NF 的要求。  存在的问题\n 增加一个仓库，但是还没有存放任何物品。根据数据表实体完整性的要求，主键不能有空值，因此会出现 插入异常 ； 如果仓库更换了管理员，我们就可能会 修改数据表中的多条记录 ； 如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除。  即便数据表符合 3NF 的要求，同样可能存在插入，更新和删除数据的异常情况。\n问题解决\n首先我们需要确认造成异常的原因：==主属性仓库名对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致上面的异常情况。因此引入BCNF，它在3NF的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。==\n如果在关系R中，U为主键，B属性是主键的一个属性，若存在B-\u0026gt;A，A为主属性，则该关系不属于BCNF。\n根据 BCNF 的要求，我们需要把仓库管理关系 warehouse_keeper 表拆分成下面这样：\n  仓库表 ：（仓库名，管理员）\n  库存表 ：（仓库名，物品名，数量）\n  这样就不存在主属性对于候选键的部分依赖或传递依赖，上面数据表的设计就符合 BCNF。\n第四范式 todo\n第五范式、域键范式 todo\n实战案例 视频 p155 ———— 尚硅谷\n商超进货系统中的进货单表进行剖析：\n进货单表：\n这个表中的字段很多，表里的数据量也很惊人。大量重复导致表变得庞大，效率极低。如何改造？\n在实际工作场景中，这种由于数据表结构设计不合理，而导致的数据重复的现象并不少见。往往是系统虽然能够运行，承载能力却很差，稍微有点流量，就会出现内存不足、CUP使用率飙升的情况，甚至会导致整个项目失败。\n 2022-3-30\nER模型 视频 p156 ———— 尚硅谷\n数据库设计是牵一发而动全身的。那有没有什么办法提前看到数据库的全貌呢？比如需要哪些数据表、 数据表中应该有哪些字段，数据表与数据表之间有什么关系、通过什么字段进行连接，等等。这样我们才能进行整体的梳理和设计。\n其实，ER模型就是一个这样的工具。ER模型也叫作实体关系模型，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。在开发基于数据库的信息系统的设计阶段，通常使用E模型来描述信息需求和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。\n特别说明：\n==工作中数据库最好不要用外键，如上所说非常影响性能，我们可以采取应用层面数据的一致性检查：例如选课系统，如果数据库中不做外键处理，我们可以在前端后端做校验处理，让用户只能输入相应的课程（或者采用下拉菜单选择的方式选择），从而实现外键的作用。==\n设计原则 三少一多：\n 数据==表的个数==越少越好 RDBMS的核心在于对实体和联系的定义，也就是E-R图(Entity Relationship Diagram),数据表越少，证明实体 和联系设计得越简洁，既方便理解又方便操作。 数据表中的==字段==个数越少越好 字段个数越多，数据沉余的可能性越大。设置字段个数少的前提是各个字段相互独立，而不是某个字段的取值可 以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。 数据表中==联合主键的字段==个数越少越好 设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式（也就是用多个字 段来定义一个主键)。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间 和索引空间，因此联合主键的字段个数越少越好。 使用==主键和代码逻辑层外键关系（不是外键约束）==越多越好 数据库的设计实际上就是定义各种表，以及各种字段之间的关系。这些关系越多，证明这些实体之间的冗余度越 低，利用度越高。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率。  “三少一多”原则的核心就是简单可复用。简单指的是用更少的表、更少的字段、更少的联合主键字段来完成数据 表的设计。可复用则是通过主键、外键的使用来增强数据表之间的复用率。因为一个主键可以理解是一张表的代 表。键设计得越多，证明它们之间的利用率越高。\n数据对象的编写建议 todo\n数据库对象编写建议 todo\n事务 事务概述 存储引擎支持情况 SHOW ENGINES 命令来查看MySQL 中，只有InnoDB 是支持事务的。\n基本概念 **事务：**一组逻辑操作单元，使数据从一种状态变换到另一种状态。\n**事务处理的原则：**保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。\n事务的ACID特性   原子性（atomicity）：\n原子性是指==事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。==\n  一致性（consistency）：\n（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述）根据定义，一致性是指事务执行前后，数据从一个 合法性状态 变换到另外一个 合法性状态 。这种状态是 语义上 的而不是语法上的，跟具体的业务有关。通俗的说，就是==事务前后数据状态符合事实约束，符合常理==\n那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。\n 举例1：A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须\u0026gt;0。 举例2：A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时数据是不一致的，为什么呢？因为你定义了一个状态，要求A+B的总余额必须不变。 举例3：在数据表中我们将姓名字段设置为唯一性约束，这时当事务进行提交或者事务发生回滚的时候，如果数据表中的姓名不唯一，就破坏了事务的一致性要求。    隔离型（isolation）：\n事务的隔离性是指一个==事务的执行不能被其他事务干扰== ，即一个事务内部的操作及使用的数据对 并发 的\n其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n如果无法保证隔离性会怎么样？假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50\n元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：\nUPDATE accounts SET money = money - 50 WHERE NAME = \u0026#39;AA\u0026#39;; UPDATE accounts SET money = money + 50 WHERE NAME = \u0026#39;BB\u0026#39;;   持久性（durability）：\n  持久性是指一个==事务一旦被提交，它对数据库中数据的改变就是 永久性的==，接下来的其他操作和数据库故障不应该对其有任何影响。\n==持久性是通过 事务日志 来保证的==。日志包括了 重做日志 和 回滚日志 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性\n ==原子性是基础，隔离性是手段，1一致性是约束条件，而持久性是我们的目的。==\n 事务的状态 我们现在知道 事务 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把 事务 大致划分成几个状态：\n  活动的（active） 事务对应的数据库操作正在执行过程中时，我们就说该事务处在 活动的 状态。\n  部分提交的（partially committed） 当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 没有刷新到磁盘时，我们就说该事务处在 部分提交的 状态。\n  失败的（failed） 当事务处在 活动的 或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失 败的 状态。\n  中止的（aborted） 如果事务执行了一部分而变为 失败的 状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 回滚 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 中止的 状态。\n  提交的（committed） 当一个处在 部分提交的 状态的事务将修改过的数据都 同步到磁盘 上之后，我们就可以说该事务处在了 提交的 状态。\n  使用事务 分别为 显式事务 和 隐式事务 。\n显示事务  步骤1： START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。  mysql\u0026gt; BEGIN; #或者 mysql\u0026gt; START TRANSACTION; START TRANSACTION 语句相较于 BEGIN 特别之处在于，后边能跟随几个 修饰符 ：\n  READ ONLY：标识当前事务是一个 只读事务 ，也就是属于该事务的数据库操作只能读取数据，而不 能修改数据。\n 补充：只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用 CREATE TMEPORARY TABLE创建的表)，由于它们只能在当前会话中可见，所以只读事务其实也是可以对临时表进行增、删、改操作的。\n   READ WRITE：标识当前事务是一个 读写事务 ，也就是属于该事务的数据库操作既可以读取数据， 也可以修改数据。\n  WITH CONSISTENT SNAPSHOT：启动一致性读。\n   步骤2：一系列事务中的操作（==主要是DML，不含DDL==）\n  步骤3：提交事务 或 中止事务（即回滚事务）\n# 提交事务。当提交事务后，对数据库的修改是永久性的。 mysql\u0026gt; COMMIT; # 回滚事务。即撤销正在进行的所有没有提交的修改 mysql\u0026gt; ROLLBACK; # 将事务回滚到某个保存点。 mysql\u0026gt; ROLLBACK TO [SAVEPOINT] 其中SAVEPOINT（关键点，使得不用全部回滚）相关操作\n#在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。 SAVEPOINT 保存点名称； #朋除某个保存点。 RELEASE SAVEPOINT 保存点名称：   隐式事务 MySQL中有一个系统变量 autocommit ：\nmysql\u0026gt; SHOW VARIABLES LIKE \u0026#39;autocommit\u0026#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | autocommit | ON | +---------------+-------+ 1 row in set (0.01 sec) 默认情况下，如果我们不显式的使用START TRANSACTION或者BEGIN语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的自动提交。\n若想不自动提交，就使用显示事务（ START TRANSACTION 或者 BEGIN）并且关闭 自动提交：\nSET autocommit = OFF; #或 SET autocommit = 0; 我们显式的写出C0MMIT语句来把这个事务提交掉，或者显式的写出ROLLBACK语句来把这个事务回滚掉。\n隐式提交数据的情况   数据定义语言（Data definition language，缩写为：DDL）\n  隐式使用或修改mysql数据库中的表\n当我们使用ALTER USER、CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET\rPASSWORD等语句时也会隐式的提交前边语句所属于的事务。\n  事务控制或关于锁定的语句\n  当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了 另一个事务时，会 隐式的提交 上一个事务。\n  当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交 前边语 句所属的事务。\n  使用LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会 隐式的提交 前边语句所属的事\n务。\n    加载数据的语句\n使用LOAD DATA语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。\n  关于MySQL复制的一些语句\n使用START SLAVE、STOP SLAVE、RESET SLAVE、CHANGE MASTER TO等语句时会隐式的提交前边语句所属的事务。\n  其它的一些语句\n使用ANALYZE TABLE、CACHE INDEX、CHECK TABLE、FLUSH、LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET等语句也会隐式的提交前边语句所属的事务。\n   2022-4-1\n使用举例1：提交与回滚 事务执行参数completion._type：\nMySQL中completion._type参数的作用，实际上这个参数有3种可能：\nSET @@completion_type = 1;  completion=0（NO CHAIN），这是默认情况。当我们执行COMMIT的时候会提交事务，在执行下一个事务时，还需要使 用START TRANSACTION或者BEGIN来开启. completion=1，这种情况下，当我们提交事务后，相当于执行了COMMIT AND CHAIN，也就是开启一个 链式事务，即当我们提交事务之后会开启一个相同隔离级别的事务。 completion=2，这种情况下COMMIT=COMMIT AND RELEASE，也就是当我们提交后，会自动与服务器断 开连接。   当我们设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。\n当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。\n 事务的隔离级别 视频 p164 ———— 尚硅谷\nMySQL是一个 客户端／服务器 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称为一个会话（ Session ）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务有 隔离性 的特性，理论上在某个事务 对某个数据进行访问 时，其他事务应该进行 排 队 ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 性能影太大 ，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 性能尽量高些 ，那就看二者如何权衡取舍了。\n数据准备 CREATE TABLE student ( \tstudentno INT,  NAME VARCHAR ( 20 ), \tclass VARCHAR ( 20 ),  PRIMARY KEY ( studentno ) ) ENGINE = INNODB CHARSET = utf8;  INSERT INTO student VALUES(1, \u0026#39;小谷\u0026#39;, \u0026#39;1班\u0026#39;); 数据并发问题 下访问相同数据的事务在 不保证串行执行 （也就是执行完一个再执行另一个）的情况下可能会出现哪些问题：\n 脏写（ Dirty Write ） 脏读（ Dirty Read ） 不可重复读（ Non-Repeatable Read ） 幻读（ Phantom ）  脏写 对于两个事务 Session A、Session B，如果事务Session A 修改了 另一个 未提交 事务Session B 修改过 的数据，那就意味着发生了 脏写\n脏读 对于两个事务 Session A、Session B，Session A 读取 了已经被 Session B 更新 但还 没有被提交 的字段。 之后若 Session B 回滚 ，Session A 读取 的内容就是 临时且无效 的。\nSession A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新为\u0026rsquo;张三\u0026rsquo;，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为\u0026rsquo;张三\u0026rsquo;，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为 脏读 。\n不可重复读 (简单系统往往视为正常，并发系统中不可重复读是个问题)对于两个事务Session A、Session B，Session A 读取 了一个字段，然后 Session B 更新 了该字段。 之后Session A 再次读取 同一个字段， 值就不同 了。那就意味着发生了不可重复读。\n我们在Session B中提交了几个 隐式事务 （注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为 不可重复读 。\n幻读 对于两个事务Session A、Session B, Session A 从一个表中 读取 了一个字段, 然后 Session B 在该表中 插 入 了一些新的行。 之后, 如果 Session A 再次读取 同一个表, 就会多出几行。那就意味着发生了幻读。\nSession A中的事务先根据条件 studentno \u0026gt; 0这个条件查询表student，得到了name列值为\u0026rsquo;张三\u0026rsquo;的记录；之后Session B中提交了一个 隐式事务 ，该事务向表student中插入了一条新记录；之后Session A中的事务再根据相同的条件 studentno \u0026gt; 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为 幻读 。我们把新插入的那些记录称之为 幻影记录 。\n注意1 有的同学会有疑问，那如果Session B中删除了一些符合studentno\u0026gt;g的记录而不是插入新记录，那Session A 之后再根据studentno\u0026gt;0的条件读取的记录变少了，这种现象算不算幻读呢？这种现象不属于幻读，幻读强 调的是多了记录。\n注意2 那对于先前已经读到的记录，之后又读取不到这种情况相当于对每一条记录都发生了 不可重复读的 现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。\nSQL中的四种隔离级别 严重性来排序：脏写 \u0026gt; 脏读 \u0026gt; 不可重复读 \u0026gt; 幻读。\n隔离性和性能都要兼顾。设立一些隔离级别，隔离级别越低，并发问题发生的就越多。\nSQL标准 中设立了4个 隔离级别 ： (以下4种隔离级别都解决的脏写的问题)\n READ UNCOMMITTED ：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。 READ COMMITTED ：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。 REPEATABLE READ ：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。 SERIALIZABLE ：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。  MySQL支持的四种隔离级别 视频 p165 ———— 尚硅谷\n  Oracle就只支持READ COMMITTED(默认隔离级别)和SERIALIZABLE隔离级别。\n  MySQL虽然支持4种隔离级别，但与SQL标准中所规定的各级隔离级别 允许发生的问题却有些出入，MySQL在 REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的，禁止幻读 的原因在后面的章节中。\n  查看隔离级别：\n  MySQL 5.7.20版本之前\nSHOW VARIABLES LIKE \u0026#39;tx_isolation\u0026#39;;   MySQL 5.7.20版本之后\nSHOW VARIABLES LIKE \u0026#39;transaction_isolation\u0026#39;;   或者不同MySQL版本中都可以使用的：\nSELECT @@transaction_isolation;   如何设置事务的隔离级别 SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = \u0026#39;隔离级别\u0026#39; #其中，隔离级别格式： \u0026gt; READ-UNCOMMITTED \u0026gt; READ-COMMITTED \u0026gt; REPEATABLE-READ \u0026gt; SERIALIZABLE 关于设置时使用GLOBAL或SESSION的影响：   使用 GLOBAL 关键字（在全局范围影响）：\nSET GLOBAL TRANSACTION_ISOLATION = \u0026#39;SERIALIZABLE\u0026#39;;  当前已经存在的会话无效 只对执行完该语句之后产生的会话起作用    使用 SESSION 关键字（在会话范围影响）：\nSET SESSION TRANSACTION_ISOLATION = \u0026#39;SERIALIZABLE\u0026#39;;  对当前会话的所有后续的事务有效 如果在事务之间执行，则对后续的事务有效 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务    修改配置文件：\n如果在服务器启动时想改变事务的默认隔离级别，可以修改启动参数transaction_isolation的值。比如，在 启动服务器时指定了transaction_isplation=SERIALIZABLE,那么事务的默认隔离级别就从原来的 REPEATABLE-READ变成了SERIALIZABLE。\n   小结：\n数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性 就越好，但并发性越弱。\n 不同隔离级别举例 演示1. 读未提交之脏读（解决了脏写） 设置隔离级别为未提交读：\n事务1和事务2的执行流程如下：\n演示2：读已提交（解决了脏写，脏读） 视频 p167 ———— 尚硅谷\n演示3：可重复读（解决了脏写，脏读，不可重复读） 视频 p167 ———— 尚硅谷\n设置隔离级别为可重复读，事务的执行流程如下：\n演示4：幻读 视频 p168 ———— 尚硅谷\nrepeatable read 解决不了幻读，但是mysql可以避免幻读，看后续\n事务1中事务开启后，事务2 提交， 事务1中查询还是查不到的，但是如果在事务1中插入相同的数据，会报错，从而证明了发生了幻读。\n事务的常见分类  扁平事务（Flat Transactions） 带有保存点的扁平事务（Flat Transactions with Savepoints） 链事务（Chained Transactions） 嵌套事务（Nested Transactions） 分布式事务（Distributed Transactions）  扁平事务 最简单的一种，但是在实际生产环境中，这可能是使用最频繁的事务，在扁平事务 中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是 原子的，要么都执行，要么都回滚，因此，扁平事务是应用程序成为原子操作的基本组成模块。扁平事务虽然简单，但是在实际环境中使用最为频繁，也正因为其简单，使用频繁，故每个数据库系统都实现了对扁平事务的支持。扁平事务的主要限制是不能提交或者回滚事务的某一部分，或分几个步骤提交。\n扁平事务一般有三种不同的结果：\n 事务成功完成。在平常应用中约占所有事务的96%。 应用程序要求停止事 务。比如应用程序在捕获到异常时会回滚事务，约占事务的3%。 外界因素强制终止事务。如连接超时或连接断 开，约占所有事务的1%。  带有保存点的扁平事务 todo\n链事务 todo\n嵌套事务 todo\n分布式事务 todo\n事务的日志 事务的四种特性到底是基于什么机制实现呢？\n 事务的隔离性由 锁机制 实现。 而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。  REDO LOG 称为 重做日志 ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持 久性。 UNDO LOG 称为 回滚日志 ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。    UNDO 不是 REDO 的逆过程，UNDO 和 REDO都可以视为一种恢复操作，都是存储引擎层生成的日志。\nredo log:记录的是\u0026quot;物理级别\u0026quot;上的页修改操作，比如页号xxx、偏移量yyy 写入了\u0026rsquo;zzz\u0026rsquo;数据。主要为了保证数据的可靠性；\nundo log:记录的是逻辑操作日志，比如对某一行数据进行了INSERT语句 操作，那么undo logi就记录一条与之相反的DELETE操作。主要用于事务的回滚 ( undo log记录的是每个修改操作的逆操作)和一致性非锁定读(undo log回滚行记录到某种特定的版本-MVCC,即多版本并发控制 ) 。\nREDO LOG 概念 视频 p169 ———— 尚硅谷\nINNODB存储引擎是以页为单位来管理存储空间的。在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Poo1之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘(checkPoint机制)，通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不 会下降太快。\n一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint 并不是每次变更的时候就触发 的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。\n另一方面，事务包含 持久性 的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。\n那么如何保证这个持久性呢？\n  一个简单的做法 ：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题\n 修改量与刷新磁盘工作量严重不成比例 有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在IoDB中是以页为单位来进行磁盘1o的，也 就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB 大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太小题大做了。 随机1O刷新较慢 一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相 邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机I0,随机I0比 顺序I0要慢，尤其对于传统的机械硬盘来说。    另一个解决的思路 ：我们只需要把 修改 了哪些东西 记录一下 就好。比如，某个事务将系统表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。\n  InnoDB引擎的事务采用了WAL技术（Write-Ahead Logging),这种技术的思想就是先写日志，再写磁盘，只 有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通 过redo log来恢复，保证AclD中的D,这就是redo log的作用。\n  REDO日志的好处特点   好处\nredo日志降低了刷盘频率redo日志占用的空间非常小\n  特点\n  redo日志是顺序写入磁盘的事务执行过程中，redo log不断记录\n 2022-4-2\nredo的组成 小记   我们进行内联查询前，最好能限制连的表大小的条件都先用上了，同时尽量让条件查询和分组执行的表尽量小====》CSDN博客_mysql联表查询优化① \n  uuid采用char(32)或char(36)存储的话，需要占用32或36个字节。为节省存储空间，改为binary(16)，占用16字节。对于500W行的表，可节省7.4G的空间。\nmybatis中没有默认的type handler来完成uuid类型\u0026lt;-\u0026gt;binary类型的相互转换，需要自定义一个type handler。下面就详细地介绍如何实现。\n  DATEDIFF(w1.recordDate,w2.recordDate)=1 日期函数，计算二者差值\n ","id":9,"section":"posts","summary":"","tags":["mysql"],"title":"MySql高级","uri":"https://gb.ytte.top/2022/03/24/mysql%E9%AB%98%E7%BA%A7/","year":"2022"},{"content":"消息队列 MQ 的相关概念 RabbitMQ 概念 RabbitMQ是一个消息中间件：它接受并转发消息。可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑RabbitMQ是一个快递站，一个快递员帮你传递快件。RabbitMQ与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。\n四大核心   生产者：\n产生数据发送消息的程序是生产者\n  交换机：\n交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定\n  队列：\n队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式\n  消费者：\n消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。\n  核心模式  Hello World——简单模式 Work Queue——工作模式 Publish/Subscribe——发布/订阅模式 Routing——路由模式 Topics——主题模式 Publisher Confirms——发布确认模式  关键词  Broker：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建exchange／queue 等 Connection：publisher／consumer 和 broker 之间的 TCP 连接 Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCPConnection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的Connection 极大减少了操作系统建立 TCP connection 的开销 Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：==direct== (point-to-point), ==topic== (publish-subscribe) and==fanout==(multicast) Queue：消息最终被送到这里等待 consumer 取走 Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据  安装 非docker方式   官方网址\n  文件上传\n上传到/usr/local/software 目录下(如果没有 software 需要自己创建)\n链接：https://pan.baidu.com/s/1UTJhAesjTjQl3rl-v9MZBw 提取码：ytte \u0026ndash;来自百度网盘超级的分享\n  安装文件(分别按照以下顺序安装)\nrpm -ivh erlang-21.3-1.el7.x86_64.rpm #rabbitmq的前置erlang的环境 yum install socat -y #官网要求安装 rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm #rabbitmq-server   常用命令(按照以下顺序执行)\n         chkconfig rabbitmq-server on 添加开机启动 RabbitMQ 服务   /sbin/service rabbitmq-server start 启动服务   /sbin/service rabbitmq-server status 查看服务状态   /sbin/service rabbitmq-server stop 停止服务(选择执行)   rabbitmq-plugins enable rabbitmq_management 开启 web 管理插件    开启web管理插件的时候需要停止服务，开启web管理插件后需要手动再次启动rabbitmq服务。\n  linux防火墙开启端口\nfirewall-cmd --zone=public --add-port=5672/tcp --permanent #开启5672端口 程序代码执行所需端口 firewall-cmd --zone=public --add-port=15672/tcp --permanent\t#开启15672端口 web插件所需端口  firewall-cmd --reload\t#防火墙重启  firewall-cmd --zone=public --list-ports\t#查看开放的端口  systemctl status firewalld\t#查看防火墙状态   云服务器开启15672和5672端口\n用默认账号密码(guest)访问地址 http://ip:15672/出现权限问题\n  出现权限问题是因为guest设置了超级管理员角色，但是没有被赋予权限。\n添加一个新的用户：\n   序号       1 rabbitmqctl add_user admin 123 创建账号   2 rabbitmqctl set_user_tags admin administrator 设置用户角色   3 rabbitmqctl set_permissions -p \u0026quot;/\u0026quot; admin \u0026quot;.*\u0026quot; \u0026quot;.*\u0026quot; \u0026quot;.*\u0026quot; 设置用户权限   3.1 set_permissions [-p ]  用户 user_admin 具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限   4  rabbitmqctl list_users 显示当前用户和角色      再次利用 admin 用户登录\n  重置命令\n 关闭应用的命令为：rabbitmqctl stop_app 清除的命令为：rabbitmqctl reset 重新启动命令为：rabbitmqctl start_app    docker安装   pull\ndocker pull rabbitmq   run\n15672端口\ndocker run -d --name myrabbitmq -p 15672:15672 -p 5672:5672 rabbitmq   增加超级管理员用户，开启web插件\ndocker ps docker exec -it 容器ID /bin/bash rabbitmqctl add_user admin 123\t#创建账号 rabbitmqctl set_user_tags admin administrator #设置用户角色 rabbitmqctl set_permissions -p \u0026#34;/\u0026#34; admin \u0026#34;.*\u0026#34; \u0026#34;.*\u0026#34; \u0026#34;.*\u0026#34; #用户 user_admin 具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限 rabbitmqctl list_users #显示当前用户和角色  rabbitmq-plugins enable rabbitmq_management #开启web插件  ctrl+p+q #退出当前容器   重启容器\ndocker restart 容器ID   linux防火墙开启端口\nfirewall-cmd --zone=public --add-port=5672/tcp --permanent #开启5672端口 firewall-cmd --zone=public --add-port=15672/tcp --permanent\t#开启15672端口  firewall-cmd --reload\t#防火墙重启  firewall-cmd --zone=public --list-ports\t#查看开放的端口  systemctl status firewalld\t#查看防火墙状态   云服务器开启15672和5672端口\n  登陆网页查看\n  helloworld 用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者。\n在下图中，“ P”是我们的生产者，“ C”是我们的消费者。中间的框是一个队列-RabbitMQ 代表使用者保留的消息缓冲区\n  pom依赖：\n \u0026lt;!--指定 jdk 编译版本--\u0026gt;  \u0026lt;build\u0026gt;  \u0026lt;plugins\u0026gt;  \u0026lt;plugin\u0026gt;  \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt;  \u0026lt;configuration\u0026gt;  \u0026lt;source\u0026gt;8\u0026lt;/source\u0026gt;  \u0026lt;target\u0026gt;8\u0026lt;/target\u0026gt;  \u0026lt;/configuration\u0026gt;  \u0026lt;/plugin\u0026gt;  \u0026lt;/plugins\u0026gt;  \u0026lt;/build\u0026gt;   \u0026lt;dependencies\u0026gt;  \u0026lt;!--rabbitmq 依赖客户端--\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.rabbitmq\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;amqp-client\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;5.8.0\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;!--操作文件流的一个依赖--\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;commons-io\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;/dependencies\u0026gt;   消息的生产者\npublic class Producer {   //队列名称常量  private final static String QUEUE_NAME = \u0026#34;hello\u0026#34;;   public static void main(String[] args) {  //创建一个连接工厂  ConnectionFactory connectionFactory = new ConnectionFactory();  connectionFactory.setHost(\u0026#34;101.35.136.150\u0026#34;);  connectionFactory.setUsername(\u0026#34;ytte\u0026#34;);  connectionFactory.setPassword(\u0026#34;ytte\u0026#34;);  //channel 实现了自动 close 接口 自动关闭 不需要显示关闭  try {  Connection connection = connectionFactory.newConnection();  Channel channel = connection.createChannel();  /** * 生成一个队列 * 1.队列名称 * 2.队列里面的消息是否持久化 默认消息存储在内存中 * 3.该队列是否只供一个消费者进行消费 是否进行共享 false 可以多个消费者消费 * （如果设置成了true）只有队列能接收到消息，消费者也接受不到消息 * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除 * 5.其他参数 */\t channel.queueDeclare(QUEUE_NAME, false, false, false, null);  String message = \u0026#34;hello world\u0026#34;;  /** * 发送一个消息 * 1.发送到那个交换机 * 2.路由的 key 是哪个 * 3.其他的参数信息 * 4.发送消息的消息体 */  channel.basicPublish(\u0026#34;\u0026#34;,QUEUE_NAME,null,message.getBytes());  System.out.println(\u0026#34;消息发送完毕\u0026#34;);   } catch (IOException | TimeoutException e) {  e.printStackTrace();  }   } }   消息的消费者\npublic class Consumer {   private final static String QUEUE_NAME = \u0026#34;hello\u0026#34;;    public static void main(String[] args) {  ConnectionFactory connectionFactory = new ConnectionFactory();  connectionFactory.setHost(\u0026#34;101.35.136.150\u0026#34;);  connectionFactory.setUsername(\u0026#34;ytte\u0026#34;);  connectionFactory.setPassword(\u0026#34;ytte\u0026#34;);  System.out.println(\u0026#34;等待接收消息。。。。。。。。\u0026#34;);   try {  Connection connection = connectionFactory.newConnection();  Channel channel = connection.createChannel();   //推送的消息如何进行消费的接口回调  DeliverCallback deliverCallback = (consumerTag, message) -\u0026gt; {  System.out.println(new String(message.getBody()));  };   //取消消费的一个回调接口 如在消费的时候队列被删除掉了  CancelCallback cancelCallback = consumerTag -\u0026gt; {  System.out.println(\u0026#34;消息消费被中断\u0026#34;);  };   /** * 消费者消费消息 * 1.消费哪个队列 * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答 * 3.消费者未成功消费的回调 */  channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);    } catch (IOException | TimeoutException e) {  e.printStackTrace();  }  } }   工作队列WorkQueue 工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。我们把任务发送到队列。==当有多个工作线程时，这些工作线程将一起处理这些任务。每个消息任务只能被完整的执行一次，如果一个消费者工作线程断开连接，他正在处理的消息任务会返回队列中，并由其他消费者工作线程来执行，所以说是只能被完整的执行一次。==\n轮循分发消息 即，如果存在两个消费者工作线程，消息会轮流分发给二者，你一个我一个。\n抽取工具类 重复代码太多抽取工具类\npublic class RabbitMqUtils {  //得到一个连接的 channel  public static Channel getChannel() throws Exception {  //创建一个连接工厂  ConnectionFactory factory = new ConnectionFactory();  factory.setHost(\u0026#34;101.35.136.150\u0026#34;);  factory.setUsername(\u0026#34;ytte\u0026#34;);  factory.setPassword(\u0026#34;ytte\u0026#34;);  Connection connection = factory.newConnection();   return connection.createChannel();  } } 消费者 不创建多个进行，使用idea自带的单一类可创建多实例。\n这样就可以多次启动WorkQueue1，且可更改其中的代码在启动（将C1 消费者启动改为C2 消费者启动）\npublic class WorkQueue1 {  private static final String QUEUE_NAME=\u0026#34;hello\u0026#34;;  public static void main(String[] args) throws Exception {   Channel channel = RabbitMqUtils.getChannel();  DeliverCallback deliverCallback=(consumerTag, delivery)-\u0026gt;{  String receivedMessage = new String(delivery.getBody());  System.out.println(\u0026#34;接收到消息:\u0026#34;+receivedMessage);  };   CancelCallback cancelCallback=(consumerTag)-\u0026gt;{  System.out.println(consumerTag+\u0026#34;消费者取消消费接口回调逻辑\u0026#34;);  };   System.out.println(\u0026#34;C1 消费者启动等待消费.................. \u0026#34;);  channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);  } } 生产者 public class Task01 {  private static final String QUEUE_NAME = \u0026#34;hello\u0026#34;;   public static void main(String[] args) throws Exception {  try (Channel channel = RabbitMqUtils.getChannel();) {   channel.queueDeclare(QUEUE_NAME, false, false, false, null);   //从控制台当中接受信息  Scanner scanner = new Scanner(System.in);  while (scanner.hasNext()) {  String message = scanner.next();  channel.basicPublish(\u0026#34;\u0026#34;, QUEUE_NAME, null, message.getBytes());  System.out.println(\u0026#34;发送消息完成:\u0026#34; + message);  }  }  } } 结果 消息应答 RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。\n为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。\n 自动应答 手动应答  自动应答 消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡，因为如果消息在接收到之前，消费者出现连接或者 channel 关闭，那么消息就丢失了；虽然这种模式消费者可以传递过载的消息，但是这样有可能使得消费者由于接收太多还来不及处理的消息，造成消息的积压，内存耗尽，最终这些消费者线程被操作系统杀死。所以自动应答仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。\n一般不采用自动应答，采用手动应答。\n手动应答 常用方法：\n  Channel.basicAck(用于肯定确认)\nRabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了\n  Channel.basicNack(用于否定确认)\n  Channel.basicReject(用于否定确认)\n与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了\n  手动应答的好处是可以批量应答并且减少网络拥堵\n批量应答即，消息在消费者的对应的信道中，还未被接受也会被消费者回复收到应答给RabbitMq。\n消息自动重新入队 如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。\n消息手动应答代码 生产者：\npublic class Task02 {   private static final String TASK_QUEUE_NAME = \u0026#34;ack_queue\u0026#34;;   public static void main(String[] argv) throws Exception {  try (Channel channel = RabbitMqUtils.getChannel()) {  channel.queueDeclare(TASK_QUEUE_NAME, false, false, false, null);  Scanner sc = new Scanner(System.in);  System.out.println(\u0026#34;请输入信息\u0026#34;);  while (sc.hasNext()) {  String message = sc.nextLine();  channel.basicPublish(\u0026#34;\u0026#34;, TASK_QUEUE_NAME, null, message.getBytes(\u0026#34;UTF-8\u0026#34;));  System.out.println(\u0026#34;生产者发出消息\u0026#34; + message);  }  }  } } 消费者1：\npublic class Work01 {  private static final String ACK_QUEUE_NAME = \u0026#34;ack_queue\u0026#34;;   public static void main(String[] args) throws Exception {  Channel channel = RabbitMqUtils.getChannel();  System.out.println(\u0026#34;C1 等待接收消息处理时间较短\u0026#34;);   //消息消费的时候如何处理消息  DeliverCallback deliverCallback = (consumerTag, delivery)-\u0026gt; {  String message = new String(delivery.getBody()); \t// 睡眠1s  SleepUtils.sleep(1);  System.out.println(\u0026#34;接收到消息:\u0026#34; + message);  /** * 1.消息标记 tag * 2.是否批量应答未应答消息 */  channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);  };   //采用手动应答  channel.basicConsume(ACK_QUEUE_NAME, false, deliverCallback, (consumerTag) -\u0026gt; {  System.out.println(consumerTag + \u0026#34;消费者取消消费接口回调逻辑\u0026#34;);  });   } } 消费者2：\npublic class Work02 {  private static final String ACK_QUEUE_NAME = \u0026#34;ack_queue\u0026#34;;   public static void main(String[] args) throws Exception {  Channel channel = RabbitMqUtils.getChannel();  System.out.println(\u0026#34;C2 等待接收消息处理时间较短\u0026#34;);   //消息消费的时候如何处理消息  DeliverCallback deliverCallback = (consumerTag, delivery)-\u0026gt; {  String message = new String(delivery.getBody()); \t//睡眠20s表示正在处理还多的代码  SleepUtils.sleep(20);  System.out.println(\u0026#34;接收到消息:\u0026#34; + message);  /** * 1.消息标记 tag * 2.是否批量应答未应答消息 */  channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);  };   //采用手动应答  channel.basicConsume(ACK_QUEUE_NAME, false, deliverCallback, (consumerTag) -\u0026gt; {  System.out.println(consumerTag + \u0026#34;消费者取消消费接口回调逻辑\u0026#34;);  });   } } SleepUtils：\npublic class SleepUtils {  public static void sleep(int second) {  try {  Thread.sleep(1000 * second);  } catch (InterruptedException _ignored) {  Thread.currentThread().interrupt();  }  } } 效果 生产者发送1~9，消费者工作线程轮流接受消息，1和2中平均接收到消息，但是由于1中睡眠1s，2中睡眠20s，所以可以看出2对应的信道里还屯留了几条消息（不知道是否可以这样说），而1中马上就处理完了。这时候我们关闭2进程，这就导致没有处理消息，或者没有处理完成，也就没有发送应答，Rabbit会检查到没有接收到应答消息，将未处理的消息交个能处理它们的1中，1继续处理消息。\n 2022-3-30\nRabbitMQ 持久化 保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。我们需要==将队列和消息都标记为持久化==。\n队列如何实现持久化 ==队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化==\n注意：之前声明的不是持久化的队列，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误\n控制台中持久化与非持久化队列的 UI 显示区：\n现在即使重启 rabbitmq 队列也依然存在。\n消息实现持久化 ==消息持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN添加这个属性。==\nchannel.basicPublish(\u0026#34;\u0026#34;, TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(\u0026#34;UTF-8\u0026#34;)); 将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。后面的发布确认章节，会细说如何让生产者收到确认的消息。（生产者收到确认消息，即消息已经 到达队列并且持久化了）\n不公平分发 之前的轮流分发在某种场景下不是好的方法，比方说有两个消费者在处理任务，二者处理速度不同，任务是平分的，就会造成一方消费者空闲 一方忙活。不能够最大化利用现有资源。\n为了避免这种情况，我们可以设置参数\nchannel.basicQos(1) 在web页面中可以看到Prefetch count 为1，即上面设置的参数为1\n如果我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。\n预取值 ==就相当于channel中有个缓冲区，缓冲区的大小（所能暂存消息的数量）可以通过使用 basic.Qos “预取计数”值来设置。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ 将停止在通道上传递更多消息。==\n例如，假设在通道上有未确认的消息 5、6、7，8，预取值设置为 4，此时RabbitMQ 将不会在该通道上再传递任何 消息。若 排在前面的消息 刚刚被确认 ACK，RabbitMQ 才会再发送消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。\n通常，增加预取值，来提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。\n发布确认 原理 生产者将信道设置成 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，消息被投递到所有匹配的队列之后，mq就会发送一个确认信息给生产者(包含消息的唯一 ID)，告诉生产者消息已经正确到达目的队列了。\n如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，mq回传给生产者的确认消息中的delivery-tag 属性，包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的multiple 属性，表示到这个序列号之前的所有消息都已经得到了处理。\nconfirm 模式最大的好处在于可以是异步的，发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。\n 2022-3-31\n开启发布确认的方法 开启需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法\n单个确认发布 这是一种简单的确认方式，==同步确认发布的方式==，发布一个消息之后只有它被确认发布，后续的消息才能继续发布，waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回(返回布尔值)，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。\n缺点：==发布速度特别的慢==，因为如果==没有收到确认发布的消息就会阻塞所有后续消息==的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。适用简单和小应用程序。\npublic class e111 {  private static final int MESSAGE_COUNT = 1000;   public static void main(String[] args) throws Exception {  publishMessageIndividually();  }   public static void publishMessageIndividually() throws Exception {  try (Channel channel = RabbitMqUtils.getChannel()) {  //产生随机的队列名  String queueName = UUID.randomUUID().toString();  //声明队列  channel.queueDeclare(queueName, false, false, false, null);  //开启发布确认  channel.confirmSelect();  long begin = System.currentTimeMillis();  //循环1000 发送消息，收到确认信息再发送消息  for (int i = 0; i \u0026lt; MESSAGE_COUNT; i++) {  String message = i + \u0026#34;\u0026#34;;  channel.basicPublish(\u0026#34;\u0026#34;, queueName, null, message.getBytes());  //等待接受确认信息 服务端返回 false 或超时时间内未返回，生产者可以消息重发  boolean flag = channel.waitForConfirms();  if (flag) {  System.out.println(\u0026#34;消息发送成功\u0026#34;);  }  }  long end = System.currentTimeMillis();  System.out.println(\u0026#34;发布\u0026#34; + MESSAGE_COUNT + \u0026#34;个单独确认消息,耗时\u0026#34; + (end - begin) + \u0026#34;ms\u0026#34;);  }  } } //结果 发布1000个单独确认消息,耗时15837ms 批量确认发布 与单个等待确认消息相比，==先发布一批消息然后一起确认==可以极大地提高吞吐量，==缺点：当发生故障导致发布出现问题时，不知道是哪个消息出现问题==，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是==同步的==，也一样阻塞消息的发布。\npublic static void BatchPublishMessage() throws Exception {  try (Channel channel = RabbitMqUtils.getChannel()) {  String queueName = UUID.randomUUID().toString();  channel.queueDeclare(queueName, false, false, false, null);  channel.confirmSelect();  long start = System.currentTimeMillis();   for (int i = 0; i \u0026lt; MESSAGE_COUNT; i++) {  String message = i + \u0026#34;\u0026#34;;  channel.basicPublish(\u0026#34;\u0026#34;, queueName, null, message.getBytes());   if (MESSAGE_COUNT % (i+1) == 0) {  boolean b = channel.waitForConfirms();  if (b) {  System.out.println(\u0026#34;消息发送成功\u0026#34;);  }  }  }  long end = System.currentTimeMillis();  System.out.println(\u0026#34;发布\u0026#34; + MESSAGE_COUNT + \u0026#34;个单独确认消息,耗时\u0026#34; + (end - start) + \u0026#34;ms\u0026#34;);  } } //结果 发布1000个单独确认消息,耗时344ms 异步确认发布 public static void AsynchronousPublishMessage() throws Exception {  try (Channel channel = RabbitMqUtils.getChannel()) {  String queueName = UUID.randomUUID().toString();  //开启发布确认  channel.confirmSelect();  /** * 线程安全有序的一个哈希表，适用于高并发的情况 * 1.将序号与消息进行关联 * 2.批量删除条目 只要给到序列号 * 3.支持并发访问 */  ConcurrentSkipListMap\u0026lt;Long, String\u0026gt; outstandingConfirms = new ConcurrentSkipListMap\u0026lt;\u0026gt;();  /** * 确认收到消息的一个回调 * 1.消息序列号 * 2.multiple * true 未能收到当前序号的确认消息 * false 确认收到当前序号消息 */  ConfirmCallback ackCallback = (sequenceNumber, multiple) -\u0026gt; {  //只清除当前序列号的消息  if (!multiple) {  String message = outstandingConfirms.get(sequenceNumber);  System.out.println(\u0026#34;发布的消息\u0026#34; + message + \u0026#34;被确认\u0026#34;);  outstandingConfirms.remove(sequenceNumber);  }  };  ConfirmCallback nackCallback = (sequenceNumber, multiple) -\u0026gt; {  if (multiple) {  String message = outstandingConfirms.get(sequenceNumber);  System.out.println(\u0026#34;发布的消息\u0026#34;+message+\u0026#34;未被确认，序列号\u0026#34;+sequenceNumber);  }  };   /** * 添加一个异步确认的监听器 * 1.确认收到消息的回调 * 2.未收到消息的回调 */  channel.addConfirmListener(ackCallback, nackCallback);   long begin = System.currentTimeMillis();   for (int i = 0; i \u0026lt; MESSAGE_COUNT; i++) {  String message = \u0026#34;消息\u0026#34; + i;  /** * channel.getNextPublishSeqNo()获取下一个消息的序列号 * 通过序列号与消息体进行一个关联 * 接收到的确认的，未确认的消息都收集到map中 */  outstandingConfirms.put(channel.getNextPublishSeqNo(), message);  channel.basicPublish(\u0026#34;\u0026#34;, queueName, null, message.getBytes());  System.out.println(\u0026#34;消息发送成功\u0026#34;);  }   long end = System.currentTimeMillis();  System.out.println(\u0026#34;发布\u0026#34; + MESSAGE_COUNT + \u0026#34;个异步确认消息,耗时\u0026#34; + (end - begin) + \u0026#34;ms\u0026#34;);  SleepUtils.sleep(20);  } }  //结果 发布1000个异步确认消息,耗时62ms 如何处理异步未确认消息 把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。\n对比   发布1000个单独确认消息,耗时15837ms\n  发布1000个单独确认消息,耗时344ms\n  发布1000个异步确认消息,耗时62ms\n  交换机 在之前，将做一些完全不同的信息传达给多个消费者的模式称为 ”发布/订阅”。为了说明这种模式，我们将构建一个简单的日志系统。由两个程序组成：第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者。todo（解释的不清晰）。\n实际上，生产者只能将消息发送到交换机(exchange)，交换机工作的内容是，一方面接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中（这就是发布订阅模式（类似广播）），还是说应该丢弃它们。这些都由交换机的类型来决定。\nExchanges 的类型  直接(direct) 主题(topic) 标题(headers) 扇出(fanout)  默认交换机 填写“”即表示使用默认的交换机。消息能路由发送到队列中其实是由routingKey(bindingkey)绑定 key 指定的\n临时队列 之前的章节我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。队列的名称我们来说至关重要-我们需要指定我们的消费者去消费哪个队列的消息。每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。创建临时队列的方式如下:\nString queueName = channel.queueDeclare().getQueue(); 创建出来之后长成这样:\n绑定(bindings) binding 是 exchange 和 queue 之间的桥梁，表示exchange 和队列进行了绑定关系。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定\nFanout Fanout 是将接收到的所有消息==广播到它知==道的所有队列中。系统中默认有些 exchange 类型。\nLogs 和临时队列的绑定关系如下图:\n总结 消息队列的使用场景\n分布式事务 重复消费、消息丢失、顺序消费 可用性  搞定！\n人生无常，大肠包小肠！\n继续学习吧！\n","id":10,"section":"posts","summary":"","tags":["Rabbit Mq"],"title":"Rabbit Mq","uri":"https://gb.ytte.top/2022/03/22/rabbit-mq/","year":"2022"},{"content":"基础篇 安装  官方网站\n 基本安装   确定你是CentOS7及以上版本\ncat /etc/redhat-release   卸载旧版本\n  yum安装gcc相关\nyum -y install gcc yum -y install gcc-c++   安装需要的软件包\nyum install -y yum-utils   设置stable镜像仓库\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo   更新yum软件包索引\nyum makecache fast   安装DOCKER CE\nyum -y install docker-ce docker-ce-cli containerd.io   启动docker\nsystemctl start docker   测试\ndocker --version   卸载\nsystemctl stop docker yum remove docker-ce docker-ce-cli containerd.io yum remove docker-ce docker-ce-cli containerd.io yum remove docker-ce docker-ce-cli containerd.io   阿里云镜像加速   https://promotion.aliyun.com/ntms/act/kubernetes.html   注册一个属于自己的阿里云账户(可复用淘宝账号)\n  获得加速器地址连接\n 登陆阿里云开发者平台 点击控制台 选择容器镜像服务 获取加速器地址    粘贴脚本直接运行\nmkdir -p /etc/docker  tee /etc/docker/daemon.json \u0026lt;\u0026lt;-\u0026#39;EOF\u0026#39; { \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://aa25jngu.mirror.aliyuncs.com\u0026#34;] } EOF   重启服务器\nsystemctl daemon-reload systemctl restart docker    搞定！\n人生无常，大肠包小肠！\n继续学习吧！\n","id":11,"section":"posts","summary":"","tags":["Docker"],"title":"Docker","uri":"https://gb.ytte.top/2022/03/22/docker/","year":"2022"},{"content":"前言 本文讲述hexo和hugo搭建静态个人博客，配置，部署到gitee和github，给github的仓库配置自定义访问域名。首先会最简单的方式实现功能，所以文章分为基本篇和进阶篇。\n基础篇 快速实现基本功能。两种实现方式：\nhexo：js写的，页面加载速度不hugo；但是用的人多，中文好看的主题多。\nhugo：go写的，用的人少，如果不使用本文使用的主题，就需要自己去多研究其他主题怎么更改配置；但是页面加载速度快。\n基本环境：\n  安装Git\n参考2\n  详细的学习网站：\n参考3\n    安装Node.js\n参考4\n  方式一：hexo hexo中文文档 ：文档 | Hexo\n 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub hexo配置远程仓库GitHub 发布文章 配置文件 主题  安装Hexo   创建一个文件夹blog（命名随意），在这个文件夹下直接右键打开git bash，输入如下代码安装hexo\nnpm install -g hexo-cli   安装完成后 hexo -v查看一下版本\n  初始化hexo\nhexo init myblog 然后\ncd myblog //进入这个myblog文件夹 npm install   install完成后文件夹目录如下\n node_modules: hexo依赖包 public：存放生成的页面（执行相关命令后md文件会被转换成html文件自动放在这里） scaffolds：生成文章的一些模板（之后创建md文章的时候就会默认使用这里的模板） source：用来存放你的文章 （自己写的文章全部放在这里，md文件放在post文件夹里） themes：主题文件 _config.yml: 博客的配置文件    本地启动看看是否安装及配置成功\n hexo g 是用来将md文件生成html页面自动放入public的。 hexo server是用来本地启动的  hexo new hexo g hexo server  启动完成会提示浏览器访问 localhost:4000。 出现一下图片样式，即表示本地启动配置成功。   使用ctrl+c可以把服务关掉    GitHub创建个人仓库 IPHP  在GitHub.com中看到一个New repository，新建仓库 创建一个和你用户名相同的仓库，后面加.github.io，只有这样，部署到GitHub page的时候，才会被识别，才能通过xxxx.github.io访问到博客，其中xxx就是你注册GitHub的用户名。 仓库类型选择【public】，勾选【Initialize this repository with a README】 点击【create repository】  生成SSH添加到GitHub 传送——Git多个ssh - YTTE Site)中的本地同步到一个git仓库 9~11步骤\nhexo配置远程仓库GitHub   打开根目录下的配置文件 _config.yml，翻到最后，修改一下代码。这里使用ssh方式push（如果没有配置ssh密钥，传送\ndeploy:\rtype: git\rrepo: github: git@github.com/YourgithubName/YourgithubName.github.io.git\rbranch: master   根目录下右键git bash 安装deploy-git 部署的命令，将git命令简化。等待安装完成。\nnpm install hexo-deployer-git --save   新建文章：layout一般选择post及文章 ，E.g. (比如) hexo new post 好好学习，然后会自动把 .md文章发送到根目录/source/_post中\nhexo new [layout] \u0026lt;title\u0026gt;   发布文章   使用hexo的命令来clean清理上一次生成的静态页面（也可以不清理），generate生成静态文章，deploy部署\nhexo clean hexo g hexo d   如图表示成功。通过http://yourgithubname.github.io即可访问你自己的博客。\n  配置文件 根目录下的_config.yml，Ctrl + F 查询填写，即可查看必须要更改的地方\n# Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/  #Ctrl + F 查询填写，即可查看必须要更改的地方  # Site title: YTTE  # 填写 subtitle: \u0026#39;Personal Blogs\u0026#39; # 填写 description: \u0026#39;\u0026#39; # 填写 keywords: java  # 填写 author: JX  # 填写 language: en timezone: \u0026#39;Asia/Shanghai\u0026#39; # 填写  # URL ## Set your site url here. For example, if you use GitHub Page, set url as \u0026#39;https://username.github.io/project\u0026#39; url: https://gb.ytte.top  # 填写 域名或者https://YourgithubName.github.io permalink: :year/:month/:day/:title/ permalink_defaults: pretty_urls:  trailing_index: true # Set to false to remove trailing \u0026#39;index.html\u0026#39; from permalinks  trailing_html: true # Set to false to remove trailing \u0026#39;.html\u0026#39; from permalinks  # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render:  # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: \u0026#39;\u0026#39; filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight:  enable: true  line_number: true  auto_detect: false  tab_replace: \u0026#39;\u0026#39;  wrap: true  hljs: false prismjs:  enable: false  preprocess: true  line_number: true  tab_replace: \u0026#39;\u0026#39;  # Home page setting # path: Root path for your blogs index page. (default = \u0026#39;\u0026#39;) # per_page: Posts displayed per page. (0 = disable pagination) # order_by: Posts order. (Order by date descending by default) index_generator:  path: \u0026#39;\u0026#39;  per_page: 10  order_by: -date  # Category \u0026amp; Tag default_category: uncategorized category_map: tag_map:  # Metadata elements ## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta meta_generator: true  # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss ## updated_option supports \u0026#39;mtime\u0026#39;, \u0026#39;date\u0026#39;, \u0026#39;empty\u0026#39; updated_option: \u0026#39;mtime\u0026#39;  # Pagination ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page  # Include / Exclude file(s) ## include:/exclude: options only apply to the \u0026#39;source/\u0026#39; folder include: exclude: ignore:  # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: pure  # 填写选择跟目录下theme文件夹里的主题的文件夹 名称   # Deployment ## Docs: https://hexo.io/docs/one-command-deployment deploy:  type: \u0026#39;git\u0026#39; # 填写  repo:  github: git@github.com:YourgithubName/YourgithubName.github.io.git  # 填写  branch: master  # 填写 官方文档配置 | Hexo\n   参数 描述     title 网站标题   subtitle 网站副标题   description 网站描述   author 您的名字   language 网站使用的语言   timezone 网站时区。\u0026lsquo;Asia/Shanghai\u0026rsquo;   url 网址（域名或者https://YourgithubName.github.io）   root 网站根目录   permalink 文章的 永久链接 格式    比如新建一个文章叫test.md，那么这个时候他自动生成的地址就是http://yoursite.com/2022/01/01/test，或者http://YourgithubName.github.io/2022/01/01/test。\n打开 根目录/scaffolds/post.md 在里面可以设置 每次new 的post 的模板。\ntitle: {{ title }} date: {{ date }} tags: {{ tags }} categories: {{categories}} toc: true  #以上代码放在yaml font matter（在typora中右键-插入当中）  \u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;no-referrer\u0026#34;/\u0026gt;  \u0026lt;!--more--\u0026gt; 更换主题 官方给的主题：Themes | Hexo\n这里本文采用pure主题Hexo theme pure(github.com)\n  在根目录下使用git bash 然后git clone 主题的github。例如pure主题的，并在最后加上theme/pure，表示在clone到theme下并重命名为pure。\ngit clone https://github.com/cofess/hexo-theme-pure.git theme/pure 主题目录：（不同主题可能不同）（本人后端，对前端不是很懂）\n _source： languages： layout：主题布局样式 ，调用函数等 screenshot： scripts： source：你的头像之类的公共资源，js，css _config.yml：主题的配置文件    每个主题都有不同的要求，有点需要你把文件夹复制到根目录，有的只需要你在根目录下_config.yml配置文件把theme 改为XXX。\n所以使用主题，需要仔细阅读它github的README.md；一般作者都会介绍如何使用。\n  pure中要求：\n 把本hexo根目录下_config.yml配置文件把theme 改为pure。（切记不是theme/pure/下的config.yml）。 根目录\\themes\\pure\\_source下（是_source 不是source）所有文件夹复制到根目录下的source文件夹。 根目录\\themes\\pure\\_config.yml中可以更改一些自己相关的信息，比如点击头像跳转自己的github。等等。  hexo clean hexo g hexo s # 本地启动 本地启动查看是否设置成功。\n然后推送到github。\nhexo clean hexo g hexo d http://YourgithubName.github.io\n  方式二：hugo 实现过程与hexo很类似\nhugo中文文档 ：Hugo中文文档 (gohugo.org)\nhugo github ：hugo: (github.com)\n 安装hugo GitHub创建个人仓库 生成SSH添加到GitHub 将hexo部署到GitHub发布文章 配置文件 主题  安装hugo 安装地址Releases · gohugoio/hugo (github.com)\n  下载解压带extend的压缩包（很多主题都采用这个扩展版hugo）。\n  解压完成会得到如下几个文件（一下目录以**F:\\hugo\\bin**为例）\n  将F:\\hugo\\bin加到path变量中，注意两点: (1) 是**path**，不是CLASSPATH，要区分下 (2) 路径后面记得加英文分号 ;以上设置好后，就可以在cmd中查看是否安装成功。\n  执行命令：hugo version HugoStatic Site Generator v0.57.2-A849CB2D windows/amd64 BuildDate: 2019-08-17T17:54:13Z　显示该条即表示成功\n  生成站点  hugo new site文件名称 (如blog) 。执行后，在F:\\hugo\\bin目录下就会生成一个 名叫blog的站点文件夹 站点文件夹目录结构：  archetypes　(存放default.md，头文件格式，每次新建文章默认显示的头部信息在此修改) content (存放博客文章，markdown格式文件) data (存放自定义或者导入的模板) layouts (存放网站的数据模板) static (存放图片、css、js等静态资源) themes (存放主题文件，每个主题都是一个独立的文件夹) config.toml (网站配置文件)    创建文章   进入站点根目录blog下，执行命令：\nhugo new post/test.md\n  执行后，会自动在content/post下生成 test.md文件，打开可编辑内容，ps.文件头部的draft要改为false，这样部署后才能看到文章。\n当前网站是没有任何内容的，需要下载个主题。\n下载主题   本文使用pure主题 hugo-theme-pure/README-ZH.md (github.com)\n  hugo主题合集Hugo Themes (gohugo.io)\n  进入站点的themes目录\ngit clone https://github.com/xiaoheiAh/hugo-theme-pure.git themes/pure 此时可回到站点目录下打开config.toml配置指定主题。如theme = \u0026ldquo;pure\u0026rdquo; 没有theme参数就自己写上\n  将themes\\pure\\exampleSite选的content文件夹复制到站点目录下。\n  在archetypes\\default.md中更改\ntitle: \u0026#34;{{ .Name | humanize | title }}\u0026#34; date: \u0026#34;{{ .Date }}\u0026#34; tags:  - \u0026#34;java\u0026#34; categories:  - \u0026#34;java\u0026#34; toc: true # bookComments: false # bookSearchExclude: false  #以上代码放在yaml font matter（在typora中右键-插入当中）  \u0026lt;!--more--\u0026gt;   本地启动 站点根目录下，执行命令：\nhugo server 执行后会显示\n \u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;此处省略上方信息\nWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop\n 可访问：http://localhost:1313/ 查看效果。 Ctrl+C 结束本地运行。\n部署github pages上   登录后，点击右上角，出现下拉菜单，点击 Your repositories 进入页面\n  点击new新建仓库（如果操作过上述hexo版本，可以不新建，毕竟仓库名为yourgithubname.github.io的只能有一个）。\n  进入 Creat a new repository 页面。\n图中的 yourname 要换成自己的github的用户名，即上图中Owner显示的用户名。最后点击Creat repository即完成\n  站点目录**config.toml中baseURL**要换成自己建立的仓库，如baseURL = \u0026ldquo;https://yourname.github.io/\u0026quot;\n  进入站点根目录下，执行：\nhugo   执行后，站点根目录下会生成一个 public 文件夹，该文件下的内容即Hugo生成的整个静态网站。每次更新内容后，将 pubilc 目录里所有文件 push到GitHub即可。\n  首次使用的时候要执行以下命令：\n  注意：与hexo不同的是\n  hexo在站点目录（根目录）下执行代码。\n  hugo生成静态页面的代码hugo在站点目录下执行，git命令在public 目录下执行。\n    cd public   使用ssh连接远程仓库：\n传送——git_ssh和多个ssh - YTTE Site中的本地同步到一个git仓库 9~11步骤\n即\nssh-keygen -t rsa -C “xxx@qq.com” # 将C:\\Users\\Administrator\\ .ssh\\id_rsa.pub 里面的内容复制到github右上角头像里下方设置里ssh里面。 ssh -T git@github.com #测试设置ssh是否成功   git：(在public文件夹中)\ngit init git pull git@github.com:yourgithubname/yourgithubname.github.io.git git add . git commit -m \u0026#34;init\u0026#34; git remote add origin git@github.com:yourgithubname/yourgithubname.github.io.git git push -u origin master   以后每次站点目录下执行 hugo 命令后，再到public下执行推送命令：\ngit add . git commit -m \u0026#34;xxx\u0026#34; git push -u origin master (此处较易出错，error了就百度吧，比较经常发送的是连接失败，多试几次，还是不行，问题可能千奇百怪) 之后就可以到GitHub上看提交到分支的内容，也可访问 http://YourgithubName.github.io看页面了。\n    配置文件 #Ctrl + F 查询 更改 ，即可查看必须要更改的地方\n#Ctrl + F 查询 更改 ，即可查看必须要更改的地方  baseURL: https://YourgithubName.github.io  #更改 theme: pure #更改 title: YTTE Site\t#更改 copyright: CC BY 4.0 CN defaultContentLanguage: en  # en/zh/... footnoteReturnLinkContents: ↩ hasCJKLanguage: true paginate: 8 enableEmoji: true PygmentsCodeFences: true googleAnalytics: \u0026#34;\u0026#34; # UA-XXXXXXXX-X  permalinks:  posts: /:year/:month/:day/:title/  taxonomies:  category : categories  tag : tags  series : series outputFormats: # use for search. recommend not to modify   SearchIndex:  mediaType: \u0026#34;application/json\u0026#34;  baseName: \u0026#34;searchindex\u0026#34;  isPlainText: true  notAlternative: true  outputs:  home: [\u0026#34;HTML\u0026#34;,\u0026#34;RSS\u0026#34;,\u0026#34;SearchIndex\u0026#34;] # recommend not to modify # sitemap sitemap:  changefreq: monthly  filename: sitemap.xml  priority: 0.5  menu:  main:  - identifier: home  name: Home  title: Home  url: /  weight: 1   - identifier: archives  name: Archives  title: Archives  url: /posts/  weight: 2   - identifier: categories  name: Categories  title: Categories  url: /categories/  weight: 3   - identifier: tags  name: Tags  title: Tags  url: /tags/  weight: 4   - identifier: about  name: About  title: About  url: /about/  weight: 5   params:  since: 2022  dateFormatToUse: \u0026#34;2006-01-02\u0026#34;  enablePostCopyright: true  copyright_link: http://creativecommons.org/licenses/by/4.0/deed.zh  # the directory under content folder that you want to render  mainSections: [\u0026#34;posts\u0026#34;]  # Enable/Disable menu icons  # Icon Reference: http://blog.cofess.com/hexo-theme-pure/iconfont/demo_fontclass.html  enableMathJax: true #Enable mathjax support, to use mathematical notations  highlightjs:  langs: [\u0026#34;python\u0026#34;, \u0026#34;javascript\u0026#34;] # refer to http://staticfile.org/, search highlight.js, already have highlight.min.js   tag_cloud:  min: 8  max: 20  # Allows you to specify an override stylesheet  # put custom.css in $hugo_root_dir/static/  # customCSS: css/custom.css   menuIcons:  enable: true # 是否启用导航菜单图标  home: icon-home-fill  archives: icon-archives-fill  categories: icon-folder  tags: icon-tags  repository: icon-project  books: icon-book-fill  links: icon-friendship  about: icon-cup-fill   # profile  profile:  enabled: true # Whether to show profile bar  avatar: avatar.png  gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden  author: YTTE\t#更改\t  author_title: 努力奋斗，不负韶华。\t#更改\t  author_description: Good Good Study, Day Day Up~\t#更改\t  location: Anhui, China\t#更改\t  follow: https://github.com/yougithubname\t#更改\t  # Social Links  social:  links:  github: https://github.com/yougithubname\t#更改  # weibo: http://weibo.com/{yourid}  # twitter: https://twitter.com/  # facebook: /  rss: /index.xml  link_tooltip: false # enable the social link tooltip, options: true, false  # Site  site:  logo:  enabled: true  width: 40  height: 40  url: favicon.ico  title: YTTE-blogs # 页面title\t#更改  favicon: favicon.ico  board: \u0026lt;p\u0026gt; 人生无常，大肠包小肠~\u0026lt;/p\u0026gt; # 公告牌\t更改   # Share  # weibo,qq,qzone,wechat,tencent,douban,diandian,facebook,twitter,google,linkedin  share:  enable: true # 是否启用分享  sites: weibo,qq,wechat,facebook,twitter # PC端显示的分享图标  mobile_sites: weibo,qq,qzone # 移动端显示的分享图标   # Comment  comment:  type: # type disqus/gitalk/valine 启用哪种评论系统  disqus: your_disqus_name # enter disqus shortname here  gitalk: # gitalk. https://gitalk.github.io/  owner: #必须. GitHub repository 所有者，可以是个人或者组织。  admin: #必须. GitHub repository 的所有者和合作者 (对这个 repository 有写权限的用户)。  repo: #必须. GitHub repository.  ClientID: #必须. GitHub Application Client ID.  ClientSecret: #必须. GitHub Application Client Secret.  valine: # Valine. https://valine.js.org  appid: # your leancloud application appid  appkey: # your leancloud application appkey  notify: # mail notifier , https://github.com/xCss/Valine/wiki  verify: # Verification code  placeholder: enjoy~ # comment box placeholder  avatar: mm # gravatar style  meta: nick,mail # custom comment header  pageSize: 10 # pagination size  visitor: false # Article reading statistic https://valine.js.org/visitor.html   # Donate  donate:  enable: false  # 微信打赏  wechatpay:  qrcode: donate/wechatpayimg.png  title: 微信支付  # 支付宝打赏  alipay:  qrcode: donate/alipayimg.png  title: 支付宝   # PV  pv:  busuanzi:  enable: false # 不蒜子统计  leancloud:  enable: false # leancloud统计  app_id: # leancloud \u0026lt;AppID\u0026gt;  app_key: # leancloud \u0026lt;AppKey\u0026gt;   # wordcount  postCount:  enable: true  wordcount: true # 文章字数统计  min2read: true # read time 阅读时长预计   # config  config:  skin: theme-black # theme color default is white. other type [theme-black,theme-blue,theme-green,theme-purple]  layout: main-center # main-left main-center main-right  excerpt_link: Read More  toc: true   # Sidebar  sidebar: right   # Search  search:  enable: true # enable search. thanks for https://raw.githubusercontent.com/ppoffice/hexo-theme-icarus/master/source/js/insight.js   # Sidebar only the following widgets. you can remove any you don\u0026#39;t like it.  widgets:  - board  - tag_cloud  - category  - recent_posts 扩展篇 鉴于扩展篇中需要其他知识的支持，所以提前把链接放出来：\n 一级域名 - YTTE Site\n二级域名 - YTTE Site\nHttps - YTTE Site\nGit多个ssh - YTTE Site\nGitee自动更新部署的脚本 - YTTE Site\n 继续更新中。。。。。。。。。。。。。。。\n 参考 ：\n hexo史上最全搭建教程_zjufangzh-CSDN_hexo Git下载安装及设置详细教程-CSDN博客_git下载 Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com) NodeJ 安装及环境配置_DistanceZK的博客-CSDN博客 windows+hugo+github搭建个人博客 - nira - 博客园 (cnblogs.com)  搞定！\n人生无常，大肠包小肠！\n继续学习吧！\n","id":12,"section":"posts","summary":"","tags":["bolg","hugo","hexo"],"title":"静态个人博客创建配置部署","uri":"https://gb.ytte.top/2022/03/21/%E9%9D%99%E6%80%81%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2/","year":"2022"},{"content":"Gitee自动更新部署的脚本使用 gitee 容量比github大，单存在不能绑定自定义域名，以及不能自动更新部署的问题。\n自动更新脚本  参考：自动更新gitee pages，_永远不会太晚的博客-CSDN博客\n 前置：\n  node\n  puppeteer\n    需要node环境\nNodeJS 安装及环境配置\n  新建建一个文件夹 用来安装 puppeteer\n  在新建的文件夹内 打开cmd输入下方代码后，不要关闭cmd窗口。\nnpm init -y npm i -s puppeteer@1.8.0 `\n  安装好后会出现package.json，打开全部替换为如下代码\n{  \u0026#34;name\u0026#34;: \u0026#34;puppeteer\u0026#34;,  \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;,  \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;,  \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;,  \u0026#34;scripts\u0026#34;: {  \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;  },  \u0026#34;keywords\u0026#34;: [],  \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;,  \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;,  \u0026#34;dependencies\u0026#34;: {  \u0026#34;puppeteer\u0026#34;: \u0026#34;^1.8.0\u0026#34;  },  \u0026#34;name\u0026#34;: \u0026#34;git-update-pages\u0026#34;,  \u0026#34;bin\u0026#34;: {  \u0026#34;git-update-pages\u0026#34;: \u0026#34;index.js\u0026#34;  } }   新建index.js，填入一下代码.其中 17、22、31 行需要更改为自己的信息。更改完成后保存。\n#! /usr/bin/env node // 此处安装版本为 1.8.0 const puppeteer = require(\u0026#34;puppeteer\u0026#34;)  // 主要原理在于使用xpath获取html页面dom元素，脚本代替小手自动触发点击事件 async function giteeUpdate() {  const browser = await puppeteer.launch({  // 此处可以使用 false 有头模式进行调试, 调试完注释即可  headless: false  })  const page = await browser.newPage()  await page.goto(\u0026#34;https://gitee.com/login\u0026#34;)   // 1. 获取账号input，自动输入  let accountElements = await page.$x(\u0026#39;//*[@id=\u0026#34;user_login\u0026#34;]\u0026#39;)  // 🚨需要设置为自己的gitee账户🚨  await accountElements[0].type(\u0026#34;自己的gitee账户\u0026#34;)   // 2. 获取密码input，自动输入  let pwdElements = await page.$x(\u0026#39;//*[@id=\u0026#34;user_password\u0026#34;]\u0026#39;)  // 🚨需要设置自己的gitee密码🚨  await pwdElements[0].type(\u0026#34;自己的gitee密码\u0026#34;)   // 3. 获取登录按钮，触发点击事件  let loginButtons = await page.$x(\u0026#39;//*[@class=\u0026#34;git-login-form-fields\u0026#34;]/div[4]/input\u0026#39;)  await loginButtons[0].click()   // 4. 等待登录成功  await page.waitFor(1000)  🚨需要设置自己的gitee pages页面🚨  await page.goto(\u0026#34;https://gitee.com/你的用户名/你的仓库名/pages\u0026#34;)   // 5. 监听触发的确认弹框，并点击确认  await page.on(\u0026#34;dialog\u0026#34;, async dialog =\u0026gt; {  console.log(\u0026#34;确认更新\u0026#34;)  dialog.accept()  })   // 6. 点击更新按钮，并弹出确认弹窗  let updateButtons = await page.$x(\u0026#39;//*[@id=\u0026#34;pages-branch\u0026#34;]/div[6]\u0026#39;)  console.log(1111, updateButtons)  await updateButtons[0].click()   //7. 轮询并确认是否更新完毕  while (true) {  await page.waitFor(2000)  try {  // 获取更新状态标签  deploying = await page.$x(\u0026#39;//*[@id=\u0026#34;pages_deploying\u0026#34;]\u0026#39;)  if (deploying.length \u0026gt; 0) {  console.log(\u0026#34;更新中...\u0026#34;)  } else {  console.log(\u0026#34;更新完毕\u0026#34;)  break  }  } catch (error) {  break  }  }  await page.waitFor(500)   // 8.更新完毕，关闭浏览器  browser.close() }  giteeUpdate()   打开刚刚的cmd窗口，输入如下代码。（将npm 模块链接到对应的运行项目中去）即可全局使用package.json中bin的命令。\nnpm link   现在就可以本地使用git-update-pages命令来自动化操作去更新gitee page 更新部署了。\n ","id":13,"section":"posts","summary":"","tags":["gitee"],"title":"Gitee自动更新部署的脚本","uri":"https://gb.ytte.top/2022/03/20/gitee%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E9%83%A8%E7%BD%B2%E7%9A%84%E8%84%9A%E6%9C%AC/","year":"2022"},{"content":"本地同步到一个git仓库    序号 代码 意译     1 git init 初始化仓库   2 在仓库端点击初始化仓库添加readme文件    3 git pull 远程仓库地址 拉取同步远程仓库代码   4- git config \u0026ndash;global user.name \u0026ldquo;xxx\u0026rdquo; 设置commit后显示的提交用户的name==这里要注意\u0026ndash;global，如果需要让不同仓库使用不同的name，email，可以将\u0026ndash;global去掉==   5 git config \u0026ndash;global user.email \u0026ldquo;xxx@xxx.com\u0026rdquo; 设置commit后显示的提交用户的email   6 git add . 将本地文件代码等交给暂存区，（HEAD指针不变化，依然指向init的状态）   7 git commit -m “提交辨识信息” 将本地文件代码等交给本地仓库（HEAD指针指向“提交辨识信息”）   8 git remote -v 查看有无远程仓库   9 ssh-keygen -t rsa -C \u0026ldquo;xxx@qq.com\u0026rdquo; 为了使用ssh连接，创建ssh公钥，回车后接着回车知道结束（问的是1.是否更改路径。2.是否设置密码。3.是否设置其他什么的 不需要！）   10 将C:\\Users\\Administrator\\ .ssh\\id_rsa.pub 里面的内容复制到github右上角头像里下方设置里ssh里面。    11 ssh -T git@github.com 测试是否连接   12 git remote add origin git@github.com:xxx/xxx.github.io.git 使用ssh地址添加远程仓库   13 git branch -v 查看本地分支   14 git push -u origin master 将本地仓库本地分支的内容同步到远程仓库origin的master分支   15 git branch \u0026ndash;set-upstream-to=origin/远程分支的名字 本地分支的名字 关联本地分支与远程分支（这样以后同步只需要git push）    还是不会那就传送。\n同一个本地仓库同步到多个不同厂家的git 仓库    以下都是基于本地同步过一个git仓库      一般ssh密钥都是保存C:\\Users\\Administrator\\ .ssh里 这里的Administrator是你的电脑本次的登录的账户，如果电脑账户只有一个一般都是这个名称   进入C:\\Users\\Administrator\\ .ssh 创建config文件（无后缀名）    使用notepad++或者vscode打开config文件，将代码输入保存     #Default github user（xxxx@xxx.com）-这是注释  Host ytte #把默认的常用的github Host设为github.com较好  HostName github.com # 远程仓库的域名地址，gitee是gitee.com \tPort 22 # 一般服务端端口都是22，所以可以省略不写，如果使用云服务器做为git公共仓库，且服务端22端口被更改则需要写上更改后的端口  PreferredAuthentications publickey  IdentityFile ~/.ssh/id_rsa #证书文件路径  #second user(xxx@xxx.com)  Host gitee  HostName gitee.com  PreferredAuthentications publickey  IdentityFile ~/.ssh/id_rsa_gitee #-----这里的id_rsa_gitee是后面创建密钥中需要更改的名称    序号 代码 意译     1 ssh-keygen -t rsa -C \u0026ldquo;xxx@qq.com\u0026rdquo; 在回车后，会提示是否更改路径和名称，我们需要把名称更改，不改路径C:\\Users\\Administrator\\.ssh\\id_rsa_gitee。这里的名称就是上方代码最后填写的   2 由于一个git账号（不论gitee还是github）都只能绑定一个ssh密钥，且该密钥不能被同时绑定两个账号（不论gitee还是github）。所以再次创建一个密匙。 ==当然可以从中权衡，github是国外的，通过ssh访问会快于https访问，而gitee是国内的，https和ssh两种访问速度差不多，所以github使用ssh，gitee使用https也是可以的，这样就不需要配置多个ssh密匙了==   3 git remote -v    4 git remote rm 删除之前的远程仓库，因为如上代码使用config配置的方式，远程仓库地址需要重新配置   5 git remote add gitee1 git@gitee:xxx/xxx.gitee.io.git 注意这里git@gitee:xxx/xxx.gitee.io.git的gitee是config中的Host gitee   6 git remote add github1 git@ytte:xxx/xxx.github.io.git 注意这里git@ytte:xxx/xxx.github.io.git的ytte是config中的Host ytte   7 git remote -v 查看两个远程仓库 gitee1 和 github1 是否正确   8 这里没有设置user.name和user.email 因为在最上面4,5中已经设置过了\u0026ndash;global全局   9 git pull git@gitee:xxx/xxx.gitee.io.git 这里@后的都需要更改为自己的信息   10 git pull git@ytte:xxx/xxx.github.io.git 这里@后的都需要更改为自己的信息    git pull 远程仓库名称 远程仓库分支名称 \u0026ndash;allow-unrelated-histories 如果不能pull，可以使用此命令强制pull合并   11 git add .    12 git commit -m “用于辨别提交信息”    13 git push -u gitee1 master gitee1 为本表格5中设置的远程仓库名称 ，master为远程仓库分支   14 git push -u github1 master github1 为本表格6中设置的远程仓库名称 ，master为远程仓库分支   15 fetch未指定地址时是默认从第一个仓库中取      搞定！\n人生无常，大肠包小肠！\n继续学习吧！\n","id":14,"section":"posts","summary":"","tags":["git","github","gitee"],"title":"git_ssh和多个ssh","uri":"https://gb.ytte.top/2022/03/20/git_ssh%E5%92%8C%E5%A4%9A%E4%B8%AAssh/","year":"2022"},{"content":"Https  视频====》哔哩哔哩_bilibili\n 前置要求   获得域名\n一级域名 - YTTE Site\n  设置二级域名 IPHP 二级域名 - YTTE Site\n  docker基础知识\n  HTTPS流程 个人理解（未学过计算机网络 need todo）\n设置SSL证书 上篇   进入阿里云控制台，点击SSL证书\n  进入后，点击左侧的SSL证书选项\n  再点击免费证书\n  点击立即购买\n  免费的证书每人每年只能拥有20张。所以选项默认不做变动。立即购买\n  点击创建证书\n  点击左侧栏的信息管理，新建联系人。按要求填写信息。\n  点击左侧栏SSL证书，点击免费证书，点击证书申请，填写域名，选择自动DNS验证，系统自动生成，下一步。\n  记录下这里的记录类型，主机记录，记录值\n  新网页标签打开控制台里的域名。\n  点击左侧栏【域名列表】，找到一个域名，点击右侧的【解析】。\n  点击添加记录。将9中的《记录类型》，《主机记录》，《记录值》选择或者填。《解析路线》和《TTL》默认。点击【确认】。\n  回到8中的页面点击【验证】，成功即可。点击【下载】将证书下载保存（选择Nginx版本）。\n   下篇   使用xhsell连接阿里云服务器\n  使用docker安装Nginx\ndocker pull nginx   运行镜像\ndocker run -p 80:80 -p 443:443 --name nginx -v /mnt/nginx/html:/usr/share/nginx/html -v /mnt/nginx/logs:/var/log/nginx -v /mnt/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /mnt/nginx/cert/:/etc/nginx/cert/ --restart=always --privileged=true -d nginx 前缀 /mnt/nginx 可以自定义。\n  运行完成后 docker ps查看下是否运行成功（是否存在，STATUS是不是up）\n然后进入cert文件夹\ncd /mnt/nginx/cert/ 将上篇第13步下载保存的压缩包拖动移动放入xshell窗口里（就是传输到服务当前文件夹，如果使用xftp更加方便）。\n  传输完成后。输入一下命令解压，可以得到后缀为pem和pub的文件。\ntar -zxvf 压缩包全名   使用xftp进入/mnt/nginx/conf/文件夹，右键nginx.conf文件，没有的话，自己创建一个。如下代码全部替换。然后保存。\n# ctrl + F 查找 填写 来寻找需要更改的地方。 worker_processes 1;  events {  worker_connections 1024; }  http {  include /etc/nginx/mime.types; #不需要更改  default_type application/octet-stream;\t#不需要更改   log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39;  \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39;  \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;;\t#不需要更改   #access_log logs/access.log main;   sendfile on;\t#不需要更改  #tcp_nopush on;   #keepalive_timeout 0;  keepalive_timeout 65;\t#不需要更改   #gzip on; \tserver {  listen 443 ssl; # 这里是新版Nginx的写法  server_name blogimg.ytte.top; # 填写你的域名  # ssl on; # 这种已经不使用了，这么写会报警告，可以直接去掉采用第一行的写法  root /home/git/hugo; # 前台文件存放文件夹，一般使用 Nginx 初始化的文件夹，当然也可以自己修改  index index.html; # 上面配置的文件夹里面的index.html  ssl_certificate cert/7448435_blogimg.ytte.top.pem; #填写改成你的证书的名字  ssl_certificate_key cert/7448435_blogimg.ytte.top.key;#填写你的证书的名字  ssl_session_timeout 5m;  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  ssl_prefer_server_ciphers on;  location / {  index index.html index.htm;  } \t} \tserver {  listen 80;  server_name blogimg.ytte.top; #填写你的域名  rewrite ^(.*)$ https://$host:443$1 permanent; # 把http的域名请求转成https且转发到443端口 \t} }   回到Xshell使用如下命令查看nginx的容器id，重启nginx是的配置文件生效。\ndocker ps  docker restart nginx容器的id  docker ps #查看是否重启成功（STATUS为up即成功，如果显示restarting，等一会再docker ps ，如果还显示restarting，可能是6中 nginx.conf 配置错误，仔细检查一下；如果还是不行，进入/mnt/nginx/logs下查看下error错误日志，在寻找解决办法）   至此https配置完成，我们只需要访问6中配置的域名（端口为80 默认不写），nginx就能帮我们把访问这个域名80端口自动转到这个域名443端口，实现https访问。\n  基于上述扩展 因为本例是基于上述的配置七牛云文件访问的二级域名。七牛云中使用的还是http方式，所以我们可以将其更改为https方式。\n只需要重复二级域名操作 ——\u0026gt;2.配置七牛云中的步骤，在第7步与第8步之间，执行一下内容。\n 注意：加速域名要填写你申请ssl证书填写的域名\n   加速域名填写不同于之前的二级玉米；通信协议选择【https】，点击【SSL 证书服务】\n  点击【上传自有证书】。\n  将本文上篇的第13步骤保存的压缩包解压，并把两个文件的内容复制这里（证书内容=\u0026gt;pem；证书私钥=\u0026gt;key）点击【确认上传】\n  等待上传成功即可，返回添加域名界面，填写你申请ssl证书填写的域名，通信协议再次点击选择【https】，就可以选择已经添加的证书，之后执行二级域名中步骤（即第8步骤开始）。\n   搞定！\n人生无常，大肠包小肠！\n继续学习吧！\n","id":15,"section":"posts","summary":"\u003c!-- raw HTML omitted --\u003e","tags":["Https"],"title":"Https","uri":"https://gb.ytte.top/2022/03/19/https/","year":"2022"},{"content":"一级域名 1. 购买域名  地址：域名_域名查询_域名注册_.com_.cn-阿里云 (aliyun.com)  任何服务，都可以不买，只购买域名使用权\n  选择个人\n  选择个人信息\n    未实名认证的，进行阿里云个人实名认证 (aliyun.com)\n  选择已阅读，购买\n  2. 等待审核 进入控制台，点击域名列表可以看到，域名正在审核\n","id":16,"section":"posts","summary":"","tags":["域名"],"title":"一级域名","uri":"https://gb.ytte.top/2022/03/16/%E4%B8%80%E7%BA%A7%E5%9F%9F%E5%90%8D/","year":"2022"},{"content":"二级域名 给七牛云配置阿里云所属顶级域名的二级域名，本文以simg.ytte.top为例\n如果只想配置二级域名，不配置二级域名转向七牛云的话，直接参看步骤9~12。\n1. 首先要有一级域名 一级域名 - github、一级域名 - gitee\n2.配置七牛云 由于七牛云每月有初始免费的存储容量10g、CDN 10g 等等。所以很nice，就选它。\n 创建账号 选择对象存储 新建空间=\u0026gt; 访问控制选择公开。（尽量选择第一华东地区（便宜）） 进入空间，点击【域名管理】 点击自定义 CDN 加速域名【域名绑定】 (使用cdn可以加速我们访问空间内文件速度，加载更快)。其他的选项默认 填写二级域名（即一级域名价格前缀，比如我当时腾讯云申请的ytte.top，在此前面加上自己想要的前缀gb. （有个英文点哦） 其他的默认不做更改（关闭忽略 URL 参数），点击【创建】  如图将这里的域名前缀和CNAME值填入阿里云新建域名解析下。（七牛云页面不要关闭）  进入阿里云控制台 点击【域名】，点击【域名列表】，找到配置的一级域名点击【解析】 点击【添加记录】，将上述的域名前缀和CNAME值填入，记录类型选择CNAME。点击【确认】 如果阿里云域名解析状态显示正常，即可  再回到七牛云中，等待 观察是否设置成功   完成，这样就可以在七牛云 ——\u0026gt;对象存储——\u0026gt;空间——\u0026gt;【文件管理】——\u0026gt;将我们设置好的二级域名设置为外链域名点击【保存默认域名】——\u0026gt;【上传文件】，然后通过上传后的文件【更多】——\u0026gt;【复制外链】来访问或者下载文件了。从地址可以看出我们是使用刚配置的二级域名来访问这个文件的。\n   搞定！\n人生无常，大肠包小肠！\n继续学习吧！\n","id":17,"section":"posts","summary":"","tags":["域名"],"title":"二级域名","uri":"https://gb.ytte.top/2022/03/16/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/","year":"2022"},{"content":"Java8之Consumer、Supplier、Predicate和Function攻略 - 公众号好好学java - 博客园 (cnblogs.com)\n","id":18,"section":"posts","summary":"","tags":["基础"],"title":"Consumer、Supplier、Predicate和Function","uri":"https://gb.ytte.top/2022/03/14/consumersupplierpredicate%E5%92%8Cfunction/","year":"2022"},{"content":"ZooKeeper 单机（本地）安装配置启动 非docker 视频====》_哔哩哔哩_bilibili p7\n  需要jdk环境，并配置环境变量\nlinux安装jdk8\n  下载ZooKeeper压缩包（Apache Downloads)放在linux下的/mnt/zookeeper下。\n  tar -zxvf apache-zookeeper-3.5.7-bin.tar.gz   将文件夹改名\nmv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7/   更改conf下 的zoo-sample.cfg为zoo.cfg\n  更改zoo.cfg中\ndataDir=/mnt/zookeeper/zookeeper-3.5.7/data\rdataLogDir=/mnt/zookeeper/zookeeper-3.5.7/dataLog   启动服务端：\n**注意：**需要在/mnt/zookeeper/zookeeper-3.5.7/目录下使用启动命令bin/zkServer.sh start 不能再/mnt/zookeeper/zookeeper-3.5.7/bin/目录下使用zkServer.sh start\n  使用jps -l 查看是否启动了zookeeper 的java进程。\n  启动客户端： bin/zkCli.sh\n    ls /查看节点\n  quit退出客户端\n  bin/zkServer.sh status查看zookeeper的状态（standalone单机模式）\n  bin/zkServer.sh stop 停止服务器端\n    docker 配置参数解读 视频====》p8\n  tickTime=2000——通信的心跳时间\nZooKeeper服务器与客户端之间通信频率，每2000ms发送一次。\n  initLimit=10——LF初始通信时限\nLeader与Follower初始连接时能容忍的最多心跳数(tickTime的数量)\n  syncLimit = 5：LF同步通信时限\nLeader和Follower之间通信时间如果超过syncLimit * tickTime，Leader认为Follwer死掉，从服务器列表中删除Follwer。\n  dataDir：保存Zookeeper中的数据\n注意：默认的tmp目录，容易被Linux系统定期删除，所以一般不用默认的tmp目录。\n  clientPort = 2181：客户端连接端口，通常不做修改。\n  集群操作","id":19,"section":"posts","summary":"","tags":["ZooKeeper"],"title":"ZooKeeper","uri":"https://gb.ytte.top/2022/03/14/zookeeper/","year":"2022"},{"content":"Filter Filter-CSDN博客_java过滤器\nLstener Filter与Listener - 简书 (jianshu.com)\nListener(监听器)的简单介绍_LrvingTc的博客-CSDN博客_listener\nServlet Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。\nServlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。\n对于每一个应用程序，*Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。*\nServletContext对象 ​ ServletContext对象表示Servlet应用程序。每个Web应用程序都只有一个ServletContext对象。在将一个应用程序同时部署到多个容器的分布式环境中，每台Java虚拟机上的Web应用都会有一个ServletContext对象。\n通过在ServletConfig中调用getServletContext方法，也可以获得ServletContext对象。\n那么为什么要存在一个ServletContext对象呢？存在肯定是有它的道理，因为有了ServletContext对象，就可以共享从应用程序中的所有资料处访问到的信息，并且可以动态注册Web对象。前者将对象保存在ServletContext中的一个内部Map中。保存在ServletContext中的对象被称作属性。\nServletContext中的下列方法负责处理属性：\nObject getAttribute(String var1);  Enumeration\u0026lt;String\u0026gt; getAttributeNames();  void setAttribute(String var1, Object var2);  void removeAttribute(String var1); JavaWeb——Servlet（全网最详细教程包括Servlet源码分析）_扬俊的小屋-CSDN博客_servlet\n四大域对象 JavaWeb四大域对象 - 简书 (jianshu.com)\nJAVA中的四大域对象总结_kun blog-CSDN博客_域对象\n","id":20,"section":"posts","summary":"","tags":["基础"],"title":"Filter/ Lstener/ Servlet/四大域对象","uri":"https://gb.ytte.top/1/01/01/filter/-lstener/-servlet/%E5%9B%9B%E5%A4%A7%E5%9F%9F%E5%AF%B9%E8%B1%A1/","year":"0001"},{"content":"彻底弄懂session，cookie，token - SegmentFault 思否\n彻底理解cookie，session，token - 墨颜丶 - 博客园 (cnblogs.com)\n","id":21,"section":"posts","summary":"","tags":["基础"],"title":"session，cookie，token","uri":"https://gb.ytte.top/1/01/01/sessioncookietoken/","year":"0001"},{"content":"线程的实现方式及其优缺点 继承Thread类 public class TestCode1 extends Thread { \tprivate int i; \tpublic void run() \t{ \tfor(;i\u0026lt;100;i++) \t{ \tSystem.out.println(getName()+\u0026#34; \u0026#34;+i); \t} \t} \tpublic static void main(String[] args) \t{ \tfor(int i=0;i\u0026lt;100;i++) \t{ \tSystem.out.println(Thread.currentThread().getName()+\u0026#34; \u0026#34;+i); \tif(i==20){ \tnew TestCode1().start(); \tnew TestCode1().start(); \t} \t} \t} } 实现Runnable接口  实现Runnable接口，重写run方法，实例要作为Thread的target来创建对象，thread.start()（推荐这种，清洗可见）  class MyRunnable implements Runnable{  @Override  public void run() {  for (int i = 0; i \u0026lt; 20; i++) {  System.out.println(Thread.currentThread().getName()+\u0026#34; \u0026#34;+i);  }  } } public class MyThread {  public static void main(String[] args) {  //创建自定义类对象 线程任务对象  MyRunnable mr = new MyRunnable();  //创建线程对象  Thread t = new Thread(mr, \u0026#34;小强\u0026#34;);  t.start();  for (int i = 0; i \u0026lt; 20; i++) {  System.out.println(\u0026#34;旺财 \u0026#34; + i);  }  } }  或者在方法内直接重写  public class MyThread {  public static void main(String[] args) {   Runnable r = new Runnable(){  public void run(){  for (int i = 0; i \u0026lt; 20; i++) {  System.out.println(\u0026#34;张宇:\u0026#34;+i);  }  }  };  new Thread(r).start();  } }  直接lambda创建Runnable实现类  public class MyThread {  public static void main(String[] args) {  Runnable r = () -\u0026gt; {  for (int i = 0; i \u0026lt; 20; i++) {  System.out.println(\u0026#34;张宇:\u0026#34;+i);  }  };  new Thread(r).start();  } } 实现Callable接口   创建Callable接口的实现类，并实现Call（）方法，该方法将作为线程执行体，且该方法有返回值，再创建Callable实现类的实例。从Java8开始，可以直接使用Lambda表达式创建Callable对象。\n  使用FutureTask来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。\n  使用FutureTask对象作为Thread对象的target创建并启动新线程。\n  调用FutureTask对象的get（）方法来获取子线程执行结束后的返回值。\n  class MyCallable implements Callable {  @Override  public Object call() throws Exception {  int i = 0;  for (; i \u0026lt; 100; i++) {  Thread.sleep(100);  System.out.println(Thread.currentThread().getName() + \u0026#34;循环遍历i的值\u0026#34; + i);  }  return null;  } } public class ThreadTest {  public static void main(String[] args) {  Callable myCallable = new MyCallable();  FutureTask task = new FutureTask(myCallable);  new Thread(task).start();  for (int i = 0; i \u0026lt; 100; i++) {  try {  Thread.sleep(100);  System.out.println(Thread.currentThread().getName()+\u0026#34;循环遍历i的值\u0026#34; + i);  }  catch (Exception e) {  e.printStackTrace();  }  }  } }  //lambda方式 public class ThreadTest {  public static void main(String[] args) {  FutureTask\u0026lt;Integer\u0026gt; task = new FutureTask\u0026lt;\u0026gt;(()-\u0026gt;{  int i=0;  for(;i\u0026lt;100;i++){  System.out.println(Thread.currentThread().getName()+\u0026#34;循环变量i的值：\u0026#34;+i);  }  return i;  });  for(int i=0;i\u0026lt;100;i++){  System.out.println(Thread.currentThread().getName()+\u0026#34;循环变量i的值：\u0026#34;+i);  if(i==20){  new Thread(task,\u0026#34;有返回值的线程\u0026#34;).start();  }  try{  System.out.println(\u0026#34;子线程的返回值：\u0026#34;+task.get());  }  catch (Exception e) {  e.printStackTrace();  }  }  } } 异同点和优缺点 异同点   相同点\n 都可以实现多线程 Runnable与Callable实现方式类似    不同点\n Thread方式是通过继承来实现。 Runnable与Callable是通过实现接口方式创建线程。 Runnable与Callable  因为通过FutureTask包装Callable接口，FutureTask有get方法可以获取返回值，所以只有这种方式创建的子线程有返回值。 run方法无法抛出异常，call方法可以抛出checked exception。 Callable和Runnable都可以应用于executors。而Thread类只支持Runnable.      优缺点   优点\n  Thread\n 编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this即可获得当前线程。    Runnable与Callable\n 可以继承其他类 多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。      缺点\n Thread  继承的局限性，不能继承其他类   Runnable与Callable  编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread（）方法。      补充 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。\n子线程执行完，主线程执行 正常如1中的各种实现方式 Local跳转方式，Shimo跳转方式，主线程与子线程是争夺线程资源的，所以一般情况是会出现类似交替执行的状况。\nFutureTask来包装Callable对象 上方（ Local跳转方式，Shimo跳转方式）的这种是子线程无返回值的情况，这种情况下，子线程与多线程可以争夺线程资源，\n如果为子线程添加返回值，使用 FutureTask来包装Callable对象，通过task.get()来获取返回值，主线程进行到task.get()时，如果子线程还在执行，没有返回，主线程就会子线程返回之前等待挂起。从而达到要求。\npublic class TestCode3 { \tpublic static void main(String[] args) { \tFutureTask\u0026lt;Integer\u0026gt; task = new FutureTask\u0026lt;Integer\u0026gt;((Callable\u0026lt;Integer\u0026gt;)()-\u0026gt;{ \tint i=0; \tfor(;i\u0026lt;100;i++){ \tSystem.out.println(Thread.currentThread().getName()+\u0026#34;循环变量i的值：\u0026#34;+i); \t} \treturn i; \t}); \tfor(int i=0;i\u0026lt;100;i++){ \tSystem.out.println(Thread.currentThread().getName()+\u0026#34;循环变量i的值：\u0026#34;+i); \tif(i==20){ \tnew Thread(task,\u0026#34;有返回值的线程\u0026#34;).start(); \t} \ttry{ \tSystem.out.println(\u0026#34;子线程的返回值：\u0026#34;+task.get()); \t} \tcatch (Exception e) { \te.printStackTrace(); \t} \t} \t} } join方法 参考资料链接\n结论：t.join()方法只会使主线程(或者说调用t.join()的线程)进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。\nt.join方法底层中使用wait(0)方法，即使用了该方法的线程会进入无限等待中，直到 t 执行完成才返回。进入等待的只是调用了join方法的线程，其他线程没开启的不会开启，开启了的不会等待继续执行。\npublic class TestJoin { \tpublic static void main(String[] args) throws InterruptedException { \t// TODO Auto-generated method stub \tSystem.out.println(Thread.currentThread().getName()+\u0026#34; start\u0026#34;); \tThreadTest t1=new ThreadTest(\u0026#34;A\u0026#34;); \tThreadTest t2=new ThreadTest(\u0026#34;B\u0026#34;); \tThreadTest t3=new ThreadTest(\u0026#34;C\u0026#34;); \tSystem.out.println(\u0026#34;t1start\u0026#34;); \tt1.start(); \tSystem.out.println(\u0026#34;t1end\u0026#34;); \tSystem.out.println(\u0026#34;t2start\u0026#34;); \tt2.start(); \tSystem.out.println(\u0026#34;t2end\u0026#34;); \tt1.join(); \tSystem.out.println(\u0026#34;t3start\u0026#34;); \tt3.start(); \tSystem.out.println(\u0026#34;t3end\u0026#34;); \tSystem.out.println(Thread.currentThread().getName()+\u0026#34; end\u0026#34;); \t} } 结果：\nmain start t1start t1end t2start t2end A-1 B-1 A-2 A-3 A-4 A-5 B-2 t3start t3end B-3 main end B-4 B-5 C-1 C-2 C-3 C-4 C-5 主线程在t1.join()方法处停止，并需要等待A线程执行完毕后才会执行t3.start()，然而，并不影响B线程的执行。因此，可以得出结论，t.join()方法只会使主线程进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。\n join源码中，只会调用wait方法，并没有在结束时调用notify，这是因为==线程在die的时候会自动调用自身的notifyAll方法，来释放所有的资源和锁。==\n 线程与线程池的状态 线程的状态（NRBWTT）（牛肉包我舔舔）  NEW\t尚未启动 RUNNABLE 正在执⾏中 BLOCKED 阻塞的（被同步锁或者IO锁阻塞） WAITING 永久等待状态 TIMED_WAITING 等待指定的时间重新被唤醒的状态 TERMINATED 执⾏完成  线程池的状态（RSSTT）（人事是傻甜甜）   RUNNING： 这是最正常的状态 ，接受新的任务，处理等待队列中的任务 。\n  SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。\n  STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执⾏任务的线程。\n  TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执⾏钩⼦⽅法 terminated()。\n  TERMINATED：terminated()⽅法结束后，线程池的状态就会变成这个。\n  线程池 大佬链接====》线程池1_CSDN博客\n大佬链接====》线程池2-CSDN博客\n线程池的优点   降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n  提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n  **提高线程的可管理性。**线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n  线程池的继承树 线程池地使用 线程池的真正实现类是ThreadPoolExecutor ，其构造器方法有以下4种：\npublic ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize,  long keepAliveTime,  TimeUnit unit,  BlockingQueue\u0026lt;Runnable\u0026gt; workQueue) {  this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,  Executors.defaultThreadFactory(), defaultHandler); }  public ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize,  long keepAliveTime,  TimeUnit unit,  BlockingQueue\u0026lt;Runnable\u0026gt; workQueue,  ThreadFactory threadFactory) {  this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,  threadFactory, defaultHandler); }  public ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize,  long keepAliveTime,  TimeUnit unit,  BlockingQueue\u0026lt;Runnable\u0026gt; workQueue,  RejectedExecutionHandler handler) {  this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,  Executors.defaultThreadFactory(), handler); }  public ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize,  long keepAliveTime,  TimeUnit unit,  BlockingQueue\u0026lt;Runnable\u0026gt; workQueue,  ThreadFactory threadFactory,  RejectedExecutionHandler handler) {  if (corePoolSize \u0026lt; 0 ||  maximumPoolSize \u0026lt;= 0 ||  maximumPoolSize \u0026lt; corePoolSize ||  keepAliveTime \u0026lt; 0)  throw new IllegalArgumentException();  if (workQueue == null || threadFactory == null || handler == null)  throw new NullPointerException();  this.corePoolSize = corePoolSize;  this.maximumPoolSize = maximumPoolSize;  this.workQueue = workQueue;  this.keepAliveTime = unit.toNanos(keepAliveTime);  this.threadFactory = threadFactory;  this.handler = handler; } 参数说明：IPHP  corePoolSize（必需）：核心线程数。默认情况下，核心线程会一直存活，但是当将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。 maximumPoolSize（必需）：线程池所能容纳的最大线程数。当活跃线程数达到该数值后，后续的新任务将会阻塞。 keepAliveTime（必需）：线程闲置超时时长。如果超过该时长，非核心线程就会被回收。如果将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。 unit（必需）：指定 keepAliveTime 参数的时间单位。常用的有：TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）。 workQueue（必需）：任务队列。通过线程池的 execute() 方法提交的 Runnable 对象将存储在该参数中。其采用阻塞队列实现。 threadFactory（可选）：线程工厂。用于指定为线程池创建新线程的方式。 handler（可选）：拒绝策略。当达到最大线程数时需要执行的饱和策略。  线程池的使用流程：\n// 创建线程池 ThreadPoolExecutor threadPool = new ThreadPoolExecutor(CORE_POOL_SIZE,  MAXIMUM_POOL_SIZE,  KEEP_ALIVE,  TimeUnit.SECONDS,  sPoolWorkQueue,  sThreadFactory); // 向线程池提交任务 threadPool.execute(new Runnable() {  @Override  public void run() {  ... // 线程执行的任务  } }); // 关闭线程池 threadPool.shutdown(); // 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程 threadPool.shutdownNow(); // 设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表 线程池的工作原理 简概：IPHP  1.如果线程数小于corePoolSize，创建一个新核心线程来运行新任务。 2.如果线程数大于等于corePoolSize但小于maximumPoolSize，则将任务放入队列。 3.如果队列已满，并且线程数小于maxPoolSize，则创建一个新非核心线程来运行任务。 4.如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。  是否需要增加线程的判断顺序是：1、corePoolSize 2、workQueue 3、maxPoolSize\n举个例子：\n线程池的核心线程数corePoolSize大小为5，最大池maxPoolSize大小为10，队列workQueue为100。\n因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程，最多到10个线程，如果再来任务，就拒绝。\n特点：\n 通过设置corePoolSize和maximumPoolSize 相同，就可以创建固定大小的线程池。 我们使用线程池一般希望保持较少的线程数，并且只有在负载变得很大时才增加它。 通过设置maximumPoolSize为很高的值，例如 Integer.MAX_VALUE，可以允许线程池容纳任意数量的并发任务。 只有在队列填满时才创建多于corePoolSize的非核心线程，如果使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize。  线程参数解析 任务队列workQueue 任务队列是基于阻塞队列实现的，即采用生产者消费者模式，在 Java 中需要实现 BlockingQueue 接口。但 Java 已经为我们提供了 7 种阻塞队列的实现：\n  ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列（数组结构可配合指针实现一个环形队列）。\n  LinkedBlockingQueue： 一个由链表结构组成的有界阻塞队列，在未指明容量时，容量默认为Integer.MAX_VALUE。\n 这种队列容量无限大，可以防止流量突增。设置maximumPoolSize也用不到，因为队列装不满，永远不需要创建新的非核心线程。但是也有风险，处理任务的速度跟不上提交的速度，可能造成内存浪费或者OOM。\n   PriorityBlockingQueue： 一个支持优先级排序的无界阻塞队列，对元素没有要求，可以实现 Comparable 接口也可以提供 Comparator 来对队列中的元素进行比较。跟时间没有任何关系，仅仅是按照优先级取任务。\n  DelayQueue：类似于PriorityBlockingQueue，是二叉堆实现的无界优先级阻塞队列。要求元素都实现 Delayed 接口，通过执行时延从队列中提取任务，时间没到任务取不出来。\n  SynchronousQueue： 一个不存储元素的阻塞队列，消费者线程调用 take() 方法的时候就会发生阻塞，直到有一个生产者线程生产了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用 put() 方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。\n 工作任务不多的情况下，只是将任务中转，就可以用SynchronousQueue，这个队列本身内部没有容量，使用这种队列，maximumPoolSize就可能需要设置的大一些。因为没有队列容量作为缓冲了，很容易创建新线程。\n   LinkedBlockingDeque： 使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样 FIFO（先进先出），也可以像栈一样 FILO（先进后出）。\n  LinkedTransferQueue： 它是ConcurrentLinkedQueue、LinkedBlockingQueue 和 SynchronousQueue 的结合体，但是把它用在 ThreadPoolExecutor 中，和 LinkedBlockingQueue 行为一致，但是是无界的阻塞队列。\n  注意有界队列和无界队列的区别：如果使用有界队列，当队列饱和时并超过最大线程数时就会执行拒绝策略；而如果使用无界队列，因为任务队列永远都可以添加任务，所以设置 maximumPoolSize 没有任何意义。\n线程工厂（threadFactory） 线程工厂指定创建线程的方式，需要实现 ThreadFactory 接口，并实现 newThread(Runnable r) 方法。\n 新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory() 创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。 如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。 通常使用默认的ThreadFactory就可以了  // 验证第一点，新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory() public static ThreadFactory defaultThreadFactory() {  return new DefaultThreadFactory(); }  ......  static class DefaultThreadFactory implements ThreadFactory {  private static final AtomicInteger poolNumber = new AtomicInteger(1);  private final ThreadGroup group;  private final AtomicInteger threadNumber = new AtomicInteger(1);  private final String namePrefix;   DefaultThreadFactory() {  SecurityManager s = System.getSecurityManager();  group = (s != null) ? s.getThreadGroup() :  Thread.currentThread().getThreadGroup();  namePrefix = \u0026#34;pool-\u0026#34; +  poolNumber.getAndIncrement() +  \u0026#34;-thread-\u0026#34;;  }   public Thread newThread(Runnable r) {  // 验证第二点，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。  Thread t = new Thread(group, r,  namePrefix + threadNumber.getAndIncrement(),  0);  if (t.isDaemon())  t.setDaemon(false);  if (t.getPriority() != Thread.NORM_PRIORITY)  t.setPriority(Thread.NORM_PRIORITY);  return t;  }  } 拒绝策略（handler） 当线程池的线程数达到最大线程数时，需要执行拒绝策略。拒绝策略需要实现 RejectedExecutionHandler 接口，并实现 rejectedExecution(Runnable r, ThreadPoolExecutor executor) 方法。不过 Executors 框架已经为我们实现了 4 种拒绝策略：\n AbortPolicy（默认）：丢弃任务并抛出 RejectedExecutionException 异常。 CallerRunsPolicy：由调用线程处理该任务。 DiscardPolicy：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。 DiscardOldestPolicy：丢弃队列最早的未处理任务，然后重新尝试执行任务。  功能线程池 嫌上面使用线程池的方法太麻烦？其实Executors已经为我们封装好了 4 种常见的功能线程池，如下：\n 定长线程池（FixedThreadPool） 定时线程池（ScheduledThreadPool ） 可缓存线程池（CachedThreadPool） 单线程化线程池（SingleThreadExecutor）  定长线程池（FixedThreadPool） public static ExecutorService newFixedThreadPool(int nThreads) {  return new ThreadPoolExecutor(nThreads, nThreads,  0L, TimeUnit.MILLISECONDS,  new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {  return new ThreadPoolExecutor(nThreads, nThreads,  0L, TimeUnit.MILLISECONDS,  new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;(),  threadFactory); }  特点：只有核心线程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。 应用场景：控制线程最大并发数。  使用：\n// 1. 创建定长线程池对象 \u0026amp; 设置线程池线程数量固定为3 ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); // 2. 创建好Runnable类线程对象 \u0026amp; 需执行的任务 Runnable task =new Runnable(){  public void run() {  System.out.println(\u0026#34;执行任务啦\u0026#34;);  } }; // 3. 向线程池提交任务 fixedThreadPool.execute(task); 定时线程池（ScheduledThreadPool ）  private static final long DEFAULT_KEEPALIVE_MILLIS = 10L;  public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {  return new ScheduledThreadPoolExecutor(corePoolSize); } public ScheduledThreadPoolExecutor(int corePoolSize) {  super(corePoolSize, Integer.MAX_VALUE,  DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,  new DelayedWorkQueue()); }  public static ScheduledExecutorService newScheduledThreadPool(  int corePoolSize, ThreadFactory threadFactory) {  return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory); } public ScheduledThreadPoolExecutor(int corePoolSize,  ThreadFactory threadFactory) {  super(corePoolSize, Integer.MAX_VALUE,  DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,  new DelayedWorkQueue(), threadFactory); }  特点：核心线程数量固定，非核心线程数量无限，执行完闲置 10ms 后回收，任务队列为延时阻塞队列。 应用场景：执行定时或周期性的任务。  // 1. 创建 定时线程池对象 \u0026amp; 设置线程池线程数量固定为5 ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); // 2. 创建好Runnable类线程对象 \u0026amp; 需执行的任务 Runnable task =new Runnable(){  public void run() {  System.out.println(\u0026#34;执行任务啦\u0026#34;);  } }; // 3. 向线程池提交任务 scheduledThreadPool.schedule(task, 1, TimeUnit.SECONDS); // 延迟1s后执行任务 scheduledThreadPool.scheduleAtFixedRate(task,10,1000,TimeUnit.MILLISECONDS);// 延迟10ms后、每隔1000ms执行任务 可缓存线程池（CachedThreadPool）  public static ExecutorService newCachedThreadPool() {  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,  60L, TimeUnit.SECONDS,  new SynchronousQueue\u0026lt;Runnable\u0026gt;()); } public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,  60L, TimeUnit.SECONDS,  new SynchronousQueue\u0026lt;Runnable\u0026gt;(),  threadFactory); }  特点：无核心线程，非核心线程数量无限，执行完闲置 60s 后回收，任务队列为不存储元素的阻塞队列。 应用场景：执行大量、耗时少的任务。  // 1. 创建可缓存线程池对象 ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); // 2. 创建好Runnable类线程对象 \u0026amp; 需执行的任务 Runnable task =new Runnable(){  public void run() {  System.out.println(\u0026#34;执行任务啦\u0026#34;);  } }; // 3. 向线程池提交任务 cachedThreadPool.execute(task) 单线程化线程池（SingleThreadExecutor） public static ExecutorService newSingleThreadExecutor() {  return new FinalizableDelegatedExecutorService  (new ThreadPoolExecutor(1, 1,  0L, TimeUnit.MILLISECONDS,  new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {  return new FinalizableDelegatedExecutorService  (new ThreadPoolExecutor(1, 1,  0L, TimeUnit.MILLISECONDS,  new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;(),  threadFactory)); }  特点：只有 1 个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。 应用场景：不适合并发但可能引起 IO 阻塞性及影响 UI 线程响应的操作，如数据库操作、文件操作等。  // 1. 创建单线程化线程池 ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); // 2. 创建好Runnable类线程对象 \u0026amp; 需执行的任务 Runnable task =new Runnable(){  public void run() {  System.out.println(\u0026#34;执行任务啦\u0026#34;);  } }; // 3. 向线程池提交任务 singleThreadExecutor.execute(task); 对比 线程池模板 大佬链接====》Spring线程池配置模板- 博客园 \n@EnableAsync @Configuration public class LogThreadPoolConfig {   @Bean(name = \u0026#34;logThreadPool\u0026#34;)  public ThreadPoolTaskExecutor LogThreadPoolTask() {  ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();  LogThreadPoolProperties properties = this.logThreadPoolProperties();   executor.setCorePoolSize(properties.getCorePoolSize());  executor.setMaxPoolSize(properties.getMaxPoolSize());  executor.setQueueCapacity(properties.getQueueCapacity());  executor.setKeepAliveSeconds(properties.getKeepAliveSeconds());  executor.setThreadNamePrefix(properties.getThreadName());  switch (properties.getRejectedExecutionHandler()) {  case \u0026#34;abortPolicy\u0026#34;:  executor.setRejectedExecutionHandler(new AbortPolicy());  break;  case \u0026#34;callerRunsPolicy\u0026#34;:  executor.setRejectedExecutionHandler(new CallerRunsPolicy());  break;  case \u0026#34;discardOldestPolicy\u0026#34;:  executor.setRejectedExecutionHandler(new DiscardOldestPolicy());  break;  case \u0026#34;discardPolicy\u0026#34;:  executor.setRejectedExecutionHandler(new DiscardOldestPolicy());  break;  default:  executor.setRejectedExecutionHandler(new CallerRunsPolicy());  break;  }  executor.initialize();  return executor;  }    @Bean  @ConfigurationProperties(prefix = \u0026#34;threadpool.log\u0026#34;)  public LogThreadPoolProperties logThreadPoolProperties() {  return new LogThreadPoolProperties();  }    //@Getter lombok提供的getset方法生成注解  //@Setter  @Configuration  public static class LogThreadPoolProperties {   /** * 线程前缀名 */  private String threadName;  /** * 核心线程池大小 */  private int corePoolSize;  /** * 最大线程数 */  private int maxPoolSize;  /** * 队列大小 */  private int queueCapacity;  /** * 线程池维护空闲线程存在时间 */  private int keepAliveSeconds;  /** * 拒绝策略 */  private String rejectedExecutionHandler;   } } 这样就可以在yml文件中配置参数了：\nthreadpool:  log:  threadName: ThreadPool-log- # 线程池前缀名  corePoolSize: 8 # 核心线程池数：IO型推荐设置为cpu核心数*2；cpu型推荐设置为cpu数+1  maxPoolSize: 16 # 最大线程池数  queueCapacity: 1000 # 线程池阻塞队列容量  keepAliveSeconds: 60 # 允许线程空闲时间  # 拒绝策略 abortPolicy callerRunsPolicy discardOldestPolicy discardPolicy  rejectedExecutionHandler: callerRunsPolicy 使用：\nSpring提供了注解方式来方便我们使用线程池，只需要在要异步处理的方法上加 @Async(\u0026ldquo;你配置的线程池名字\u0026rdquo;)就可以了,注意这个类需要被spring扫描并纳入管理，所以要加@Service、@Component等注解。\n@Service public class ServiceImpl implements Service {   @Override  @Async(\u0026#34;logThreadPool\u0026#34;)  public void addOperationLog(BaseLog baseLog) {  //你要异步执行的逻辑  } } 小总结  ==Executors 的 4 个功能线程池虽然方便，但现在已经不建议使用了，而是建议直接通过使用 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。==  其实 Executors 的 4 个功能线程有如下弊端：\n FixedThreadPool 和 SingleThreadExecutor：主要问题是堆积的请求处理队列均采用 LinkedBlockingQueue，可能会耗费非常大的内存，甚至 OOM。 CachedThreadPool 和 ScheduledThreadPool：主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。  线程池里的线程数量设定为多少比较合适？  这个得看任务类型\n CPU密集型（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。 耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般会大于CPU核心数很多倍 ，参考Brain Goetz专家推荐的计算方法：线程数=CPU核心数*（1+平均等待时间/平均工作时间）  如果需要更精确的线程数量，那就需要根据不同的程序去做压测，这样就能得到比较合适的线程数量。\nThreadLocal 概念 ThreadLocal叫做线程变量，ThreadLocal中填充的变量 属于当前线程，该变量对其他线程而言是隔离的。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。\nThreadLocal 适用于每个线程变量在线程间隔离而在方法或类间共享的场景。\nThreadLocal与Synchronized的区别   ThreadLocal\nThreadLocal则用于线程间的数据隔离。ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象\n  Synchronized\nSynchronized用于线程间的数据共享。利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。\n  使用 public class ThreadLocaDemo {   private static ThreadLocal\u0026lt;String\u0026gt; localVar = new ThreadLocal\u0026lt;String\u0026gt;();   static void print(String str) {  //打印当前线程中本地内存中本地变量的值  System.out.println(str + \u0026#34; :\u0026#34; + localVar.get());  //清除本地内存中的本地变量  localVar.remove();  }  public static void main(String[] args) throws InterruptedException {   new Thread(new Runnable() {  public void run() {  ThreadLocaDemo.localVar.set(\u0026#34;local_A\u0026#34;);  print(\u0026#34;A\u0026#34;);  //打印本地变量  System.out.println(\u0026#34;after remove : \u0026#34; + localVar.get());   }  },\u0026#34;A\u0026#34;).start();   Thread.sleep(1000);   new Thread(new Runnable() {  public void run() {  ThreadLocaDemo.localVar.set(\u0026#34;local_B\u0026#34;);  print(\u0026#34;B\u0026#34;);  System.out.println(\u0026#34;after remove : \u0026#34; + localVar.get());   }  },\u0026#34;B\u0026#34;).start();  } } A :local_A after remove : null B :local_B after remove : null set() ==向ThreadLocal里面存东西就是向它里面的Map存东西的，然后ThreadLocal把这个Map挂到当前的线程底下==\n public void set(T value) {  //1、获取当前线程  Thread t = Thread.currentThread();  //2、获取线程中的属性 threadLocalMap ,如果threadLocalMap 不为空，  //则直接更新要保存的变量值，否则创建threadLocalMap，并赋值  ThreadLocalMap map = getMap(t);  if (map != null)  map.set(this, value);  else  // 初始化thradLocalMap 并赋值  createMap(t, value);  } 从上面的代码可以看出，ThreadLocal set赋值的时候首先会获取当前线程thread,并获取thread线程中的ThreadLocalMap属性。如果map属性不为空，则直接更新value值，如果map为空，则实例化threadLocalMap,并将value值初始化。\n==ThreadLocalMap呢是当前线程Thread一个叫threadLocals的变量中获取的。每个线程Thread都维护了自己的threadLocals变量，所以在每个线程创建ThreadLocal的时候，实际上数据是存在自己线程Thread的threadLocals变量里面的，别人没办法拿到，从而实现了隔离。==\nThreadLocalMap getMap(Thread t) {  return t.threadLocals;  }  static class ThreadLocalMap {  /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as \u0026#34;stale entries\u0026#34; in the code that follows. */  static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; {  /** The value associated with this ThreadLocal. */  Object value;   Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) {  super(k);  value = v;  }  }  } 可看出ThreadLocalMap是ThreadLocal的内部静态类，而它的构成主要是用Entry来保存数据 ，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。IPHP姬祥todo createMap\nget()  public T get() {  //1、获取当前线程  Thread t = Thread.currentThread();  //2、获取当前线程的ThreadLocalMap  ThreadLocalMap map = getMap(t);  //3、如果map数据为空，  if (map != null) {  //3.1、获取threalLocalMap中存储的值  ThreadLocalMap.Entry e = map.getEntry(this);  if (e != null) {  @SuppressWarnings(\u0026#34;unchecked\u0026#34;)  T result = (T)e.value;  return result;  }  }  //如果是数据为null，则初始化，初始化的结果，TheralLocalMap中存放key值为threadLocal，值为null  return setInitialValue();  }  private T setInitialValue() {  T value = initialValue();  Thread t = Thread.currentThread();  ThreadLocalMap map = getMap(t);  if (map != null)  map.set(this, value);  else  createMap(t, value);  return value;  } remove()  public void remove() {  ThreadLocalMap m = getMap(Thread.currentThread());  if (m != null)  m.remove(this); } remove方法，直接将ThrealLocal 对应的值从当前相差Thread中的ThreadLocalMap中删除。为什么要删除，这涉及到内存泄露的问题。\n如上所说（Local跳转方式，Shimo跳转方式）， ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。\n所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。这样就造成了内存泄露。\nThreadLocal与Thread，ThreadLocalMap之间的关系 ThreadLocal 常见使用场景 参考====》ThreadLocal的应用场景 - sw_kong - 博客园 (cnblogs.com)\n场景的需求：\n 每个线程需要有自己单独的实例 实例需要在多个方法中共享，但不希望变量被多线程共享 ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。  SimpleDateFormat （Java8里的 java.time.format.DateTimeFormatter 是线程安全的 ，由于它调用的parseResolved0 方法入参都是final 修饰的，不可变变量是线程安全的。）\n当时我们使用SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear（），然后调用Calendar.add()。ThreadLocal_敖丙-CSDN博客。如果一个线程先调用了add()然后另一个线程又调用了clear()，这时候parse()方法解析的时间就不对了。\n在这种情况下，每个Thread内都有自己的实例副本，且该副本只能由当前Thread访问到并使用，相当于每个线程内部的本地变量，这也是ThreadLocal命名的含义。因为每个线程独享副本，而不是公用的，所以不存在多线程间共享的问题。\n比如有1000个线程都要用到SimpleDateFormat\npublic class ThreadLocalDemo011 {  public static ExecutorService threadPool = Executors.newFixedThreadPool(16);   public static void main(String[] args) throws InterruptedException {   for (int i = 0; i \u0026lt; 1000; i++) {  int finalI = i;  threadPool.submit(() -\u0026gt; {  String data = new ThreadLocalDemo011().date(finalI);  System.out.println(data);  });  }  threadPool.shutdown();  }  public static Integer id= 0;  private String date(int seconds){  Date date = new Date(1000 * seconds);  id++;  System.out.println(id+\u0026#34;=============\u0026#34;);  SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\u0026#34;mm:ss\u0026#34;);  return simpleDateFormat.format(date);  } } 可以看出，我们用了一个16线程的线程池，并且给这个线程池提交了1000次任务。每个任务中它做的事情和之前是一样的，还是去执行date方法，并且在这个方法中创建一个simpleDateFormat 对象。近1000个simpleDateFormat 对象会被创建。\n这么多对象的创建是有开销的，并且在使用完之后的销毁同样是有开销的，同时存在在内存中也是一种内存的浪费。\n我们可能会想到，要不所有的线程共用一个 simpleDateFormat 对象？但是simpleDateFormat 又不是线程安全的，我们必须做同步，比如使用synchronized加锁。到这里也许就是我们最终的一个解决方法。但是使用synchronized加锁会陷入一种排队的状态，多个线程不能同时工作，这样一来，整体的效率就被大大降低了。\n 使用ThreadLocal  对这种场景，ThreadLocal再合适不过了，ThreadLocal给每个线程维护一个自己的simpleDateFormat对象，这个对象在线程之间是独立的，互相没有关系的。这也就避免了线程安全问题。与此同时，simpleDateFormat对象还不会创造过多，线程池一共只有 16 个线程，所以需要16个对象即可。\npublic class ThreadLocalDemo04 {   public static ExecutorService threadPool = Executors.newFixedThreadPool(16);   public static void main(String[] args) throws InterruptedException {   for (int i = 0; i \u0026lt; 1000; i++) {  int finalI = i;  threadPool.submit(() -\u0026gt; {  String data = new ThreadLocalDemo04().date(finalI);  System.out.println(data);  });  }  threadPool.shutdown();  }   private String date(int seconds){  Date date = new Date(1000 * seconds);  SimpleDateFormat dateFormat = ThreadSafeFormater.dateFormatThreadLocal.get();  return dateFormat.format(date);  } }  class ThreadSafeFormater{  public static Integer id= 0;  public static ThreadLocal\u0026lt;SimpleDateFormat\u0026gt; dateFormatThreadLocal = ThreadLocal.withInitial(() -\u0026gt; {  id++;  System.out.println(id+\u0026#34;=============\u0026#34;);  return new SimpleDateFormat(\u0026#34;mm:ss\u0026#34;);  }); }   结果：\n可以看出只创建了16个SimpleDateFormat对象。\n  1=============\r4=============\r5=============\r6=============\r3=============\r7=============\r2=============\r8=============\r9=============\r10=============\r11=============\r13=============\r12=============\r14=============\r15=============\r16=============\r00:09\r00:16\r00:17\r........\r........\r16:05\r16:04\r16:03\r16:02  问题：  这种情况每个线程的SimpleDataFormat的parse()方法，在一个任务执行后其他任务继续使用这个线程执行任务时，会不会造成数据混乱。   答案  不会，SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear()清除数据，然后调用Calendar.add()添加数据。    用户信息（类似线程内的全局变量） 每个线程内需要保存类似于全局变量的信息（例如在拦截器中获取的用户信息），可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享（因为不同线程获取到的用户信息不一样）。\n例如，用 ThreadLocal 保存一些业务内容（用户权限信息、从用户系统获取到的用户名、用户ID 等），这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。\n在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，避免了将这个对象（如 user 对象）作为参数传递的麻烦。\n比如说我们是一个用户系统，那么当一个请求进来的时候，一个线程会负责执行这个请求，然后这个请求就会依次调用service-1()、service-2()、service-3()、service-4()，这4个方法可能是分布在不同的类中的。\npackage com.kong.threadlocal;   public class ThreadLocalDemo05 {  public static void main(String[] args) {  User user = new User(\u0026#34;jack\u0026#34;);  new Service1().service1(user);  } }  class Service1 {  public void service1(User user){  //给ThreadLocal赋值，后续的服务直接通过ThreadLocal获取就行了。  UserContextHolder.holder.set(user);  new Service2().service2();  } }  class Service2 {  public void service2(){  User user = UserContextHolder.holder.get();  System.out.println(\u0026#34;service2拿到的用户:\u0026#34;+user.name);  new Service3().service3();  } }  class Service3 {  public void service3(){  User user = UserContextHolder.holder.get();  System.out.println(\u0026#34;service3拿到的用户:\u0026#34;+user.name);  //在整个流程执行完毕后，一定要执行remove  UserContextHolder.holder.remove();  } }  class UserContextHolder {  //创建ThreadLocal保存User对象  public static ThreadLocal\u0026lt;User\u0026gt; holder = new ThreadLocal\u0026lt;\u0026gt;(); }  class User {  String name;  public User(String name){  this.name = name;  } } 守护线程 面试题 线程池创建的4中方法 Local跳转方式，Shimo跳转方式\n任务加入的线程池的流程 Local跳转方式，Shimo跳转方式\n线程池的7个参数。拒绝策略。 参数：Local跳转方式，Shimo跳转方式\n拒绝策略：Local跳转方式，Shimo跳转方式\n线程池中如何拿到线程的执行结果 线程池中 submit()和 execute()方法有什么区别？   execute()：只能执⾏ Runnable 类型的任务。\n  submit()：可以执⾏ Runnable 和 Callable 类型的任务。\n  死锁 两线程都有各自的锁，并都尝试去获取独占对方的锁，就会发生阻塞的现象。\n解释下生产消费模型 生产者消费者能够解决的问题如下：\n 生产与消费的速度不匹配 软件开发过程中解耦  生产者生产，消费者消费，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架满的时候，消费者可以从货架上拿走商品，生产者此时等待货架的空位，这样不断的循环。那么在这个过程中，生产者和消费者是不直接接触的，所谓的‘货架’其实就是一个==阻塞队列==，生产者生产的产品不直接给消费者消费，而是仍给阻塞队列，这个阻塞队列就是来解决生产者消费者的强耦合的。就是生产者消费者模型。TP①，TP②\n参考  ThreadLocal原理分析与使用场景 - 阿凡卢 - 博客园 (cnblogs.com) ThreadLocal的应用场景 - sw_kong - 博客园 (cnblogs.com) ThreadLocal_敖丙-CSDN博客 CSDN博客_生产者消费者模型 Java8之Consumer、Supplier、Predicate和Function攻略 博客园 ","id":22,"section":"posts","summary":"","tags":["Thread"],"title":"Thread","uri":"https://gb.ytte.top/1/01/01/thread/","year":"0001"},{"content":"使用typora写文档传图片，再上传石墨等网站的好方法 1. typora下载 typora开始收费，我们可以使用不收费的老版本 下载链接\n2. typora图床 picgotypora不像word，word可以直接将上传的图片保存在文件当中，而typora不行。但是typora支持picgo插件的使用，所以，我们下在picgo 下载链接\n3. 七牛云和picgo的使用，二级域名（如果不想弄直接第4步骤） 注册七牛云 ，并开通对象存储 picgo使用七牛云图床 - 知乎 。为七牛云配置二级域名（前提是有了一级域名）：二级域名-石墨\n4. picgo 配置： 进入picgo，点击左侧的图床设置，选择七牛图床。按下图所示填写配置，SecretKey向 j j 索取。\n SbOIcbA56xQGcpZyyLDtuARvi3COHhlBxa-IZxDi\nytte-picgo\nhttps://blogimg.ytte.top/\nz2\nimg-sunsifan/或者是img-wuhao\n 伍昊：\n孙思凡：\n将最后 一项，指定存储路径更改为：img-sunsifan。\n5. typora设置   打开typora后，\n  点击左上角文件，\n  点击偏好设置，\n  点击图像，\n  如图进行配置，\n   成功就会出现如图信息，  ==大功告成==\n6. picgo的使用 使用截图软件截图，打开picgo点记左侧的上传区，点击剪切板图片上传，上传成功后自动将图片地址返回到剪切板当中。\n 注意：如果直接截图后直接粘贴到typora文中，使用的是标签，在有的编辑器不能正常识别（比如石墨），所以最好先按上面方法。\n","id":23,"section":"posts","summary":"","tags":["typora"],"title":"typora","uri":"https://gb.ytte.top/1/01/01/typora/","year":"0001"},{"content":"谷粒商城步骤笔记 使用人人代码生成器 视频====》谷粒商城——p17\n  clone人人代码生成器\n  放进项目中加入模块\n  在application.yml修改数据库相关信息\n  在generator.properties中修改参数\nmainPath=com.atguigu #包名 package=com.atguigu.gulimall moduleName=product #作者 author=yttejx #Email email=1026190684@qq.com #表前缀(类名不会包含表前缀) tablePrefix=pms_   更改renren-generator的resources的template的Controller模板中@RequiresPermissions注解和导包注释掉，以后再导入使用。\n  启动renren-generator的Application。网页访问localhost:80，点击显示全部表格，全选表格，点击生成代码。\n  将生成的代码中main包复制粘贴到product项目下。\n  新建模块（maven）取名，gulimall_common（项目的公共资源全部放在这里）\n  查看product项目中报错信息。将相应的pom 和类（renren自己创建的工具类）加入到common项目中\n从renren-faster中导入\n  包：\n exception utils  Constant PageUtils Query R validator xss  去掉XssFilter和XssHttpServletRequestWrapper，是防跨站脚本攻击的，以后用springsecurity来实现。 这里需要导包Servlet，同时设置scope 为provided，因为tomcat内有Servlet        pom：\n  \u0026lt;properties\u0026gt; \t\u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt;  \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt;  \u0026lt;mybatis.plus.boot.starter.version\u0026gt;3.5.1\u0026lt;/mybatis.plus.boot.starter.version\u0026gt;  \u0026lt;lombok.version\u0026gt;1.18.22\u0026lt;/lombok.version\u0026gt;  \u0026lt;commons.lang.version\u0026gt;2.6\u0026lt;/commons.lang.version\u0026gt;  \u0026lt;httpcore.version\u0026gt;4.4.15\u0026lt;/httpcore.version\u0026gt;  \u0026lt;shiro.version\u0026gt;1.4.0\u0026lt;/shiro.version\u0026gt;  \u0026lt;commons.io.version\u0026gt;2.5\u0026lt;/commons.io.version\u0026gt;  \u0026lt;mysql.connector.version\u0026gt;8.0.28\u0026lt;/mysql.connector.version\u0026gt;  \u0026lt;/properties\u0026gt;  \u0026lt;dependencies\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${mybatis.plus.boot.starter.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;commons-lang\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;commons-lang\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${commons.lang.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore --\u0026gt;  \u0026lt;!--java 发送http请求--\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;httpcore\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${httpcore.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;commons-io\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${commons.io.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;shiro-core\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${shiro.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;shiro-spring\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${shiro.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${mysql.connector.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt;  \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt;  \u0026lt;!-- tomcat内有Servlet--\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;jakarta.validation\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jakarta.validation-api\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;2.0.2\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;/dependencies\u0026gt;   product的UndoLogEntity的rollbackInfo属性，数据库中使用的是Longblob，实体类中使用byte[]。\n  配置\u0026amp;测试服务的crud功能 视频====》谷粒商城——p18\n  每个项目都需要crud，所以在common中导入mysql驱动\n  配置数据源\nspring:  datasource:  username: root  password: as123  url: jdbc:mysql://localhost:3380/gulimall_pms?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;useSSL=false\u0026amp;serverTimezone=Asia/Shanghai  driver-class-name: com.mysql.cj.jdbc.Driver   配置mybatis-plus\n 使用MapperScan  @MapperScan(\u0026#34;com.atguigu.gulimall.product.dao\u0026#34;)   告诉mybatis-plus，sql映射文件位置\n使用自增主键（以后数据量大了在使用其他主键策略）\nmybatis-plus:  mapper-locations: classpath*:/mapper/**/*.xml  global-config:  db-config:  id-type: auto   crud测试\n@Test  void contextLoads() {  BrandEntity brandEntity = new BrandEntity();  brandEntity.setName(\u0026#34;华为\u0026#34;);   brandService.save(brandEntity);  System.out.println(\u0026#34;保存成功----------\u0026#34;);   brandEntity.setBrandId(1L);  brandEntity.setDescript(\u0026#34;华为手机\u0026#34;);  brandService.updateById(brandEntity);  System.out.println(\u0026#34;更新成功---------\u0026#34;);   List\u0026lt;BrandEntity\u0026gt; list = brandService.list(new LambdaQueryWrapper\u0026lt;BrandEntity\u0026gt;().eq(BrandEntity::getBrandId, \u0026#34;1\u0026#34;));  list.forEach(System.out::println);  System.out.println(\u0026#34;查询成功---------\u0026#34;);  }     逆向工程生成所有代码 视频====》p19\n分","id":24,"section":"posts","summary":"","tags":["谷粒商城"],"title":"谷粒商城步骤笔记","uri":"https://gb.ytte.top/1/01/01/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E6%AD%A5%E9%AA%A4%E7%AC%94%E8%AE%B0/","year":"0001"}],"tags":[{"title":"bolg","uri":"https://gb.ytte.top/tags/bolg/"},{"title":"Docker","uri":"https://gb.ytte.top/tags/docker/"},{"title":"git","uri":"https://gb.ytte.top/tags/git/"},{"title":"gitee","uri":"https://gb.ytte.top/tags/gitee/"},{"title":"github","uri":"https://gb.ytte.top/tags/github/"},{"title":"hexo","uri":"https://gb.ytte.top/tags/hexo/"},{"title":"Https","uri":"https://gb.ytte.top/tags/https/"},{"title":"hugo","uri":"https://gb.ytte.top/tags/hugo/"},{"title":"index","uri":"https://gb.ytte.top/tags/index/"},{"title":"java","uri":"https://gb.ytte.top/tags/java/"},{"title":"JVM","uri":"https://gb.ytte.top/tags/jvm/"},{"title":"mysql","uri":"https://gb.ytte.top/tags/mysql/"},{"title":"Rabbit Mq","uri":"https://gb.ytte.top/tags/rabbit-mq/"},{"title":"Spring Mvc","uri":"https://gb.ytte.top/tags/spring-mvc/"},{"title":"SpringBoot","uri":"https://gb.ytte.top/tags/springboot/"},{"title":"SpringCloud","uri":"https://gb.ytte.top/tags/springcloud/"},{"title":"Thread","uri":"https://gb.ytte.top/tags/thread/"},{"title":"typora","uri":"https://gb.ytte.top/tags/typora/"},{"title":"ZooKeeper","uri":"https://gb.ytte.top/tags/zookeeper/"},{"title":"域名","uri":"https://gb.ytte.top/tags/%E5%9F%9F%E5%90%8D/"},{"title":"基础","uri":"https://gb.ytte.top/tags/%E5%9F%BA%E7%A1%80/"},{"title":"谷粒商城","uri":"https://gb.ytte.top/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"},{"title":"题目","uri":"https://gb.ytte.top/tags/%E9%A2%98%E7%9B%AE/"}]}