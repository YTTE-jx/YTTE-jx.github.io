{"categories":[{"title":"git","uri":"https://gb.ytte.top/categories/git/"},{"title":"java","uri":"https://gb.ytte.top/categories/java/"},{"title":"JVM","uri":"https://gb.ytte.top/categories/jvm/"},{"title":"MySQL","uri":"https://gb.ytte.top/categories/mysql/"},{"title":"ZooKeeper","uri":"https://gb.ytte.top/categories/zookeeper/"},{"title":"服务器","uri":"https://gb.ytte.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"杂项","uri":"https://gb.ytte.top/categories/%E6%9D%82%E9%A1%B9/"},{"title":"项目","uri":"https://gb.ytte.top/categories/%E9%A1%B9%E7%9B%AE/"}],"posts":[{"content":"","id":0,"section":"posts","summary":"","tags":["git"],"title":"Git多个ssh","uri":"https://gb.ytte.top/2022/03/20/git%E5%A4%9A%E4%B8%AAssh/","year":"2022"},{"content":"Https  视频====》哔哩哔哩_bilibili\n 前置要求   获得域名\n一级域名 - YTTE Site\n  设置二级域名\n二级域名 - YTTE Site\n  HTTPS流程 个人理解（未学过计算机网络 need todo）\n设置SSL证书   进入阿里云控制台，点击SSL证书\n  进入后，点击左侧的SSL证书选项\n  再点击免费证书\n  点击立即购买\n  免费的证书每人每年只能拥有20张。所以选项默认不做变动。立即购买\n  点击创建证书\n  点击左侧栏的信息管理，新建联系人。按要求填写信息。\n  点击左侧栏SSL证书，点击免费证书，点击证书申请，填写域名，选择自动DNS验证，系统自动生成，下一步。\n  新网页标签打开控制台里的域名。\n  点击左侧栏域名列表，找到一个域名，点击右侧的解析。\n  3\n  3\n  3\n  3\n  ","id":1,"section":"posts","summary":"\u003c!-- raw HTML omitted --\u003e","tags":["Https"],"title":"Https","uri":"https://gb.ytte.top/2022/03/19/https/","year":"2022"},{"content":"一级域名 1. 购买域名  地址：域名_域名查询_域名注册_.com_.cn-阿里云 (aliyun.com)  任何服务，都可以不买，只购买域名使用权\n  选择个人\n  选择个人信息\n    未实名认证的，进行阿里云个人实名认证 (aliyun.com)\n  选择已阅读，购买\n  2. 等待审核 进入控制台，点击域名列表可以看到，域名正在审核\n","id":2,"section":"posts","summary":"","tags":["域名"],"title":"一级域名","uri":"https://gb.ytte.top/2022/03/16/%E4%B8%80%E7%BA%A7%E5%9F%9F%E5%90%8D/","year":"2022"},{"content":"二级域名 给七牛云配置阿里云所属顶级域名的二级域名\n1. 首先要有一级域名 一级域名-石墨\n2.配置七牛云 尽量选择华南地区（便宜）。\n 点击域名   点击域名绑定   点击创建 如下图，说明创建成功，    点击复制CNAME（七牛云页面不要关闭）\n  进入阿里云控制台\n  点击域名=\u0026gt;点击域名列表\n  点击解析\n  点击添加记录 =\u0026gt;点击确认\n这里的主机记录和记录值前缀要一致\n  如果状态显示正常，即可\n  再回到七牛云中，观察是否设置成功\n ","id":3,"section":"posts","summary":"","tags":["域名"],"title":"二级域名","uri":"https://gb.ytte.top/2022/03/16/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/","year":"2022"},{"content":"Java8之Consumer、Supplier、Predicate和Function攻略 - 公众号好好学java - 博客园 (cnblogs.com)\n","id":4,"section":"posts","summary":"","tags":["基础"],"title":"Consumer、Supplier、Predicate和Function","uri":"https://gb.ytte.top/2022/03/14/consumersupplierpredicate%E5%92%8Cfunction/","year":"2022"},{"content":"ZooKeeper 非docker 单机（本地）安装配置启动 视频====》_哔哩哔哩_bilibili p7\n  需要jdk环境，并配置环境变量\nlinux安装jdk8\n  下载ZooKeeper压缩包（Apache Downloads)放在linux下的/mnt/zookeeper下。\n  tar -zxvf apache-zookeeper-3.5.7-bin.tar.gz   将文件夹改名\nmv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7/   更改conf下 的zoo-sample.cfg为zoo.cfg\n  更改zoo.cfg中\ndataDir=/mnt/zookeeper/zookeeper-3.5.7/data\rdataLogDir=/mnt/zookeeper/zookeeper-3.5.7/dataLog   启动服务端：\n**注意：**需要在/mnt/zookeeper/zookeeper-3.5.7/目录下使用启动命令bin/zkServer.sh start 不能再/mnt/zookeeper/zookeeper-3.5.7/bin/目录下使用zkServer.sh start\n  使用jps -l 查看是否启动了zookeeper 的java进程。\n  启动客户端： bin/zkCli.sh\n    ls /查看节点\n  quit退出客户端\n  bin/zkServer.sh status查看zookeeper的状态（standalone单机模式）\n  bin/zkServer.sh stop 停止服务器端\n    docker 配置参数解读 视频====》p8\n  tickTime=2000——通信的心跳时间\nZooKeeper服务器与客户端之间通信频率，每2000ms发送一次。\n  initLimit=10——LF初始通信时限\n  Leader与Follower初始连接是\n ","id":5,"section":"posts","summary":"","tags":["ZooKeeper"],"title":"ZooKeeper","uri":"https://gb.ytte.top/2022/03/14/zookeeper/","year":"2022"},{"content":"Filter Filter-CSDN博客_java过滤器\nLstener Filter与Listener - 简书 (jianshu.com)\nListener(监听器)的简单介绍_LrvingTc的博客-CSDN博客_listener\nServlet JavaWeb——Servlet（全网最详细教程包括Servlet源码分析）_扬俊的小屋-CSDN博客_servlet\n四大域对象 JavaWeb四大域对象 - 简书 (jianshu.com)\nJAVA中的四大域对象总结_kun blog-CSDN博客_域对象\n","id":6,"section":"posts","summary":"","tags":["基础"],"title":"Filter/ Lstener/ Servlet/四大域对象","uri":"https://gb.ytte.top/1/01/01/filter/-lstener/-servlet/%E5%9B%9B%E5%A4%A7%E5%9F%9F%E5%AF%B9%E8%B1%A1/","year":"0001"},{"content":"JVM上篇 JVM与Java体系结构 1. Java虚拟机整体架构祥图 2.Java代码执行过程详图 3. JVM的架构模型","id":7,"section":"posts","summary":"","tags":["JVM"],"title":"JVM上篇","uri":"https://gb.ytte.top/1/01/01/jvm%E4%B8%8A%E7%AF%87/","year":"0001"},{"content":"MySQL 基础 高级 8、 索引的创建与设计原则 2、索引的必要使用场景 1). 字段的数值有唯一性的限制 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。\n说明：唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。\n2). 频繁作为 WHERE 查询条件的字段 某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。\n比如查询 student_id =144324的时候\nSELECT course_id ,class_id, `name`,create_time,student_id FROM student_info WHERE student_id =144324   在student_id不加索引的情况下，100w条数据，耗时为350ms左右，即在百毫秒级\nALTER TABLE student_info ADD INDEX idx_sid(student_id)  SHOW INDEX FROM student_info #查看是否添加成功   在添加索引的情况下，耗时为22ms，降了一个数量级，这是很客观的。\n   3). 经常 GROUP BY 和 ORDER BY 的列 索引就是让数据按照某种顺序进行存储或检索，因此当我们使用GROUP BY对数据进行分组查询，或者使用ORDER BY对数据进行排序的时候，就需要对分组或者排序的字段进行索引，从而减少排序的时间。如果待排序的列有多个，那么可以在这些列上建立组合索引。\n1. GROUP BY eg：在100w条数据中，按照student_id对学生选修课程进行分组，显示不同的student_id和课程数量，显示100个。\nSELECT student_id ,COUNT(*) AS num FROM student_info GROUP BY student_id LIMIT 100  DROP INDEX idx_sid ON student_info SHOW INDEX FROM student_info  在不加索引的情况下，耗时850毫秒。 在加索引的情况下（这里使用的是2）当中的idx_sid索引），耗时21毫秒。  2. ORDER BY ORDER BY单独使用的情况与GROUP BY差不多\n3. ORDER BY和GROUP BY同时使用的情况 ==由于GROUP BY先执行，且GROUP BY为先排序再分组，所以主要耗时就集中在GROUP BY上。==\n使用以下三种情况来观察不同索引状况下，sql执行的速度差异\n 三种情况：  ​\t①. student_id和create_time分别建立索引\n​\t②. student_id和create_time建立联合索引，且student_id在前\n​\t③. student_id和create_time建立联合索引，且create_time在前\nSELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info GROUP BY\tstudent_id ORDER BY\tcreate_time desc LIMIT 100 不加除主键索引以外的其他索引的情况下，耗时约==0.8~1s==\n 两种版本：  ​\t①. MySQL 5.7.5及以上功能依赖检测功能\n​\t②. MySQL 5.7.5以下无依赖检测功能\n执行上方代码后MySQL 5.7.5及以上会报错\nsql_mode=only_full_group_by #出现问题 MySQL 5.7.5及以上由于sql_mode=only_full_group_by是默认开启依赖检测功能，所以HAVING条件或ORDER BY列表的查询引用在GROUP BY子句中。 简单来说就是：输出的结果是叫target list，就是select后面跟着的字段，还有一个地方group by column，就是group by后面跟着的字段。由于开启ONLY_FULL_GROUP_BY的设置，如果一个字段没有在target list和group by字段中同时出现，或者是聚合函数的值的话，那么这条sql查询是被mysql认为非法的，会报错误。\n但是如果同时GROUP BY student_id，create_time 这两个字段，就失去了本例的作用。所以需要MySQL 5.7.5及以上的需要关闭依赖检测功能\n具体解析链接====》文档——石墨\nselect @@global.sql_mode #查看sql_mode详细  set @@global.sql_mode =\u0026#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\u0026#39;; #去掉ONLY_FULL_GROUP_BY，重新设置值，对于新建的数据库有效 8.0中还要去掉NO_AUTO_CREATE_USER  set global sql_mode=\u0026#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\u0026#39;; #对于已存在的数据库，则需要在对应的数据下执行 继续测试\n  添加单列student_id索引和create_time索引\n​\t5.7中：\n耗时6s左右，添加索引就是将这些时间提前消耗掉，让客户查询的时候减少查询时间。\nALTER TABLE student_info ADD INDEX idx_sid(student_id);  ALTER TABLE student_info ADD INDEX idx_cre_time(create_time DESC); 这里 EXPLAIN 后会发现只使用了student_id 的索引idx_sid（单列索引的情况，只使用语句执行过程第一个索引）所以这里只使用了索引idx_sid，而idx_cre_time压根没用到。\nSHOW INDEX FROM student_info  EXPLAIN  SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info GROUP BY\tstudent_id ORDER BY\tcreate_time DESC LIMIT 100; 各自单列索引的情况下，耗时大约1.5s（上面不加索引的情况下耗时1s）\n​\t8.0中\n==todo 不明原因，未得到解决，上述方式在5.7中大约需要1.5s左右，而在8.0中需要几分钟的时间。==\n  联合索引的情况① ：\n先删除除主键外其他的单列索引\nidx_sid_cre_time(student_id,create_time)，student_id在前\n​\t5.7：\nALTER TABLE student_info ADD INDEX idx_sid_cre_time(student_id,create_time);  SHOW INDEX FROM student_info;  EXPLAIN  SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info GROUP BY\tstudent_id ORDER BY\tcreate_time DESC LIMIT 100; 耗时约==300ms==左右（未加索引1s左右，单列索引1.5s左右）\n8.0：\nDROP INDEX idx_sid ON student_info ; DROP INDEX idx_cre_time ON student_info; DROP INDEX idx_sid_cre_time ON student_info;  ALTER TABLE student_info ADD INDEX idx_sid_cre_time(student_id,create_time DESC);  SHOW INDEX FROM student_info;  EXPLAIN  SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info GROUP BY\tstudent_id ORDER BY\tcreate_time DESC LIMIT 100;   索引不加DESC时，耗时约==800ms==左右（不加索引1s左右，单列索引几分钟）\n  索引加DESC时，耗时约==300ms==左右（不加索引1s左右，单列索引几分钟）\n    联合索引的情况② ：\nidx_cre_sid_time(create_time,student_id)，create_time在前\n在语句执行中，先进行group by 所以此时如果存在idx_sid(student_id)的话，会优先使用group by student_id的student_id索引（idx_sid），这样就变成了使用单列索引，联合索引idx_sid_cre_time就不起作用了。\n如果不存在idx_sid，只有联合索引idx_cre_sid_time：\n​ 5.7：\nDROP INDEX idx_sid ON student_info ; DROP INDEX idx_cre_time ON student_info; DROP INDEX idx_sid_cre_time ON student_info;  ALTER TABLE student_info ADD INDEX idx_cre_sid_time(create_time,student_id);  SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info GROUP BY\tstudent_id ORDER BY\tcreate_time DESC LIMIT 100; 耗时约==800ms左右== （未加索引1s左右，单列索引1.5s左右，idx_sid_cre_time索引耗时约300ms）\n​ 8.0 ：\nDROP INDEX idx_sid ON student_info ; DROP INDEX idx_cre_time ON student_info; DROP INDEX idx_sid_cre_time ON student_info; DROP INDEX idx_cre_sid_time ON student_info;  ALTER TABLE student_info ADD INDEX idx_cre_sid_time(create_time DESC,student_id);  SELECT student_id,COUNT(*)\tAS\tnum\tFROM\tstudent_info GROUP BY\tstudent_id ORDER BY\tcreate_time DESC LIMIT 100;   索引不加DESC时，耗时约==1s==左右（不加索引1s左右，单列索引几分钟，idx_sid_cre_time索引800ms左右）\n  索引加DESC时，耗时约==1s==左右（不加索引1s左右，单列索引几分钟，idx_sid_cre_time索引300ms左右）\n    4). UPDATE、DELETE 的 WHERE 条件列 对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。\n原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。\n5). DISTINCT 字段需要创建索引 有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。\n比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行\nSQL 语句：\nSELECT DISTINCT(student_id) FROM `student_info`; 运行结果（600637 条记录，运行时间 0.683s ）：\n如果我们对 student_id 创建索引，再执行 SQL 语句：\nSELECT DISTINCT(student_id) FROM `student_info`; 运行结果（600637 条记录，运行时间 0.010s ）：\nSQL 查询效率有了提升，同时显示出来的 student_id 还是按照 递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。\n6). 多表 JOIN 连接操作时，创建索引注意事项 首先， ==连接表的数量尽量不要超过 3 张==，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。\n其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。\n最后，==类似字符串和int比较时，会存在隐式转换，即使用了函数，一旦使用了函数就会让索引失效。 对用于连接的字段创建索引 ，并且该字段在多张表中的 类型必须一致 。==比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。\n举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：\nSELECT course_id, name, student_info.student_id, course_name FROM student_info JOIN course ON student_info.course_id = course.course_id WHERE name = \u0026#39;462eed7ac6e791292a79\u0026#39;; 运行结果（1 条数据，运行时间 0.189s ）：\n这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。\n7). 使用列的类型小的创建索引 8). 使用字符串前缀创建索引 创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引\ncreate table shop(address varchar(120) not null);  alter table shop add index(address(12)); 问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字\n段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？\n先看一下字段在全部数据中的选择度：\nselect count(distinct address) / count(*) from shop; 通过不同长度去计算，与全表的选择性对比：\n公式：\ncount(distinct left(列名, 索引长度))/count(*) 例如：\nselect count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度 count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度 count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度 count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度 from shop; 引申另一个问题：索引列前缀对排序的影响\n拓展：Alibaba《Java开发手册》\n==在 varchar 字段上建立索引时，必须指定索引长度，根据实际文本区分度决定索引长度。==\n说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会 高达 90% 以上 ，可以使用\n count(distinct left(列名, 索引长度))/count(*)的区分度来确定。\n9). 区分度高(散列性高)的列适合作为索引 10). 使用最频繁的列放到联合索引的左侧 11). 在多个字段都要创建索引的情况下，联合索引优于单值索引 3. 限制索引的数目 4. 哪些情况不适合创建索引  WHERE条件（包括GROUP BY、ORDER BY)里用不到的字段不需要创建索引 数据量小的表最好不要使用索引 有大量重复数据的列上不要建立索引  比如性别。   避免对经常更新的表创建过多的索引 不建议用无序的值作为索引  例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。   删除不再使用或者很少使用的索引 不要定义冗余或重复的索引  小记  我们进行内联查询前，最好能限制连的表大小的条件都先用上了，同时尽量让条件查询和分组执行的表尽量小====》CSDN博客_mysql联表查询优化①   ","id":8,"section":"posts","summary":"","tags":["MySQL"],"title":"MySQL","uri":"https://gb.ytte.top/1/01/01/mysql/","year":"0001"},{"content":"彻底弄懂session，cookie，token - SegmentFault 思否\n彻底理解cookie，session，token - 墨颜丶 - 博客园 (cnblogs.com)\n","id":9,"section":"posts","summary":"","tags":["基础"],"title":"session，cookie，token","uri":"https://gb.ytte.top/1/01/01/sessioncookietoken/","year":"0001"},{"content":"SpringBoot 5. web开发 3. 请求参数处理 1. 普通参数与基本注解 1.1注解 视频====》尚硅谷雷神SpringBoot2_bilibili\n@PathVariable、\n@RequestHeader、\n@ModelAttribute、\n@RequestParam、\n@MatrixVariable（矩阵变量）、\n@CookieValue、\n@RequestBody\n@RestController public class ParameterTestController {    // car/2/owner/zhangsan  @GetMapping(\u0026#34;/car/{id}/owner/{username}\u0026#34;)  public Map\u0026lt;String,Object\u0026gt; getCar(@PathVariable(\u0026#34;id\u0026#34;) Integer id,  @PathVariable(\u0026#34;username\u0026#34;) String name,  @PathVariable Map\u0026lt;String,String\u0026gt; pv,  @RequestHeader(\u0026#34;User-Agent\u0026#34;) String userAgent,  @RequestHeader Map\u0026lt;String,String\u0026gt; header,  @RequestParam(\u0026#34;age\u0026#34;) Integer age,  @RequestParam(\u0026#34;inters\u0026#34;) List\u0026lt;String\u0026gt; inters,  @RequestParam Map\u0026lt;String,String\u0026gt; params,  @CookieValue(\u0026#34;_ga\u0026#34;) String _ga,  @CookieValue(\u0026#34;_ga\u0026#34;) Cookie cookie){    Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();  // map.put(\u0026#34;id\u0026#34;,id); // map.put(\u0026#34;name\u0026#34;,name); // map.put(\u0026#34;pv\u0026#34;,pv); // map.put(\u0026#34;userAgent\u0026#34;,userAgent); // map.put(\u0026#34;headers\u0026#34;,header);  map.put(\u0026#34;age\u0026#34;,age);  map.put(\u0026#34;inters\u0026#34;,inters);  map.put(\u0026#34;params\u0026#34;,params);  map.put(\u0026#34;_ga\u0026#34;,_ga);  System.out.println(cookie.getName()+\u0026#34;===\u0026gt;\u0026#34;+cookie.getValue());  return map;  }    @PostMapping(\u0026#34;/save\u0026#34;)  public Map postMethod(@RequestBody String content){  Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();  map.put(\u0026#34;content\u0026#34;,content);  return map;  }    //1、语法： 请求路径：/cars/sell;low=34;brand=byd,audi,yd  //2、SpringBoot默认是禁用了矩阵变量的功能  // 手动开启：原理。对于路径的处理。UrlPathHelper进行解析。  // removeSemicolonContent（移除分号内容）支持矩阵变量的  //3、矩阵变量必须有url路径变量才能被解析  @GetMapping(\u0026#34;/cars/{path}\u0026#34;)  public Map carsSell(@MatrixVariable(\u0026#34;low\u0026#34;) Integer low,  @MatrixVariable(\u0026#34;brand\u0026#34;) List\u0026lt;String\u0026gt; brand,  @PathVariable(\u0026#34;path\u0026#34;) String path){  Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();   map.put(\u0026#34;low\u0026#34;,low);  map.put(\u0026#34;brand\u0026#34;,brand);  map.put(\u0026#34;path\u0026#34;,path);  return map;  }   // /boss/1;age=20/2;age=10   @GetMapping(\u0026#34;/boss/{bossId}/{empId}\u0026#34;)  public Map boss(@MatrixVariable(value = \u0026#34;age\u0026#34;,pathVar = \u0026#34;bossId\u0026#34;) Integer bossAge,  @MatrixVariable(value = \u0026#34;age\u0026#34;,pathVar = \u0026#34;empId\u0026#34;) Integer empAge){  Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();   map.put(\u0026#34;bossAge\u0026#34;,bossAge);  map.put(\u0026#34;empAge\u0026#34;,empAge);  return map;   }  } ","id":10,"section":"posts","summary":"","tags":["SpringBoot"],"title":"SpringBoot","uri":"https://gb.ytte.top/1/01/01/springboot/","year":"0001"},{"content":"SpringCloud alibaba","id":11,"section":"posts","summary":"","tags":["SpringCloud"],"title":"SpringCloud alibaba","uri":"https://gb.ytte.top/1/01/01/springcloud-alibaba/","year":"0001"},{"content":"线程的实现方式及其优缺点 继承Thread类 public class TestCode1 extends Thread { \tprivate int i; \tpublic void run() \t{ \tfor(;i\u0026lt;100;i++) \t{ \tSystem.out.println(getName()+\u0026#34; \u0026#34;+i); \t} \t} \tpublic static void main(String[] args) \t{ \tfor(int i=0;i\u0026lt;100;i++) \t{ \tSystem.out.println(Thread.currentThread().getName()+\u0026#34; \u0026#34;+i); \tif(i==20){ \tnew TestCode1().start(); \tnew TestCode1().start(); \t} \t} \t} } 实现Runnable接口  实现Runnable接口，重写run方法，实例要作为Thread的target来创建对象，thread.start()（推荐这种，清洗可见）  class MyRunnable implements Runnable{  @Override  public void run() {  for (int i = 0; i \u0026lt; 20; i++) {  System.out.println(Thread.currentThread().getName()+\u0026#34; \u0026#34;+i);  }  } } public class MyThread {  public static void main(String[] args) {  //创建自定义类对象 线程任务对象  MyRunnable mr = new MyRunnable();  //创建线程对象  Thread t = new Thread(mr, \u0026#34;小强\u0026#34;);  t.start();  for (int i = 0; i \u0026lt; 20; i++) {  System.out.println(\u0026#34;旺财 \u0026#34; + i);  }  } }  或者在方法内直接重写  public class MyThread {  public static void main(String[] args) {   Runnable r = new Runnable(){  public void run(){  for (int i = 0; i \u0026lt; 20; i++) {  System.out.println(\u0026#34;张宇:\u0026#34;+i);  }  }  };  new Thread(r).start();  } }  直接lambda创建Runnable实现类  public class MyThread {  public static void main(String[] args) {  Runnable r = () -\u0026gt; {  for (int i = 0; i \u0026lt; 20; i++) {  System.out.println(\u0026#34;张宇:\u0026#34;+i);  }  };  new Thread(r).start();  } } 实现Callable接口   创建Callable接口的实现类，并实现Call（）方法，该方法将作为线程执行体，且该方法有返回值，再创建Callable实现类的实例。从Java8开始，可以直接使用Lambda表达式创建Callable对象。\n  使用FutureTask来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。\n  使用FutureTask对象作为Thread对象的target创建并启动新线程。\n  调用FutureTask对象的get（）方法来获取子线程执行结束后的返回值。\n  class MyCallable implements Callable {  @Override  public Object call() throws Exception {  int i = 0;  for (; i \u0026lt; 100; i++) {  Thread.sleep(100);  System.out.println(Thread.currentThread().getName() + \u0026#34;循环遍历i的值\u0026#34; + i);  }  return null;  } } public class ThreadTest {  public static void main(String[] args) {  Callable myCallable = new MyCallable();  FutureTask task = new FutureTask(myCallable);  new Thread(task).start();  for (int i = 0; i \u0026lt; 100; i++) {  try {  Thread.sleep(100);  System.out.println(Thread.currentThread().getName()+\u0026#34;循环遍历i的值\u0026#34; + i);  }  catch (Exception e) {  e.printStackTrace();  }  }  } }  //lambda方式 public class ThreadTest {  public static void main(String[] args) {  FutureTask\u0026lt;Integer\u0026gt; task = new FutureTask\u0026lt;\u0026gt;(()-\u0026gt;{  int i=0;  for(;i\u0026lt;100;i++){  System.out.println(Thread.currentThread().getName()+\u0026#34;循环变量i的值：\u0026#34;+i);  }  return i;  });  for(int i=0;i\u0026lt;100;i++){  System.out.println(Thread.currentThread().getName()+\u0026#34;循环变量i的值：\u0026#34;+i);  if(i==20){  new Thread(task,\u0026#34;有返回值的线程\u0026#34;).start();  }  try{  System.out.println(\u0026#34;子线程的返回值：\u0026#34;+task.get());  }  catch (Exception e) {  e.printStackTrace();  }  }  } } 异同点和优缺点 异同点   相同点\n 都可以实现多线程 Runnable与Callable实现方式类似    不同点\n Thread方式是通过继承来实现。 Runnable与Callable是通过实现接口方式创建线程。 Runnable与Callable  因为通过FutureTask包装Callable接口，FutureTask有get方法可以获取返回值，所以只有这种方式创建的子线程有返回值。 run方法无法抛出异常，call方法可以抛出checked exception。 Callable和Runnable都可以应用于executors。而Thread类只支持Runnable.      优缺点   优点\n  Thread\n 编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this即可获得当前线程。    Runnable与Callable\n 可以继承其他类 多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。      缺点\n Thread  继承的局限性，不能继承其他类   Runnable与Callable  编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread（）方法。      补充 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。\n子线程执行完，主线程执行 正常如1中的各种实现方式 Local跳转方式，Shimo跳转方式，主线程与子线程是争夺线程资源的，所以一般情况是会出现类似交替执行的状况。\nFutureTask来包装Callable对象 上方（ Local跳转方式，Shimo跳转方式）的这种是子线程无返回值的情况，这种情况下，子线程与多线程可以争夺线程资源，\n如果为子线程添加返回值，使用 FutureTask来包装Callable对象，通过task.get()来获取返回值，主线程进行到task.get()时，如果子线程还在执行，没有返回，主线程就会子线程返回之前等待挂起。从而达到要求。\npublic class TestCode3 { \tpublic static void main(String[] args) { \tFutureTask\u0026lt;Integer\u0026gt; task = new FutureTask\u0026lt;Integer\u0026gt;((Callable\u0026lt;Integer\u0026gt;)()-\u0026gt;{ \tint i=0; \tfor(;i\u0026lt;100;i++){ \tSystem.out.println(Thread.currentThread().getName()+\u0026#34;循环变量i的值：\u0026#34;+i); \t} \treturn i; \t}); \tfor(int i=0;i\u0026lt;100;i++){ \tSystem.out.println(Thread.currentThread().getName()+\u0026#34;循环变量i的值：\u0026#34;+i); \tif(i==20){ \tnew Thread(task,\u0026#34;有返回值的线程\u0026#34;).start(); \t} \ttry{ \tSystem.out.println(\u0026#34;子线程的返回值：\u0026#34;+task.get()); \t} \tcatch (Exception e) { \te.printStackTrace(); \t} \t} \t} } join方法 参考资料链接\n结论：t.join()方法只会使主线程(或者说调用t.join()的线程)进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。\nt.join方法底层中使用wait(0)方法，即使用了该方法的线程会进入无限等待中，直到 t 执行完成才返回。进入等待的只是调用了join方法的线程，其他线程没开启的不会开启，开启了的不会等待继续执行。\npublic class TestJoin { \tpublic static void main(String[] args) throws InterruptedException { \t// TODO Auto-generated method stub \tSystem.out.println(Thread.currentThread().getName()+\u0026#34; start\u0026#34;); \tThreadTest t1=new ThreadTest(\u0026#34;A\u0026#34;); \tThreadTest t2=new ThreadTest(\u0026#34;B\u0026#34;); \tThreadTest t3=new ThreadTest(\u0026#34;C\u0026#34;); \tSystem.out.println(\u0026#34;t1start\u0026#34;); \tt1.start(); \tSystem.out.println(\u0026#34;t1end\u0026#34;); \tSystem.out.println(\u0026#34;t2start\u0026#34;); \tt2.start(); \tSystem.out.println(\u0026#34;t2end\u0026#34;); \tt1.join(); \tSystem.out.println(\u0026#34;t3start\u0026#34;); \tt3.start(); \tSystem.out.println(\u0026#34;t3end\u0026#34;); \tSystem.out.println(Thread.currentThread().getName()+\u0026#34; end\u0026#34;); \t} } 结果：\nmain start t1start t1end t2start t2end A-1 B-1 A-2 A-3 A-4 A-5 B-2 t3start t3end B-3 main end B-4 B-5 C-1 C-2 C-3 C-4 C-5 主线程在t1.join()方法处停止，并需要等待A线程执行完毕后才会执行t3.start()，然而，并不影响B线程的执行。因此，可以得出结论，t.join()方法只会使主线程进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。\n join源码中，只会调用wait方法，并没有在结束时调用notify，这是因为==线程在die的时候会自动调用自身的notifyAll方法，来释放所有的资源和锁。==\n 线程与线程池的状态 线程的状态（NRBWTT）（牛肉包我舔舔）  NEW\t尚未启动 RUNNABLE 正在执⾏中 BLOCKED 阻塞的（被同步锁或者IO锁阻塞） WAITING 永久等待状态 TIMED_WAITING 等待指定的时间重新被唤醒的状态 TERMINATED 执⾏完成  线程池的状态（RSSTT）（人事是傻甜甜）   RUNNING： 这是最正常的状态 ，接受新的任务，处理等待队列中的任务 。\n  SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。\n  STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执⾏任务的线程。\n  TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执⾏钩⼦⽅法 terminated()。\n  TERMINATED：terminated()⽅法结束后，线程池的状态就会变成这个。\n  线程池 大佬链接====》线程池1_CSDN博客\n大佬链接====》线程池2-CSDN博客\n线程池的优点   降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n  提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n  **提高线程的可管理性。**线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n  线程池的继承树 线程池地使用 线程池的真正实现类是ThreadPoolExecutor ，其构造器方法有以下4种：\npublic ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize,  long keepAliveTime,  TimeUnit unit,  BlockingQueue\u0026lt;Runnable\u0026gt; workQueue) {  this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,  Executors.defaultThreadFactory(), defaultHandler); }  public ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize,  long keepAliveTime,  TimeUnit unit,  BlockingQueue\u0026lt;Runnable\u0026gt; workQueue,  ThreadFactory threadFactory) {  this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,  threadFactory, defaultHandler); }  public ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize,  long keepAliveTime,  TimeUnit unit,  BlockingQueue\u0026lt;Runnable\u0026gt; workQueue,  RejectedExecutionHandler handler) {  this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,  Executors.defaultThreadFactory(), handler); }  public ThreadPoolExecutor(int corePoolSize,  int maximumPoolSize,  long keepAliveTime,  TimeUnit unit,  BlockingQueue\u0026lt;Runnable\u0026gt; workQueue,  ThreadFactory threadFactory,  RejectedExecutionHandler handler) {  if (corePoolSize \u0026lt; 0 ||  maximumPoolSize \u0026lt;= 0 ||  maximumPoolSize \u0026lt; corePoolSize ||  keepAliveTime \u0026lt; 0)  throw new IllegalArgumentException();  if (workQueue == null || threadFactory == null || handler == null)  throw new NullPointerException();  this.corePoolSize = corePoolSize;  this.maximumPoolSize = maximumPoolSize;  this.workQueue = workQueue;  this.keepAliveTime = unit.toNanos(keepAliveTime);  this.threadFactory = threadFactory;  this.handler = handler; } 参数说明：IPHP  corePoolSize（必需）：核心线程数。默认情况下，核心线程会一直存活，但是当将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。 maximumPoolSize（必需）：线程池所能容纳的最大线程数。当活跃线程数达到该数值后，后续的新任务将会阻塞。 keepAliveTime（必需）：线程闲置超时时长。如果超过该时长，非核心线程就会被回收。如果将 allowCoreThreadTimeout 设置为 true 时，核心线程也会超时回收。 unit（必需）：指定 keepAliveTime 参数的时间单位。常用的有：TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）。 workQueue（必需）：任务队列。通过线程池的 execute() 方法提交的 Runnable 对象将存储在该参数中。其采用阻塞队列实现。 threadFactory（可选）：线程工厂。用于指定为线程池创建新线程的方式。 handler（可选）：拒绝策略。当达到最大线程数时需要执行的饱和策略。  线程池的使用流程：\n// 创建线程池 ThreadPoolExecutor threadPool = new ThreadPoolExecutor(CORE_POOL_SIZE,  MAXIMUM_POOL_SIZE,  KEEP_ALIVE,  TimeUnit.SECONDS,  sPoolWorkQueue,  sThreadFactory); // 向线程池提交任务 threadPool.execute(new Runnable() {  @Override  public void run() {  ... // 线程执行的任务  } }); // 关闭线程池 threadPool.shutdown(); // 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程 threadPool.shutdownNow(); // 设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表 线程池的工作原理 简概：IPHP  1.如果线程数小于corePoolSize，创建一个新核心线程来运行新任务。 2.如果线程数大于等于corePoolSize但小于maximumPoolSize，则将任务放入队列。 3.如果队列已满，并且线程数小于maxPoolSize，则创建一个新非核心线程来运行任务。 4.如果队列已满，并且线程数大于或等于maxPoolSize，则拒绝该任务。  是否需要增加线程的判断顺序是：1、corePoolSize 2、workQueue 3、maxPoolSize\n举个例子：\n线程池的核心线程数corePoolSize大小为5，最大池maxPoolSize大小为10，队列workQueue为100。\n因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程，最多到10个线程，如果再来任务，就拒绝。\n特点：\n 通过设置corePoolSize和maximumPoolSize 相同，就可以创建固定大小的线程池。 我们使用线程池一般希望保持较少的线程数，并且只有在负载变得很大时才增加它。 通过设置maximumPoolSize为很高的值，例如 Integer.MAX_VALUE，可以允许线程池容纳任意数量的并发任务。 只有在队列填满时才创建多于corePoolSize的非核心线程，如果使用的是无界队列（例如LinkedBlockingQueue），那么线程数就不会超过corePoolSize。  线程参数解析 任务队列workQueue 任务队列是基于阻塞队列实现的，即采用生产者消费者模式，在 Java 中需要实现 BlockingQueue 接口。但 Java 已经为我们提供了 7 种阻塞队列的实现：\n  ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列（数组结构可配合指针实现一个环形队列）。\n  LinkedBlockingQueue： 一个由链表结构组成的有界阻塞队列，在未指明容量时，容量默认为Integer.MAX_VALUE。\n 这种队列容量无限大，可以防止流量突增。设置maximumPoolSize也用不到，因为队列装不满，永远不需要创建新的非核心线程。但是也有风险，处理任务的速度跟不上提交的速度，可能造成内存浪费或者OOM。\n   PriorityBlockingQueue： 一个支持优先级排序的无界阻塞队列，对元素没有要求，可以实现 Comparable 接口也可以提供 Comparator 来对队列中的元素进行比较。跟时间没有任何关系，仅仅是按照优先级取任务。\n  DelayQueue：类似于PriorityBlockingQueue，是二叉堆实现的无界优先级阻塞队列。要求元素都实现 Delayed 接口，通过执行时延从队列中提取任务，时间没到任务取不出来。\n  SynchronousQueue： 一个不存储元素的阻塞队列，消费者线程调用 take() 方法的时候就会发生阻塞，直到有一个生产者线程生产了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用 put() 方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。\n 工作任务不多的情况下，只是将任务中转，就可以用SynchronousQueue，这个队列本身内部没有容量，使用这种队列，maximumPoolSize就可能需要设置的大一些。因为没有队列容量作为缓冲了，很容易创建新线程。\n   LinkedBlockingDeque： 使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样 FIFO（先进先出），也可以像栈一样 FILO（先进后出）。\n  LinkedTransferQueue： 它是ConcurrentLinkedQueue、LinkedBlockingQueue 和 SynchronousQueue 的结合体，但是把它用在 ThreadPoolExecutor 中，和 LinkedBlockingQueue 行为一致，但是是无界的阻塞队列。\n  注意有界队列和无界队列的区别：如果使用有界队列，当队列饱和时并超过最大线程数时就会执行拒绝策略；而如果使用无界队列，因为任务队列永远都可以添加任务，所以设置 maximumPoolSize 没有任何意义。\n线程工厂（threadFactory） 线程工厂指定创建线程的方式，需要实现 ThreadFactory 接口，并实现 newThread(Runnable r) 方法。\n 新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory() 创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。 如果自己指定ThreadFactory，那么就可以改变线程名、线程组、优先级、是否是守护线程等。 通常使用默认的ThreadFactory就可以了  // 验证第一点，新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory() public static ThreadFactory defaultThreadFactory() {  return new DefaultThreadFactory(); }  ......  static class DefaultThreadFactory implements ThreadFactory {  private static final AtomicInteger poolNumber = new AtomicInteger(1);  private final ThreadGroup group;  private final AtomicInteger threadNumber = new AtomicInteger(1);  private final String namePrefix;   DefaultThreadFactory() {  SecurityManager s = System.getSecurityManager();  group = (s != null) ? s.getThreadGroup() :  Thread.currentThread().getThreadGroup();  namePrefix = \u0026#34;pool-\u0026#34; +  poolNumber.getAndIncrement() +  \u0026#34;-thread-\u0026#34;;  }   public Thread newThread(Runnable r) {  // 验证第二点，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。  Thread t = new Thread(group, r,  namePrefix + threadNumber.getAndIncrement(),  0);  if (t.isDaemon())  t.setDaemon(false);  if (t.getPriority() != Thread.NORM_PRIORITY)  t.setPriority(Thread.NORM_PRIORITY);  return t;  }  } 拒绝策略（handler） 当线程池的线程数达到最大线程数时，需要执行拒绝策略。拒绝策略需要实现 RejectedExecutionHandler 接口，并实现 rejectedExecution(Runnable r, ThreadPoolExecutor executor) 方法。不过 Executors 框架已经为我们实现了 4 种拒绝策略：\n AbortPolicy（默认）：丢弃任务并抛出 RejectedExecutionException 异常。 CallerRunsPolicy：由调用线程处理该任务。 DiscardPolicy：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。 DiscardOldestPolicy：丢弃队列最早的未处理任务，然后重新尝试执行任务。  功能线程池 嫌上面使用线程池的方法太麻烦？其实Executors已经为我们封装好了 4 种常见的功能线程池，如下：\n 定长线程池（FixedThreadPool） 定时线程池（ScheduledThreadPool ） 可缓存线程池（CachedThreadPool） 单线程化线程池（SingleThreadExecutor）  定长线程池（FixedThreadPool） public static ExecutorService newFixedThreadPool(int nThreads) {  return new ThreadPoolExecutor(nThreads, nThreads,  0L, TimeUnit.MILLISECONDS,  new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); } public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {  return new ThreadPoolExecutor(nThreads, nThreads,  0L, TimeUnit.MILLISECONDS,  new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;(),  threadFactory); }  特点：只有核心线程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。 应用场景：控制线程最大并发数。  使用：\n// 1. 创建定长线程池对象 \u0026amp; 设置线程池线程数量固定为3 ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); // 2. 创建好Runnable类线程对象 \u0026amp; 需执行的任务 Runnable task =new Runnable(){  public void run() {  System.out.println(\u0026#34;执行任务啦\u0026#34;);  } }; // 3. 向线程池提交任务 fixedThreadPool.execute(task); 定时线程池（ScheduledThreadPool ）  private static final long DEFAULT_KEEPALIVE_MILLIS = 10L;  public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {  return new ScheduledThreadPoolExecutor(corePoolSize); } public ScheduledThreadPoolExecutor(int corePoolSize) {  super(corePoolSize, Integer.MAX_VALUE,  DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,  new DelayedWorkQueue()); }  public static ScheduledExecutorService newScheduledThreadPool(  int corePoolSize, ThreadFactory threadFactory) {  return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory); } public ScheduledThreadPoolExecutor(int corePoolSize,  ThreadFactory threadFactory) {  super(corePoolSize, Integer.MAX_VALUE,  DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,  new DelayedWorkQueue(), threadFactory); }  特点：核心线程数量固定，非核心线程数量无限，执行完闲置 10ms 后回收，任务队列为延时阻塞队列。 应用场景：执行定时或周期性的任务。  // 1. 创建 定时线程池对象 \u0026amp; 设置线程池线程数量固定为5 ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); // 2. 创建好Runnable类线程对象 \u0026amp; 需执行的任务 Runnable task =new Runnable(){  public void run() {  System.out.println(\u0026#34;执行任务啦\u0026#34;);  } }; // 3. 向线程池提交任务 scheduledThreadPool.schedule(task, 1, TimeUnit.SECONDS); // 延迟1s后执行任务 scheduledThreadPool.scheduleAtFixedRate(task,10,1000,TimeUnit.MILLISECONDS);// 延迟10ms后、每隔1000ms执行任务 可缓存线程池（CachedThreadPool）  public static ExecutorService newCachedThreadPool() {  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,  60L, TimeUnit.SECONDS,  new SynchronousQueue\u0026lt;Runnable\u0026gt;()); } public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,  60L, TimeUnit.SECONDS,  new SynchronousQueue\u0026lt;Runnable\u0026gt;(),  threadFactory); }  特点：无核心线程，非核心线程数量无限，执行完闲置 60s 后回收，任务队列为不存储元素的阻塞队列。 应用场景：执行大量、耗时少的任务。  // 1. 创建可缓存线程池对象 ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); // 2. 创建好Runnable类线程对象 \u0026amp; 需执行的任务 Runnable task =new Runnable(){  public void run() {  System.out.println(\u0026#34;执行任务啦\u0026#34;);  } }; // 3. 向线程池提交任务 cachedThreadPool.execute(task) 单线程化线程池（SingleThreadExecutor） public static ExecutorService newSingleThreadExecutor() {  return new FinalizableDelegatedExecutorService  (new ThreadPoolExecutor(1, 1,  0L, TimeUnit.MILLISECONDS,  new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;())); } public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {  return new FinalizableDelegatedExecutorService  (new ThreadPoolExecutor(1, 1,  0L, TimeUnit.MILLISECONDS,  new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;(),  threadFactory)); }  特点：只有 1 个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。 应用场景：不适合并发但可能引起 IO 阻塞性及影响 UI 线程响应的操作，如数据库操作、文件操作等。  // 1. 创建单线程化线程池 ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); // 2. 创建好Runnable类线程对象 \u0026amp; 需执行的任务 Runnable task =new Runnable(){  public void run() {  System.out.println(\u0026#34;执行任务啦\u0026#34;);  } }; // 3. 向线程池提交任务 singleThreadExecutor.execute(task); 对比 线程池模板 大佬链接====》Spring线程池配置模板- 博客园 \n@EnableAsync @Configuration public class LogThreadPoolConfig {   @Bean(name = \u0026#34;logThreadPool\u0026#34;)  public ThreadPoolTaskExecutor LogThreadPoolTask() {  ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();  LogThreadPoolProperties properties = this.logThreadPoolProperties();   executor.setCorePoolSize(properties.getCorePoolSize());  executor.setMaxPoolSize(properties.getMaxPoolSize());  executor.setQueueCapacity(properties.getQueueCapacity());  executor.setKeepAliveSeconds(properties.getKeepAliveSeconds());  executor.setThreadNamePrefix(properties.getThreadName());  switch (properties.getRejectedExecutionHandler()) {  case \u0026#34;abortPolicy\u0026#34;:  executor.setRejectedExecutionHandler(new AbortPolicy());  break;  case \u0026#34;callerRunsPolicy\u0026#34;:  executor.setRejectedExecutionHandler(new CallerRunsPolicy());  break;  case \u0026#34;discardOldestPolicy\u0026#34;:  executor.setRejectedExecutionHandler(new DiscardOldestPolicy());  break;  case \u0026#34;discardPolicy\u0026#34;:  executor.setRejectedExecutionHandler(new DiscardOldestPolicy());  break;  default:  executor.setRejectedExecutionHandler(new CallerRunsPolicy());  break;  }  executor.initialize();  return executor;  }    @Bean  @ConfigurationProperties(prefix = \u0026#34;threadpool.log\u0026#34;)  public LogThreadPoolProperties logThreadPoolProperties() {  return new LogThreadPoolProperties();  }    //@Getter lombok提供的getset方法生成注解  //@Setter  @Configuration  public static class LogThreadPoolProperties {   /** * 线程前缀名 */  private String threadName;  /** * 核心线程池大小 */  private int corePoolSize;  /** * 最大线程数 */  private int maxPoolSize;  /** * 队列大小 */  private int queueCapacity;  /** * 线程池维护空闲线程存在时间 */  private int keepAliveSeconds;  /** * 拒绝策略 */  private String rejectedExecutionHandler;   } } 这样就可以在yml文件中配置参数了：\nthreadpool:  log:  threadName: ThreadPool-log- # 线程池前缀名  corePoolSize: 8 # 核心线程池数：IO型推荐设置为cpu核心数*2；cpu型推荐设置为cpu数+1  maxPoolSize: 16 # 最大线程池数  queueCapacity: 1000 # 线程池阻塞队列容量  keepAliveSeconds: 60 # 允许线程空闲时间  # 拒绝策略 abortPolicy callerRunsPolicy discardOldestPolicy discardPolicy  rejectedExecutionHandler: callerRunsPolicy 使用：\nSpring提供了注解方式来方便我们使用线程池，只需要在要异步处理的方法上加 @Async(\u0026ldquo;你配置的线程池名字\u0026rdquo;)就可以了,注意这个类需要被spring扫描并纳入管理，所以要加@Service、@Component等注解。\n@Service public class ServiceImpl implements Service {   @Override  @Async(\u0026#34;logThreadPool\u0026#34;)  public void addOperationLog(BaseLog baseLog) {  //你要异步执行的逻辑  } } 小总结  ==Executors 的 4 个功能线程池虽然方便，但现在已经不建议使用了，而是建议直接通过使用 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。==  其实 Executors 的 4 个功能线程有如下弊端：\n FixedThreadPool 和 SingleThreadExecutor：主要问题是堆积的请求处理队列均采用 LinkedBlockingQueue，可能会耗费非常大的内存，甚至 OOM。 CachedThreadPool 和 ScheduledThreadPool：主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。  线程池里的线程数量设定为多少比较合适？  这个得看任务类型\n CPU密集型（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。 耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般会大于CPU核心数很多倍 ，参考Brain Goetz专家推荐的计算方法：线程数=CPU核心数*（1+平均等待时间/平均工作时间）  如果需要更精确的线程数量，那就需要根据不同的程序去做压测，这样就能得到比较合适的线程数量。\nThreadLocal 概念 ThreadLocal叫做线程变量，ThreadLocal中填充的变量 属于当前线程，该变量对其他线程而言是隔离的。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。\nThreadLocal 适用于每个线程变量在线程间隔离而在方法或类间共享的场景。\nThreadLocal与Synchronized的区别   ThreadLocal\nThreadLocal则用于线程间的数据隔离。ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象\n  Synchronized\nSynchronized用于线程间的数据共享。利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。\n  使用 public class ThreadLocaDemo {   private static ThreadLocal\u0026lt;String\u0026gt; localVar = new ThreadLocal\u0026lt;String\u0026gt;();   static void print(String str) {  //打印当前线程中本地内存中本地变量的值  System.out.println(str + \u0026#34; :\u0026#34; + localVar.get());  //清除本地内存中的本地变量  localVar.remove();  }  public static void main(String[] args) throws InterruptedException {   new Thread(new Runnable() {  public void run() {  ThreadLocaDemo.localVar.set(\u0026#34;local_A\u0026#34;);  print(\u0026#34;A\u0026#34;);  //打印本地变量  System.out.println(\u0026#34;after remove : \u0026#34; + localVar.get());   }  },\u0026#34;A\u0026#34;).start();   Thread.sleep(1000);   new Thread(new Runnable() {  public void run() {  ThreadLocaDemo.localVar.set(\u0026#34;local_B\u0026#34;);  print(\u0026#34;B\u0026#34;);  System.out.println(\u0026#34;after remove : \u0026#34; + localVar.get());   }  },\u0026#34;B\u0026#34;).start();  } } A :local_A after remove : null B :local_B after remove : null set() ==向ThreadLocal里面存东西就是向它里面的Map存东西的，然后ThreadLocal把这个Map挂到当前的线程底下==\n public void set(T value) {  //1、获取当前线程  Thread t = Thread.currentThread();  //2、获取线程中的属性 threadLocalMap ,如果threadLocalMap 不为空，  //则直接更新要保存的变量值，否则创建threadLocalMap，并赋值  ThreadLocalMap map = getMap(t);  if (map != null)  map.set(this, value);  else  // 初始化thradLocalMap 并赋值  createMap(t, value);  } 从上面的代码可以看出，ThreadLocal set赋值的时候首先会获取当前线程thread,并获取thread线程中的ThreadLocalMap属性。如果map属性不为空，则直接更新value值，如果map为空，则实例化threadLocalMap,并将value值初始化。\n==ThreadLocalMap呢是当前线程Thread一个叫threadLocals的变量中获取的。每个线程Thread都维护了自己的threadLocals变量，所以在每个线程创建ThreadLocal的时候，实际上数据是存在自己线程Thread的threadLocals变量里面的，别人没办法拿到，从而实现了隔离。==\nThreadLocalMap getMap(Thread t) {  return t.threadLocals;  }  static class ThreadLocalMap {  /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as \u0026#34;stale entries\u0026#34; in the code that follows. */  static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; {  /** The value associated with this ThreadLocal. */  Object value;   Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) {  super(k);  value = v;  }  }  } 可看出ThreadLocalMap是ThreadLocal的内部静态类，而它的构成主要是用Entry来保存数据 ，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。IPHP姬祥todo createMap\nget()  public T get() {  //1、获取当前线程  Thread t = Thread.currentThread();  //2、获取当前线程的ThreadLocalMap  ThreadLocalMap map = getMap(t);  //3、如果map数据为空，  if (map != null) {  //3.1、获取threalLocalMap中存储的值  ThreadLocalMap.Entry e = map.getEntry(this);  if (e != null) {  @SuppressWarnings(\u0026#34;unchecked\u0026#34;)  T result = (T)e.value;  return result;  }  }  //如果是数据为null，则初始化，初始化的结果，TheralLocalMap中存放key值为threadLocal，值为null  return setInitialValue();  }  private T setInitialValue() {  T value = initialValue();  Thread t = Thread.currentThread();  ThreadLocalMap map = getMap(t);  if (map != null)  map.set(this, value);  else  createMap(t, value);  return value;  } remove()  public void remove() {  ThreadLocalMap m = getMap(Thread.currentThread());  if (m != null)  m.remove(this); } remove方法，直接将ThrealLocal 对应的值从当前相差Thread中的ThreadLocalMap中删除。为什么要删除，这涉及到内存泄露的问题。\n如上所说（Local跳转方式，Shimo跳转方式）， ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。\n所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。这样就造成了内存泄露。\nThreadLocal与Thread，ThreadLocalMap之间的关系 ThreadLocal 常见使用场景 参考====》ThreadLocal的应用场景 - sw_kong - 博客园 (cnblogs.com)\n场景的需求：\n 每个线程需要有自己单独的实例 实例需要在多个方法中共享，但不希望变量被多线程共享 ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。  SimpleDateFormat （Java8里的 java.time.format.DateTimeFormatter 是线程安全的 ，由于它调用的parseResolved0 方法入参都是final 修饰的，不可变变量是线程安全的。）\n当时我们使用SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear（），然后调用Calendar.add()。ThreadLocal_敖丙-CSDN博客。如果一个线程先调用了add()然后另一个线程又调用了clear()，这时候parse()方法解析的时间就不对了。\n在这种情况下，每个Thread内都有自己的实例副本，且该副本只能由当前Thread访问到并使用，相当于每个线程内部的本地变量，这也是ThreadLocal命名的含义。因为每个线程独享副本，而不是公用的，所以不存在多线程间共享的问题。\n比如有1000个线程都要用到SimpleDateFormat\npublic class ThreadLocalDemo011 {  public static ExecutorService threadPool = Executors.newFixedThreadPool(16);   public static void main(String[] args) throws InterruptedException {   for (int i = 0; i \u0026lt; 1000; i++) {  int finalI = i;  threadPool.submit(() -\u0026gt; {  String data = new ThreadLocalDemo011().date(finalI);  System.out.println(data);  });  }  threadPool.shutdown();  }  public static Integer id= 0;  private String date(int seconds){  Date date = new Date(1000 * seconds);  id++;  System.out.println(id+\u0026#34;=============\u0026#34;);  SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\u0026#34;mm:ss\u0026#34;);  return simpleDateFormat.format(date);  } } 可以看出，我们用了一个16线程的线程池，并且给这个线程池提交了1000次任务。每个任务中它做的事情和之前是一样的，还是去执行date方法，并且在这个方法中创建一个simpleDateFormat 对象。近1000个simpleDateFormat 对象会被创建。\n这么多对象的创建是有开销的，并且在使用完之后的销毁同样是有开销的，同时存在在内存中也是一种内存的浪费。\n我们可能会想到，要不所有的线程共用一个 simpleDateFormat 对象？但是simpleDateFormat 又不是线程安全的，我们必须做同步，比如使用synchronized加锁。到这里也许就是我们最终的一个解决方法。但是使用synchronized加锁会陷入一种排队的状态，多个线程不能同时工作，这样一来，整体的效率就被大大降低了。\n 使用ThreadLocal  对这种场景，ThreadLocal再合适不过了，ThreadLocal给每个线程维护一个自己的simpleDateFormat对象，这个对象在线程之间是独立的，互相没有关系的。这也就避免了线程安全问题。与此同时，simpleDateFormat对象还不会创造过多，线程池一共只有 16 个线程，所以需要16个对象即可。\npublic class ThreadLocalDemo04 {   public static ExecutorService threadPool = Executors.newFixedThreadPool(16);   public static void main(String[] args) throws InterruptedException {   for (int i = 0; i \u0026lt; 1000; i++) {  int finalI = i;  threadPool.submit(() -\u0026gt; {  String data = new ThreadLocalDemo04().date(finalI);  System.out.println(data);  });  }  threadPool.shutdown();  }   private String date(int seconds){  Date date = new Date(1000 * seconds);  SimpleDateFormat dateFormat = ThreadSafeFormater.dateFormatThreadLocal.get();  return dateFormat.format(date);  } }  class ThreadSafeFormater{  public static Integer id= 0;  public static ThreadLocal\u0026lt;SimpleDateFormat\u0026gt; dateFormatThreadLocal = ThreadLocal.withInitial(() -\u0026gt; {  id++;  System.out.println(id+\u0026#34;=============\u0026#34;);  return new SimpleDateFormat(\u0026#34;mm:ss\u0026#34;);  }); }   结果：\n可以看出只创建了16个SimpleDateFormat对象。\n  1=============\r4=============\r5=============\r6=============\r3=============\r7=============\r2=============\r8=============\r9=============\r10=============\r11=============\r13=============\r12=============\r14=============\r15=============\r16=============\r00:09\r00:16\r00:17\r........\r........\r16:05\r16:04\r16:03\r16:02  问题：  这种情况每个线程的SimpleDataFormat的parse()方法，在一个任务执行后其他任务继续使用这个线程执行任务时，会不会造成数据混乱。   答案  不会，SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear()清除数据，然后调用Calendar.add()添加数据。    用户信息（类似线程内的全局变量） 每个线程内需要保存类似于全局变量的信息（例如在拦截器中获取的用户信息），可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享（因为不同线程获取到的用户信息不一样）。\n例如，用 ThreadLocal 保存一些业务内容（用户权限信息、从用户系统获取到的用户名、用户ID 等），这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。\n在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，避免了将这个对象（如 user 对象）作为参数传递的麻烦。\n比如说我们是一个用户系统，那么当一个请求进来的时候，一个线程会负责执行这个请求，然后这个请求就会依次调用service-1()、service-2()、service-3()、service-4()，这4个方法可能是分布在不同的类中的。\npackage com.kong.threadlocal;   public class ThreadLocalDemo05 {  public static void main(String[] args) {  User user = new User(\u0026#34;jack\u0026#34;);  new Service1().service1(user);  } }  class Service1 {  public void service1(User user){  //给ThreadLocal赋值，后续的服务直接通过ThreadLocal获取就行了。  UserContextHolder.holder.set(user);  new Service2().service2();  } }  class Service2 {  public void service2(){  User user = UserContextHolder.holder.get();  System.out.println(\u0026#34;service2拿到的用户:\u0026#34;+user.name);  new Service3().service3();  } }  class Service3 {  public void service3(){  User user = UserContextHolder.holder.get();  System.out.println(\u0026#34;service3拿到的用户:\u0026#34;+user.name);  //在整个流程执行完毕后，一定要执行remove  UserContextHolder.holder.remove();  } }  class UserContextHolder {  //创建ThreadLocal保存User对象  public static ThreadLocal\u0026lt;User\u0026gt; holder = new ThreadLocal\u0026lt;\u0026gt;(); }  class User {  String name;  public User(String name){  this.name = name;  } } 守护线程 面试题 线程池创建的4中方法 Local跳转方式，Shimo跳转方式\n任务加入的线程池的流程 Local跳转方式，Shimo跳转方式\n线程池的7个参数。拒绝策略。 参数：Local跳转方式，Shimo跳转方式\n拒绝策略：Local跳转方式，Shimo跳转方式\n线程池中如何拿到线程的执行结果 线程池中 submit()和 execute()方法有什么区别？   execute()：只能执⾏ Runnable 类型的任务。\n  submit()：可以执⾏ Runnable 和 Callable 类型的任务。\n  死锁 两线程都有各自的锁，并都尝试去获取独占对方的锁，就会发生阻塞的现象。\n解释下生产消费模型 生产者消费者能够解决的问题如下：\n 生产与消费的速度不匹配 软件开发过程中解耦  生产者生产，消费者消费，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架满的时候，消费者可以从货架上拿走商品，生产者此时等待货架的空位，这样不断的循环。那么在这个过程中，生产者和消费者是不直接接触的，所谓的‘货架’其实就是一个==阻塞队列==，生产者生产的产品不直接给消费者消费，而是仍给阻塞队列，这个阻塞队列就是来解决生产者消费者的强耦合的。就是生产者消费者模型。TP①，TP②\n参考  ThreadLocal原理分析与使用场景 - 阿凡卢 - 博客园 (cnblogs.com) ThreadLocal的应用场景 - sw_kong - 博客园 (cnblogs.com) ThreadLocal_敖丙-CSDN博客 CSDN博客_生产者消费者模型 Java8之Consumer、Supplier、Predicate和Function攻略 博客园 ","id":12,"section":"posts","summary":"","tags":["Thread"],"title":"Thread","uri":"https://gb.ytte.top/1/01/01/thread/","year":"0001"},{"content":"使用typora写文档传图片，再上传石墨等网站的好方法 1. typora下载 typora开始收费，我们可以使用不收费的老版本 下载链接\n2. typora图床 picgotypora不像word，word可以直接将上传的图片保存在文件当中，而typora不行。但是typora支持picgo插件的使用，所以，我们下在picgo 下载链接\n3. 七牛云和picgo的使用，二级域名（如果不想弄直接第4步骤） 注册七牛云 ，并开通对象存储 picgo使用七牛云图床 - 知乎 。为七牛云配置二级域名（前提是有了一级域名）：二级域名-石墨\n4. picgo 配置： 进入picgo，点击左侧的图床设置，选择七牛图床。按下图所示填写配置，SecretKey向 j j 索取。\n SbOIcbA56xQGcpZyyLDtuARvi3COHhlBxa-IZxDi\nytte-picgo\nhttps://blogimg.ytte.top/\nz2\nimg-sunsifan/或者是img-wuhao\n 伍昊：\n孙思凡：\n将最后 一项，指定存储路径更改为：img-sunsifan。\n5. typora设置   打开typora后，\n  点击左上角文件，\n  点击偏好设置，\n  点击图像，\n  如图进行配置，\n   成功就会出现如图信息，  ==大功告成==\n6. picgo的使用 使用截图软件截图，打开picgo点记左侧的上传区，点击剪切板图片上传，上传成功后自动将图片地址返回到剪切板当中。\n 注意：如果直接截图后直接粘贴到typora文中，使用的是标签，在有的编辑器不能正常识别（比如石墨），所以最好先按上面方法。\n","id":13,"section":"posts","summary":"","tags":["typora"],"title":"typora","uri":"https://gb.ytte.top/1/01/01/typora/","year":"0001"},{"content":"谷粒商城步骤笔记 使用人人代码生成器 视频====》谷粒商城——p17\n  clone人人代码生成器\n  放进项目中加入模块\n  在application.yml修改数据库相关信息\n  在generator.properties中修改参数\nmainPath=com.atguigu #包名 package=com.atguigu.gulimall moduleName=product #作者 author=yttejx #Email email=1026190684@qq.com #表前缀(类名不会包含表前缀) tablePrefix=pms_   更改renren-generator的resources的template的Controller模板中@RequiresPermissions注解和导包注释掉，以后再导入使用。\n  启动renren-generator的Application。网页访问localhost:80，点击显示全部表格，全选表格，点击生成代码。\n  将生成的代码中main包复制粘贴到product项目下。\n  新建模块（maven）取名，gulimall_common（项目的公共资源全部放在这里）\n  查看product项目中报错信息。将相应的pom 和类（renren自己创建的工具类）加入到common项目中\n从renren-faster中导入\n  包：\n exception utils  Constant PageUtils Query R validator xss  去掉XssFilter和XssHttpServletRequestWrapper，是防跨站脚本攻击的，以后用springsecurity来实现。 这里需要导包Servlet，同时设置scope 为provided，因为tomcat内有Servlet        pom：\n  \u0026lt;properties\u0026gt; \t\u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt;  \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt;  \u0026lt;mybatis.plus.boot.starter.version\u0026gt;3.5.1\u0026lt;/mybatis.plus.boot.starter.version\u0026gt;  \u0026lt;lombok.version\u0026gt;1.18.22\u0026lt;/lombok.version\u0026gt;  \u0026lt;commons.lang.version\u0026gt;2.6\u0026lt;/commons.lang.version\u0026gt;  \u0026lt;httpcore.version\u0026gt;4.4.15\u0026lt;/httpcore.version\u0026gt;  \u0026lt;shiro.version\u0026gt;1.4.0\u0026lt;/shiro.version\u0026gt;  \u0026lt;commons.io.version\u0026gt;2.5\u0026lt;/commons.io.version\u0026gt;  \u0026lt;mysql.connector.version\u0026gt;8.0.28\u0026lt;/mysql.connector.version\u0026gt;  \u0026lt;/properties\u0026gt;  \u0026lt;dependencies\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${mybatis.plus.boot.starter.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;commons-lang\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;commons-lang\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${commons.lang.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore --\u0026gt;  \u0026lt;!--java 发送http请求--\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;httpcore\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${httpcore.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;commons-io\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${commons.io.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;shiro-core\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${shiro.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;shiro-spring\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${shiro.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;${mysql.connector.version}\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;servlet-api\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt;  \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt;  \u0026lt;!-- tomcat内有Servlet--\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;jakarta.validation\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jakarta.validation-api\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;2.0.2\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  \u0026lt;/dependencies\u0026gt;   product的UndoLogEntity的rollbackInfo属性，数据库中使用的是Longblob，实体类中使用byte[]。\n  配置\u0026amp;测试服务的crud功能 视频====》谷粒商城——p18\n  每个项目都需要crud，所以在common中导入mysql驱动\n  配置数据源\nspring:  datasource:  username: root  password: as123  url: jdbc:mysql://localhost:3380/gulimall_pms?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;useSSL=false\u0026amp;serverTimezone=Asia/Shanghai  driver-class-name: com.mysql.cj.jdbc.Driver   配置mybatis-plus\n 使用MapperScan  @MapperScan(\u0026#34;com.atguigu.gulimall.product.dao\u0026#34;)   告诉mybatis-plus，sql映射文件位置\n使用自增主键（以后数据量大了在使用其他主键策略）\nmybatis-plus:  mapper-locations: classpath*:/mapper/**/*.xml  global-config:  db-config:  id-type: auto   crud测试\n@Test  void contextLoads() {  BrandEntity brandEntity = new BrandEntity();  brandEntity.setName(\u0026#34;华为\u0026#34;);   brandService.save(brandEntity);  System.out.println(\u0026#34;保存成功----------\u0026#34;);   brandEntity.setBrandId(1L);  brandEntity.setDescript(\u0026#34;华为手机\u0026#34;);  brandService.updateById(brandEntity);  System.out.println(\u0026#34;更新成功---------\u0026#34;);   List\u0026lt;BrandEntity\u0026gt; list = brandService.list(new LambdaQueryWrapper\u0026lt;BrandEntity\u0026gt;().eq(BrandEntity::getBrandId, \u0026#34;1\u0026#34;));  list.forEach(System.out::println);  System.out.println(\u0026#34;查询成功---------\u0026#34;);  }     逆向工程生成所有代码 视频====》p19\n分","id":14,"section":"posts","summary":"","tags":["谷粒商城"],"title":"谷粒商城步骤笔记","uri":"https://gb.ytte.top/1/01/01/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E6%AD%A5%E9%AA%A4%E7%AC%94%E8%AE%B0/","year":"0001"}],"tags":[{"title":"git","uri":"https://gb.ytte.top/tags/git/"},{"title":"Https","uri":"https://gb.ytte.top/tags/https/"},{"title":"index","uri":"https://gb.ytte.top/tags/index/"},{"title":"JVM","uri":"https://gb.ytte.top/tags/jvm/"},{"title":"MySQL","uri":"https://gb.ytte.top/tags/mysql/"},{"title":"SpringBoot","uri":"https://gb.ytte.top/tags/springboot/"},{"title":"SpringCloud","uri":"https://gb.ytte.top/tags/springcloud/"},{"title":"Thread","uri":"https://gb.ytte.top/tags/thread/"},{"title":"typora","uri":"https://gb.ytte.top/tags/typora/"},{"title":"ZooKeeper","uri":"https://gb.ytte.top/tags/zookeeper/"},{"title":"域名","uri":"https://gb.ytte.top/tags/%E5%9F%9F%E5%90%8D/"},{"title":"基础","uri":"https://gb.ytte.top/tags/%E5%9F%BA%E7%A1%80/"},{"title":"谷粒商城","uri":"https://gb.ytte.top/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"}]}