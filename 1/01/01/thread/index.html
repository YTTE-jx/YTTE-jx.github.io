<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
        Thread - YTTE Site
      </title>
        <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    
    <meta name="theme-color" content="#000000" />
    
    <meta http-equiv="window-target" content="_top" />
    
    
    <meta name="description" content="" />
    <meta name="generator" content="Hugo 0.95.0 with theme pure" />
    <title>Thread - YTTE Site</title>
    
    
    <link rel="stylesheet" href="https://gb.ytte.top/css/style.min.a85959a41e7abcc0db1f81f44bd264649303417f91b536e87dcde644340fea6d.css">
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css" async>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css" async>
    <meta property="og:title" content="Thread" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://gb.ytte.top/1/01/01/thread/" /><meta property="article:section" content="posts" />



<meta itemprop="name" content="Thread">
<meta itemprop="description" content="">

<meta itemprop="wordCount" content="12935">
<meta itemprop="keywords" content="Thread," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Thread"/>
<meta name="twitter:description" content=""/>

    <!--[if lte IE 9]>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
      <![endif]-->

    <!--[if lt IE 9]>
        <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
      <![endif]-->
  </head>

  
  

  <body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="https://github.com/YTTE-jx" target="_blank">
            <img class="img-circle img-rotate" src="https://gb.ytte.top/avatar.png" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">YTTE</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">努力奋斗，不负韶华。</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>Anhui, China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="Type something..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">Home</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/posts/">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">Archives</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/categories/">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">Categories</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/tags/">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">Tags</span>
                </a>
            </li>
            <li class="menu-item menu-item-about">
                <a href="/about/">
                    <i class="icon icon-cup-fill"></i>
                  <span class="menu-title">About</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>

<aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content"><p> 人生无常，大肠包小肠~</p>
            </div>
        </div>
    </div>
</div>

      <div class="widget">
    <h3 class="widget-title"> Tags</h3>
    <div id="tag-cloud-list" class="widget-body">
            
            
            <a href="https://gb.ytte.top/tags/https/" class="tag-list-link" rel="1">https<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/index/" class="tag-list-link" rel="1">index<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/java/" class="tag-list-link" rel="1">java<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/jvm/" class="tag-list-link" rel="1">jvm<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/mysql/" class="tag-list-link" rel="1">mysql<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/springboot/" class="tag-list-link" rel="1">springboot<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/springcloud/" class="tag-list-link" rel="1">springcloud<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/thread/" class="tag-list-link" rel="1">thread<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/typora/" class="tag-list-link" rel="1">typora<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/zookeeper/" class="tag-list-link" rel="1">zookeeper<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://gb.ytte.top/tags/%E5%9F%9F%E5%90%8D/" class="tag-list-link" rel="2">域名<span
               class="tag-list-count">2</span></a>
            
            
            <a href="https://gb.ytte.top/tags/%E5%9F%BA%E7%A1%80/" class="tag-list-link" rel="3">基础<span
               class="tag-list-count">3</span></a>
            
            
            <a href="https://gb.ytte.top/tags/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/" class="tag-list-link" rel="1">谷粒商城<span
               class="tag-list-count">1</span></a>
            
    </div>
<script>
document.onreadystatechange = () => {
  if (document.readyState === 'complete') {
    tagCloud('#tag-cloud-list a',  8 ,  20 );
  }
};

function tagCloud(where, min, max) {
  let iMax = 0;
  let iMin = 0;
  $(where).each(function() {
    let weight = Number($(this).attr("rel"));
    if(iMax < weight) iMax = weight;
    if(iMin > weight || iMin == 0) iMin = weight;
  });
  let step = (max - min)/(iMax - iMin);
  $(where).each(function() {
    let weight = $(this).attr("rel") - iMin;
    $(this).css({"font-size": min + (weight * step) + 'px'});
  });
};
</script>
</div>

      <div class="widget">
    <h3 class="widget-title"> Categories</h3>
    <div class="widget-body">
        <ul class="category-list">
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/java/" class="category-list-link">java</a><span class="category-list-count">7</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/jvm/" class="category-list-link">jvm</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/mysql/" class="category-list-link">mysql</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/zookeeper/" class="category-list-link">zookeeper</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="category-list-link">服务器</a><span class="category-list-count">3</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/%E6%9D%82%E9%A1%B9/" class="category-list-link">杂项</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://gb.ytte.top/categories/%E9%A1%B9%E7%9B%AE/" class="category-list-link">项目</a><span class="category-list-count">1</span></li>
        </ul>
    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gb.ytte.top/2022/03/19/456th/" class="title">456th</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-19 20:55:16 &#43;0800 CST" itemprop="datePublished">2022-03-19</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gb.ytte.top/2022/03/19/https/" class="title">Https</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-19 20:18:16 &#43;0800 CST" itemprop="datePublished">2022-03-19</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gb.ytte.top/2022/03/16/%E4%B8%80%E7%BA%A7%E5%9F%9F%E5%90%8D/" class="title">一级域名</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-16 20:18:16 &#43;0800 CST" itemprop="datePublished">2022-03-16</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gb.ytte.top/2022/03/16/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/" class="title">二级域名</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-16 20:18:16 &#43;0800 CST" itemprop="datePublished">2022-03-16</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://gb.ytte.top/2022/03/14/consumersupplierpredicate%E5%92%8Cfunction/" class="title">Consumer、Supplier、Predicate和Function</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-14 09:35:19 &#43;0000 UTC" itemprop="datePublished">2022-03-14</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <h4 class="toc-title">Catalogue</h4>
    <nav id="toc" class="js-toc toc">

    </nav>
  </div>
</aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/1/01/01/thread/"
    >Thread</a
  >
</h1>

      <div class="article-meta">
        <span class="article-category">
  <i class="icon icon-folder"></i>&nbsp;
  <a class="article-category-link" href="/categories/java/"> java </a>
</span>  
  <span class="article-tag">
    <i class="icon icon-tags"></i>&nbsp;
    <a class="article-tag-link" href="/tags/thread/"> Thread </a>
  </span>

		<span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 12935 words</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">Read Time: 26 minutes </span>
      </div>
    </div>
    <div class="article-entry marked-body js-toc-content" itemprop="articleBody">
      <h1 id="线程的实现方式及其优缺点">线程的实现方式及其优缺点</h1>
<h2 id="继承thread类">继承Thread类</h2>
<pre><code class="language-java">public class TestCode1 extends Thread
{
	private int i;
	public void run()
	{
		for(;i&lt;100;i++)
		{
			System.out.println(getName()+&quot; &quot;+i);
		}
	}
	public static void main(String[] args) 
	{
		for(int i=0;i&lt;100;i++)
		{
			System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);
			if(i==20){
				new TestCode1().start();
				new TestCode1().start();
			}
		}
	}
}
</code></pre>
<h2 id="实现runnable接口">实现Runnable接口</h2>
<ul>
<li>实现Runnable接口，重写run方法，实例要作为Thread的target来创建对象，thread.start()（推荐这种，清洗可见）</li>
</ul>
<pre><code class="language-java">class MyRunnable implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);
        }
    }
}
public class MyThread {
    public static void main(String[] args) {
        //创建自定义类对象 线程任务对象
        MyRunnable mr = new MyRunnable();
        //创建线程对象
        Thread t = new Thread(mr, &quot;小强&quot;);
        t.start();
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;旺财 &quot; + i);
        }
    }
} 
</code></pre>
<ul>
<li>或者在方法内直接重写</li>
</ul>
<pre><code class="language-java">public class MyThread {
    public static void main(String[] args) { 
        
        Runnable r = new Runnable(){
            public void run(){
                for (int i = 0; i &lt; 20; i++) {
                System.out.println(&quot;张宇:&quot;+i);
                }
            }
        };
        new Thread(r).start(); 
     }
}
</code></pre>
<ul>
<li>直接lambda创建<strong>Runnable</strong>实现类</li>
</ul>
<pre><code class="language-java">public class MyThread {
    public static void main(String[] args) {
        Runnable r = () -&gt; {
            for (int i = 0; i &lt; 20; i++) {
                System.out.println(&quot;张宇:&quot;+i);
            }
        };
        new Thread(r).start();
    }
}
</code></pre>
<h2 id="实现callable接口">实现Callable接口</h2>
<ol>
<li>
<p>创建Callable接口的实现类，并实现Call（）方法，该方法将作为线程执行体，且该方法有返回值，再创建Callable实现类的实例。从Java8开始，可以直接使用Lambda表达式创建Callable对象。</p>
</li>
<li>
<p>使用FutureTask来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。</p>
</li>
<li>
<p>使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
</li>
<li>
<p>调用FutureTask对象的get（）方法来获取子线程执行结束后的返回值。</p>
</li>
</ol>
<pre><code class="language-java">class MyCallable implements Callable {
    @Override
    public Object call() throws Exception {
        int i = 0;
        for (; i &lt; 100; i++) {
            Thread.sleep(100);
            System.out.println(Thread.currentThread().getName() + &quot;循环遍历i的值&quot; + i);
        }
        return null;
    }
}
public class ThreadTest {
    public static void main(String[] args) {
        Callable myCallable = new MyCallable();
        FutureTask task = new FutureTask(myCallable);
        new Thread(task).start();
        for (int i = 0; i &lt; 100; i++) {
            try {
                Thread.sleep(100);
                System.out.println(Thread.currentThread().getName()+&quot;循环遍历i的值&quot; + i);
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

//lambda方式
public class ThreadTest {
    public static void main(String[] args) {
        FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(()-&gt;{
            int i=0;
            for(;i&lt;100;i++){
                System.out.println(Thread.currentThread().getName()+&quot;循环变量i的值：&quot;+i);
            }
            return i;
        });
        for(int i=0;i&lt;100;i++){
            System.out.println(Thread.currentThread().getName()+&quot;循环变量i的值：&quot;+i);
            if(i==20){
                new Thread(task,&quot;有返回值的线程&quot;).start();
            }
            try{
                System.out.println(&quot;子线程的返回值：&quot;+task.get());
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<h2 id="异同点和优缺点">异同点和优缺点</h2>
<h3 id="异同点">异同点</h3>
<ul>
<li>
<p>相同点</p>
<ul>
<li>都可以实现多线程</li>
<li>Runnable与Callable实现方式类似</li>
</ul>
</li>
<li>
<p>不同点</p>
<ul>
<li>Thread方式是通过继承来实现。</li>
<li>Runnable与Callable是通过实现接口方式创建线程。</li>
<li>Runnable与Callable
<ul>
<li>因为通过FutureTask包装Callable接口，FutureTask有get方法可以获取返回值，所以只有这种方式创建的子线程有返回值。</li>
<li>run方法无法抛出异常，call方法可以抛出checked exception。</li>
<li>Callable和Runnable都可以应用于executors。而Thread类只支持Runnable.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="优缺点">优缺点</h3>
<ul>
<li>
<p>优点</p>
<ul>
<li>
<p>Thread</p>
<ul>
<li>编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this即可获得当前线程。</li>
</ul>
</li>
<li>
<p>Runnable与Callable</p>
<ul>
<li>可以继承其他类</li>
<li>多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>Thread
<ul>
<li>继承的局限性，不能继承其他类</li>
</ul>
</li>
<li>Runnable与Callable
<ul>
<li>编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread（）方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="补充">补充</h2>
<p>扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。</p>
<h1 id="子线程执行完主线程执行">子线程执行完，主线程执行</h1>
<p>正常如1中的各种实现方式 <a href="##%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F">Local跳转方式</a>，<a href="">Shimo跳转方式</a>，主线程与子线程是争夺线程资源的，所以一般情况是会出现类似交替执行的状况。</p>
<h2 id="futuretask来包装callable对象">FutureTask来包装Callable对象</h2>
<p>上方（ <a href="##%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3">Local跳转方式</a>，<a href="">Shimo跳转方式</a>）的这种是子线程无返回值的情况，这种情况下，子线程与多线程可以争夺线程资源，</p>
<p>如果为子线程添加返回值，使用 FutureTask来包装Callable对象，通过task.get()来获取返回值，主线程进行到task.get()时，如果子线程还在执行，没有返回，主线程就会子线程返回之前等待挂起。从而达到要求。</p>
<pre><code class="language-java">public class TestCode3 {
	public static void main(String[] args) {
		FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)()-&gt;{
			int i=0;
			for(;i&lt;100;i++){
				System.out.println(Thread.currentThread().getName()+&quot;循环变量i的值：&quot;+i);
			}
			return i;
		});
		for(int i=0;i&lt;100;i++){
			System.out.println(Thread.currentThread().getName()+&quot;循环变量i的值：&quot;+i);
			if(i==20){
				new Thread(task,&quot;有返回值的线程&quot;).start();
			}
			try{
				System.out.println(&quot;子线程的返回值：&quot;+task.get());
			}
			catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
}
</code></pre>
<h2 id="join方法">join方法</h2>
<p><a href="https://blog.csdn.net/u013425438/article/details/80205693?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3.pc_relevant_default&amp;utm_relevant_index=6">参考资料链接</a></p>
<p>结论：t.join()方法只会使主线程(或者说调用t.join()的线程)进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。</p>
<p>t.join方法底层中使用wait(0)方法，即使用了该方法的线程会进入无限等待中，直到 t 执行完成才返回。进入等待的只是调用了join方法的线程，其他线程没开启的不会开启，开启了的不会等待继续执行。</p>
<pre><code class="language-java">public class TestJoin {
	public static void main(String[] args) throws InterruptedException {
		// TODO Auto-generated method stub
		System.out.println(Thread.currentThread().getName()+&quot; start&quot;);
		ThreadTest t1=new ThreadTest(&quot;A&quot;);
		ThreadTest t2=new ThreadTest(&quot;B&quot;);
		ThreadTest t3=new ThreadTest(&quot;C&quot;);
		System.out.println(&quot;t1start&quot;);
		t1.start();
		System.out.println(&quot;t1end&quot;);
		System.out.println(&quot;t2start&quot;);
		t2.start();
		System.out.println(&quot;t2end&quot;);
		t1.join();
		System.out.println(&quot;t3start&quot;);
		t3.start();
		System.out.println(&quot;t3end&quot;);
		System.out.println(Thread.currentThread().getName()+&quot; end&quot;);
	}
}
</code></pre>
<p>结果：</p>
<pre><code class="language-java">main start
t1start
t1end
t2start
t2end
A-1
B-1
A-2
A-3
A-4
A-5
B-2
t3start
t3end
B-3
main end
B-4
B-5
C-1
C-2
C-3
C-4
C-5
</code></pre>
<p>主线程在t1.join()方法处停止，并需要等待A线程执行完毕后才会执行t3.start()，然而，并不影响B线程的执行。因此，可以得出结论，t.join()方法只会使主线程进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。</p>
<blockquote>
<p>join源码中，只会调用wait方法，并没有在结束时调用notify，这是因为==线程在die的时候会自动调用自身的notifyAll方法，来释放所有的资源和锁。==</p>
</blockquote>
<h1 id="线程与线程池的状态">线程与线程池的状态</h1>
<h2 id="线程的状态nrbwtt牛肉包我舔舔">线程的状态（NRBWTT）（牛肉包我舔舔）</h2>
<ul>
<li>NEW																 尚未启动</li>
<li>RUNNABLE                                         正在执⾏中</li>
<li>BLOCKED                                            阻塞的（被同步锁或者IO锁阻塞）</li>
<li>WAITING                                             永久等待状态</li>
<li>TIMED_WAITING                                 等待指定的时间重新被唤醒的状态</li>
<li>TERMINATED                                      执⾏完成</li>
</ul>
<p><img src="https://blogimg.ytte.top//img-jixiang//20220310230947.png" alt=""></p>
<h2 id="线程池的状态rsstt人事是傻甜甜">线程池的状态（RSSTT）（人事是傻甜甜）</h2>
<ol>
<li>
<p><em><strong>RUNNING： 这是最正常的状态</strong></em> ，接受新的任务，处理等待队列中的任务 。</p>
</li>
<li>
<p><em><strong>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务</strong></em>。</p>
</li>
<li>
<p><em><strong>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执⾏任务的线程。</strong></em></p>
</li>
<li>
<p><em><strong>TIDYING：所有的任务都销毁了</strong></em>，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执⾏钩⼦⽅法 terminated()。</p>
</li>
<li>
<p><strong>TERMINATED：terminated()⽅法结束后，线程池的状态就会变成这个。</strong></p>
</li>
</ol>
<h1 id="线程池">线程池</h1>
<p>大佬链接====》<a href="https://blog.csdn.net/u013541140/article/details/95225769?ops_request_misc=%7B%22request%5Fid%22%3A%22164683408616781685325229%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=164683408616781685325229&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-95225769.pc_search_result_cache&amp;utm_term=%E7%BA%BF%E7%A8%8B%E6%B1%A0&amp;spm=1018.2226.3001.4187">线程池1_CSDN博客</a></p>
<p>大佬链接====》<a href="https://blog.csdn.net/qq_34115899/article/details/114531116?ops_request_misc=%7B%22request%5Fid%22%3A%22164691607116780255229360%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=164691607116780255229360&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-114531116.pc_search_result_cache&amp;utm_term=%E7%BA%BF%E7%A8%8B%E6%B1%A0&amp;spm=1018.2226.3001.4187">线程池2-CSDN博客</a></p>
<h2 id="线程池的优点">线程池的优点</h2>
<ul>
<li>
<p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
</li>
<li>
<p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
</li>
<li>
<p>**提高线程的可管理性。**线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</li>
</ul>
<h2 id="线程池的继承树">线程池的继承树</h2>
<p><img src="https://blogimg.ytte.top//img-jixiang/20220310114635.png" alt=""></p>
<h2 id="线程池地使用">线程池地使用</h2>
<p>线程池的真正实现类是ThreadPoolExecutor ，其构造器方法有以下4种：</p>
<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
 
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         threadFactory, defaultHandler);
}
 
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          RejectedExecutionHandler handler) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), handler);
}
 
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
</code></pre>
<p>参数说明：<!-- raw HTML omitted --> IPHP <!-- raw HTML omitted --></p>
<ul>
<li><code>corePoolSize</code>（必需）：核心线程数。默认情况下，核心线程会一直存活，但是当将 <strong>allowCoreThreadTimeout</strong> 设置为 true 时，核心线程也会超时回收。</li>
<li><code>maximumPoolSize</code>（必需）：线程池所能容纳的最大线程数。当活跃线程数达到该数值后，后续的新任务将会阻塞。</li>
<li><code>keepAliveTime</code>（必需）：线程闲置超时时长。如果超过该时长，非核心线程就会被回收。如果将 <strong>allowCoreThreadTimeout</strong> 设置为 true 时，核心线程也会超时回收。</li>
<li><code>unit</code>（必需）：指定 keepAliveTime 参数的时间单位。常用的有：TimeUnit.MILLISECONDS（毫秒）、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES（分）。</li>
<li><code>workQueue</code>（必需）：任务队列。通过线程池的 <strong>execute()</strong> 方法提交的 Runnable 对象将存储在该参数中。其采用阻塞队列实现。</li>
<li><code>threadFactory</code>（可选）：线程工厂。用于指定为线程池创建新线程的方式。</li>
<li><code>handler</code>（可选）：拒绝策略。当达到最大线程数时需要执行的饱和策略。</li>
</ul>
<p>线程池的使用流程：</p>
<pre><code class="language-java">// 创建线程池
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(CORE_POOL_SIZE,
                                             MAXIMUM_POOL_SIZE,
                                             KEEP_ALIVE,
                                             TimeUnit.SECONDS,
                                             sPoolWorkQueue,
                                             sThreadFactory);
// 向线程池提交任务
threadPool.execute(new Runnable() {
    @Override
    public void run() {
        ... // 线程执行的任务
    }
});
// 关闭线程池
threadPool.shutdown(); // 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程
threadPool.shutdownNow(); // 设置线程池的状态为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表
</code></pre>
<h2 id="线程池的工作原理">线程池的工作原理</h2>
<p><img src="https://blogimg.ytte.top//img-jixiang//20220310160511.png" alt=""></p>
<p>简概：<!-- raw HTML omitted --> IPHP <!-- raw HTML omitted --></p>
<ul>
<li>1.如果线程数小于<code>corePoolSize</code>，创建一个新<strong>核心线程</strong>来运行新任务。</li>
<li>2.如果线程数大于等于<code>corePoolSize</code>但小于<code>maximumPoolSize</code>，则将任务放入队列。</li>
<li>3.如果队列已满，并且线程数小于<code>maxPoolSize</code>，则创建一个新<strong>非核心线程</strong>来运行任务。</li>
<li>4.如果队列已满，并且线程数大于或等于<code>maxPoolSize</code>，则拒绝该任务。</li>
</ul>
<p>是否需要增加线程的判断顺序是：1、<code>corePoolSize</code> 2、<code>workQueue</code> 3、<code>maxPoolSize</code></p>
<p><strong>举个例子：</strong></p>
<p>线程池的核心线程数<code>corePoolSize</code>大小为5，最大池<code>maxPoolSize</code>大小为10，队列<code>workQueue</code>为100。</p>
<p>因为线程中的请求最多会创建5个，然后任务将被添加到队列中，直到达到100。当队列已满时，将创建新的线程，最多到10个线程，如果再来任务，就拒绝。</p>
<p><strong>特点：</strong></p>
<ul>
<li>通过设置<code>corePoolSize</code>和<code>maximumPoolSize</code> 相同，就可以创建固定大小的线程池。</li>
<li>我们使用线程池一般希望保持较少的线程数，并且只有在负载变得很大时才增加它。</li>
<li>通过设置<code>maximumPoolSize</code>为很高的值，例如 <code>Integer.MAX_VALUE</code>，可以允许线程池容纳任意数量的并发任务。</li>
<li>只有在队列填满时才创建多于<code>corePoolSize</code>的非核心线程，如果使用的是无界队列（例如<code>LinkedBlockingQueue</code>），那么线程数就不会超过<code>corePoolSize</code>。</li>
</ul>
<h2 id="线程参数解析">线程参数解析</h2>
<h3 id="任务队列workqueue">任务队列workQueue</h3>
<p>任务队列是基于阻塞队列实现的，即采用生产者消费者模式，在 Java 中需要实现 BlockingQueue 接口。但 Java 已经为我们提供了 7 种阻塞队列的实现：</p>
<ul>
<li>
<p><code>ArrayBlockingQueue</code>：一个由数组结构组成的有界阻塞队列（数组结构可配合指针实现一个环形队列）。</p>
</li>
<li>
<p><code>LinkedBlockingQueue</code>： 一个由链表结构组成的有界阻塞队列，在未指明容量时，容量默认为Integer.MAX_VALUE。</p>
<blockquote>
<p>这种队列容量无限大，可以防止流量突增。设置<code>maximumPoolSize</code>也用不到，因为队列装不满，永远不需要创建新的非核心线程。但是也有风险，处理任务的速度跟不上提交的速度，可能造成内存浪费或者<code>OOM</code>。</p>
</blockquote>
</li>
<li>
<p><code>PriorityBlockingQueue</code>： 一个支持优先级排序的无界阻塞队列，对元素没有要求，可以实现 Comparable 接口也可以提供 Comparator 来对队列中的元素进行比较。跟时间没有任何关系，仅仅是按照优先级取任务。</p>
</li>
<li>
<p><code>DelayQueue</code>：类似于PriorityBlockingQueue，是二叉堆实现的无界优先级阻塞队列。要求元素都实现 Delayed 接口，通过执行时延从队列中提取任务，时间没到任务取不出来。</p>
</li>
<li>
<p><code>SynchronousQueue</code>： 一个不存储元素的阻塞队列，消费者线程调用 take() 方法的时候就会发生阻塞，直到有一个生产者线程生产了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用 put() 方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。</p>
<blockquote>
<p>工作任务不多的情况下，只是将任务中转，就可以用<code>SynchronousQueue</code>，这个队列本身内部没有容量，使用这种队列，<code>maximumPoolSize</code>就可能需要设置的大一些。因为没有队列容量作为缓冲了，很容易创建新线程。</p>
</blockquote>
</li>
<li>
<p><code>LinkedBlockingDeque</code>： 使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样 FIFO（先进先出），也可以像栈一样 FILO（先进后出）。</p>
</li>
<li>
<p><code>LinkedTransferQueue</code>： 它是ConcurrentLinkedQueue、LinkedBlockingQueue 和 SynchronousQueue 的结合体，但是把它用在 ThreadPoolExecutor 中，和 LinkedBlockingQueue 行为一致，但是是无界的阻塞队列。</p>
</li>
</ul>
<p>注意有界队列和无界队列的区别：如果使用有界队列，当队列饱和时并超过最大线程数时就会执行拒绝策略；而如果使用无界队列，因为任务队列永远都可以添加任务，所以设置 maximumPoolSize 没有任何意义。</p>
<h3 id="线程工厂threadfactory">线程工厂（threadFactory）</h3>
<p>线程工厂指定创建线程的方式，需要实现 <strong>ThreadFactory</strong> 接口，并实现 <strong>newThread(Runnable r)</strong> 方法。</p>
<ol>
<li>新的线程是由<code>ThreadFactory</code>创建的，默认使用<code>Executors.defaultThreadFactory()</code></li>
<li>创建出来的线程都在同一个线程组，拥有同样的<code>NORM_PRIORITY</code>优先级并且都不是守护线程。</li>
<li>如果自己指定<code>ThreadFactory</code>，那么就可以改变线程名、线程组、优先级、是否是守护线程等。</li>
<li>通常使用默认的<code>ThreadFactory</code>就可以了</li>
</ol>
<pre><code class="language-java">// 验证第一点，新的线程是由ThreadFactory创建的，默认使用Executors.defaultThreadFactory()
public static ThreadFactory defaultThreadFactory() {
    return new DefaultThreadFactory();
}

......

static class DefaultThreadFactory implements ThreadFactory {
        private static final AtomicInteger poolNumber = new AtomicInteger(1);
        private final ThreadGroup group;
        private final AtomicInteger threadNumber = new AtomicInteger(1);
        private final String namePrefix;

        DefaultThreadFactory() {
            SecurityManager s = System.getSecurityManager();
            group = (s != null) ? s.getThreadGroup() :
                                  Thread.currentThread().getThreadGroup();
            namePrefix = &quot;pool-&quot; +
                          poolNumber.getAndIncrement() +
                         &quot;-thread-&quot;;
        }

        public Thread newThread(Runnable r) {
        // 验证第二点，创建出来的线程都在同一个线程组，拥有同样的NORM_PRIORITY优先级并且都不是守护线程。
            Thread t = new Thread(group, r,
                                  namePrefix + threadNumber.getAndIncrement(),
                                  0);
            if (t.isDaemon())
                t.setDaemon(false);
            if (t.getPriority() != Thread.NORM_PRIORITY)
                t.setPriority(Thread.NORM_PRIORITY);
            return t;
        }
    }
</code></pre>
<h3 id="拒绝策略handler">拒绝策略（handler）</h3>
<p>当线程池的线程数达到最大线程数时，需要执行拒绝策略。拒绝策略需要实现 RejectedExecutionHandler 接口，并实现 rejectedExecution(Runnable r, ThreadPoolExecutor executor) 方法。不过 Executors 框架已经为我们实现了 4 种拒绝策略：</p>
<ul>
<li><strong>AbortPolicy（默认）</strong>：丢弃任务并抛出 RejectedExecutionException 异常。</li>
<li><strong>CallerRunsPolicy</strong>：由调用线程处理该任务。</li>
<li><strong>DiscardPolicy</strong>：丢弃任务，但是不抛出异常。可以配合这种模式进行自定义的处理方式。</li>
<li><strong>DiscardOldestPolicy</strong>：丢弃队列最早的未处理任务，然后重新尝试执行任务。</li>
</ul>
<h2 id="功能线程池">功能线程池</h2>
<p>嫌上面使用线程池的方法太麻烦？其实Executors已经为我们封装好了 4 种常见的功能线程池，如下：</p>
<ul>
<li>定长线程池（FixedThreadPool）</li>
<li>定时线程池（ScheduledThreadPool ）</li>
<li>可缓存线程池（CachedThreadPool）</li>
<li>单线程化线程池（SingleThreadExecutor）</li>
</ul>
<h3 id="定长线程池fixedthreadpool">定长线程池（FixedThreadPool）</h3>
<pre><code class="language-java">public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;(),
                                  threadFactory);
}
</code></pre>
<ul>
<li><strong>特点</strong>：只有核心线程，<strong>线程数量固定</strong>，执行完立即回收，任务队列为链表结构的有界队列。</li>
<li><strong>应用场景</strong>：控制线程最大并发数。</li>
</ul>
<p>使用：</p>
<pre><code class="language-java">// 1. 创建定长线程池对象 &amp; 设置线程池线程数量固定为3
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
// 2. 创建好Runnable类线程对象 &amp; 需执行的任务
Runnable task =new Runnable(){
  public void run() {
     System.out.println(&quot;执行任务啦&quot;);
  }
};
// 3. 向线程池提交任务
fixedThreadPool.execute(task);
</code></pre>
<h3 id="定时线程池scheduledthreadpool-">定时线程池（ScheduledThreadPool ）</h3>
<pre><code class="language-java">
private static final long DEFAULT_KEEPALIVE_MILLIS = 10L;
 
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE,
          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,
          new DelayedWorkQueue());
}
 
public static ScheduledExecutorService newScheduledThreadPool(
        int corePoolSize, ThreadFactory threadFactory) {
    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
}
public ScheduledThreadPoolExecutor(int corePoolSize,
                                   ThreadFactory threadFactory) {
    super(corePoolSize, Integer.MAX_VALUE,
          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,
          new DelayedWorkQueue(), threadFactory);
}
</code></pre>
<ul>
<li><strong>特点</strong>：核心线程数量固定，非核心线程数量无限，执行完闲置 10ms 后回收，任务队列为延时阻塞队列。</li>
<li><strong>应用场景</strong>：执行定时或周期性的任务。</li>
</ul>
<pre><code class="language-java">// 1. 创建 定时线程池对象 &amp; 设置线程池线程数量固定为5
ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
// 2. 创建好Runnable类线程对象 &amp; 需执行的任务
Runnable task =new Runnable(){
  public void run() {
     System.out.println(&quot;执行任务啦&quot;);
  }
};
// 3. 向线程池提交任务
scheduledThreadPool.schedule(task, 1, TimeUnit.SECONDS); // 延迟1s后执行任务
scheduledThreadPool.scheduleAtFixedRate(task,10,1000,TimeUnit.MILLISECONDS);// 延迟10ms后、每隔1000ms执行任务
</code></pre>
<h3 id="可缓存线程池cachedthreadpool">可缓存线程池（CachedThreadPool）</h3>
<pre><code class="language-java">
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;(),
                                  threadFactory);
}
</code></pre>
<ul>
<li><strong>特点</strong>：无核心线程，非核心线程数量无限，执行完闲置 60s 后回收，任务队列为不存储元素的阻塞队列。</li>
<li><strong>应用场景</strong>：执行大量、耗时少的任务。</li>
</ul>
<pre><code class="language-java">// 1. 创建可缓存线程池对象
ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
// 2. 创建好Runnable类线程对象 &amp; 需执行的任务
Runnable task =new Runnable(){
  public void run() {
     System.out.println(&quot;执行任务啦&quot;);
  }
};
// 3. 向线程池提交任务
cachedThreadPool.execute(task)
</code></pre>
<h3 id="单线程化线程池singlethreadexecutor">单线程化线程池（SingleThreadExecutor）</h3>
<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;(),
                                threadFactory));
}
</code></pre>
<ul>
<li><strong>特点</strong>：只有 1 个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。</li>
<li><strong>应用场景</strong>：不适合并发但可能引起 IO 阻塞性及影响 UI 线程响应的操作，如数据库操作、文件操作等。</li>
</ul>
<pre><code class="language-java">// 1. 创建单线程化线程池
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
// 2. 创建好Runnable类线程对象 &amp; 需执行的任务
Runnable task =new Runnable(){
  public void run() {
     System.out.println(&quot;执行任务啦&quot;);
  }
};
// 3. 向线程池提交任务
singleThreadExecutor.execute(task);
</code></pre>
<h3 id="对比">对比</h3>
<p><img src="https://blogimg.ytte.top//img-jixiang//20220310203126.png" alt=""></p>
<h1 id="线程池模板">线程池模板</h1>
<p>大佬链接====》<a href="https://www.cnblogs.com/keeya/archive/2018/11/27/10025260.html">Spring线程池配置模板- 博客园 </a></p>
<pre><code class="language-java">@EnableAsync
@Configuration
public class LogThreadPoolConfig {

  @Bean(name = &quot;logThreadPool&quot;)
  public ThreadPoolTaskExecutor LogThreadPoolTask() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    LogThreadPoolProperties properties = this.logThreadPoolProperties();

    executor.setCorePoolSize(properties.getCorePoolSize());
    executor.setMaxPoolSize(properties.getMaxPoolSize());
    executor.setQueueCapacity(properties.getQueueCapacity());
    executor.setKeepAliveSeconds(properties.getKeepAliveSeconds());
    executor.setThreadNamePrefix(properties.getThreadName());
    switch (properties.getRejectedExecutionHandler()) {
      case &quot;abortPolicy&quot;:
        executor.setRejectedExecutionHandler(new AbortPolicy());
        break;
      case &quot;callerRunsPolicy&quot;:
        executor.setRejectedExecutionHandler(new CallerRunsPolicy());
        break;
      case &quot;discardOldestPolicy&quot;:
        executor.setRejectedExecutionHandler(new DiscardOldestPolicy());
        break;
      case &quot;discardPolicy&quot;:
        executor.setRejectedExecutionHandler(new DiscardOldestPolicy());
        break;
      default:
        executor.setRejectedExecutionHandler(new CallerRunsPolicy());
        break;
    }
    executor.initialize();
    return executor;
  }


  @Bean
  @ConfigurationProperties(prefix = &quot;threadpool.log&quot;)
  public LogThreadPoolProperties logThreadPoolProperties() {
    return new LogThreadPoolProperties();
  }


  //@Getter lombok提供的getset方法生成注解
  //@Setter
  @Configuration
  public static class LogThreadPoolProperties {

    /**
     * 线程前缀名
     */
    private String threadName;
    /**
     * 核心线程池大小
     */
    private int corePoolSize;
    /**
     * 最大线程数
     */
    private int maxPoolSize;
    /**
     * 队列大小
     */
    private int queueCapacity;
    /**
     * 线程池维护空闲线程存在时间
     */
    private int keepAliveSeconds;
    /**
     * 拒绝策略
     */
    private String rejectedExecutionHandler;

  }
}
</code></pre>
<p>这样就可以在yml文件中配置参数了：</p>
<pre><code class="language-yaml">threadpool:
  log:
    threadName: ThreadPool-log- # 线程池前缀名
    corePoolSize: 8             # 核心线程池数：IO型推荐设置为cpu核心数*2；cpu型推荐设置为cpu数+1
    maxPoolSize: 16             # 最大线程池数
    queueCapacity: 1000         # 线程池阻塞队列容量
    keepAliveSeconds: 60        # 允许线程空闲时间
    # 拒绝策略 abortPolicy callerRunsPolicy discardOldestPolicy discardPolicy
    rejectedExecutionHandler: callerRunsPolicy
</code></pre>
<p>使用：</p>
<p>Spring提供了注解方式来方便我们使用线程池，只需要在要异步处理的方法上加 @Async(&ldquo;你配置的线程池名字&rdquo;)就可以了,注意这个类需要被spring扫描并纳入管理，所以要加@Service、@Component等注解。</p>
<pre><code class="language-java">@Service
public class ServiceImpl implements Service {

  @Override
  @Async(&quot;logThreadPool&quot;)
  public void addOperationLog(BaseLog baseLog) {
    //你要异步执行的逻辑
  }
}
</code></pre>
<h1 id="小总结">小总结</h1>
<ol>
<li>==Executors 的 4 个功能线程池虽然方便，但现在已经不建议使用了，而是建议直接通过使用 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。==</li>
</ol>
<p>其实 Executors 的 4 个功能线程有如下弊端：</p>
<ul>
<li><strong>FixedThreadPool</strong> 和 <strong>SingleThreadExecutor</strong>：主要问题是堆积的请求处理队列均采用 <strong>LinkedBlockingQueue</strong>，可能会耗费非常大的内存，甚至 OOM。</li>
<li><strong>CachedThreadPool</strong> 和 <strong>ScheduledThreadPool</strong>：主要问题是线程数最大数是 <strong>Integer.MAX_VALUE</strong>，可能会创建数量非常多的线程，甚至 OOM。</li>
</ul>
<ol start="2">
<li>线程池里的线程数量设定为多少比较合适？</li>
</ol>
<p>这个得看任务类型</p>
<ul>
<li><code>CPU</code>密集型（加密、计算<code>hash</code>等）：最佳线程数为<code>CPU</code>核心数的1-2倍左右。</li>
<li>耗时<code>IO</code>型（读写数据库、文件、网络读写等）：最佳线程数一般会大于<code>CPU</code>核心数很多倍 ，参考<code>Brain Goetz</code>专家推荐的计算方法：线程数=<code>CPU</code>核心数*（1+平均等待时间/平均工作时间）</li>
</ul>
<p>如果需要更精确的线程数量，那就需要根据不同的程序去做压测，这样就能得到比较合适的线程数量。</p>
<h1 id="threadlocal">ThreadLocal</h1>
<h2 id="概念">概念</h2>
<p>ThreadLocal叫做<em><strong>线程变量</strong></em>，ThreadLocal中<em><strong>填充的变量</strong></em> 属于<em><strong>当前线程</strong></em>，该变量对其他线程而言是隔离的。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<p>ThreadLocal 适用于每个线程变量在线程间隔离而在方法或类间共享的场景。</p>
<p><img src="https://blogimg.ytte.top//img-jixiang//20220311113857.png" alt=""></p>
<h2 id="threadlocal与synchronized的区别">ThreadLocal与Synchronized的区别</h2>
<ul>
<li>
<p>ThreadLocal</p>
<p>ThreadLocal则用于线程间的数据隔离。ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象</p>
</li>
<li>
<p>Synchronized</p>
<p>Synchronized用于线程间的数据共享。利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。</p>
</li>
</ul>
<h2 id="使用">使用</h2>
<pre><code class="language-java">public class ThreadLocaDemo {
    
    private static ThreadLocal&lt;String&gt; localVar = new ThreadLocal&lt;String&gt;();
    
    static void print(String str) {
        //打印当前线程中本地内存中本地变量的值
        System.out.println(str + &quot; :&quot; + localVar.get());
        //清除本地内存中的本地变量
        localVar.remove();
    }
    public static void main(String[] args) throws InterruptedException {
 
        new Thread(new Runnable() {
            public void run() {
                ThreadLocaDemo.localVar.set(&quot;local_A&quot;);
                print(&quot;A&quot;);
                //打印本地变量
                System.out.println(&quot;after remove : &quot; + localVar.get());
               
            }
        },&quot;A&quot;).start();
 
        Thread.sleep(1000);
 
        new Thread(new Runnable() {
            public void run() {
                ThreadLocaDemo.localVar.set(&quot;local_B&quot;);
                print(&quot;B&quot;);
                System.out.println(&quot;after remove : &quot; + localVar.get());
              
            }
        },&quot;B&quot;).start();
    }
}
A :local_A
after remove : null
B :local_B
after remove : null
</code></pre>
<h3 id="set">set()</h3>
<p>==向ThreadLocal里面存东西就是向它里面的Map存东西的，然后ThreadLocal把这个Map挂到当前的线程底下==</p>
<pre><code class="language-java"> public void set(T value) {
        //1、获取当前线程
        Thread t = Thread.currentThread();
        //2、获取线程中的属性 threadLocalMap ,如果threadLocalMap 不为空，
        //则直接更新要保存的变量值，否则创建threadLocalMap，并赋值
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            // 初始化thradLocalMap 并赋值
            createMap(t, value);
    }
</code></pre>
<p>从上面的代码可以看出，ThreadLocal  set赋值的时候首先会获取当前线程thread,并获取thread线程中的ThreadLocalMap属性。如果map属性不为空，则直接更新value值，如果map为空，则实例化threadLocalMap,并将value值初始化。</p>
<p>==ThreadLocalMap呢是当前线程Thread一个叫threadLocals的变量中获取的。每个线程Thread都维护了自己的threadLocals变量，所以在每个线程创建ThreadLocal的时候，实际上数据是存在自己线程Thread的threadLocals变量里面的，别人没办法拿到，从而实现了隔离。==</p>
<pre><code class="language-java">ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
</code></pre>
<pre><code class="language-java">  static class ThreadLocalMap {
        /**
         * The entries in this hash map extend WeakReference, using
         * its main ref field as the key (which is always a
         * ThreadLocal object).  Note that null keys (i.e. entry.get()
         * == null) mean that the key is no longer referenced, so the
         * entry can be expunged from table.  Such entries are referred to
         * as &quot;stale entries&quot; in the code that follows.
         */
        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
            /** The value associated with this ThreadLocal. */
            Object value;
 
            Entry(ThreadLocal&lt;?&gt; k, Object v) {
                super(k);
                value = v;
            }
        }
    }
</code></pre>
<p>可看出ThreadLocalMap是ThreadLocal的内部静态类，而它的构成主要是用Entry来保存数据 ，而且还是继承的弱引用。在Entry内部使用ThreadLocal作为key，使用我们设置的value作为value。<!-- raw HTML omitted -->IPHP<!-- raw HTML omitted --></p>
<p>姬祥todo createMap</p>
<h3 id="get">get()</h3>
<pre><code class="language-java">    public T get() {
        //1、获取当前线程
        Thread t = Thread.currentThread();
        //2、获取当前线程的ThreadLocalMap
        ThreadLocalMap map = getMap(t);
        //3、如果map数据为空，
        if (map != null) {
            //3.1、获取threalLocalMap中存储的值
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings(&quot;unchecked&quot;)
                T result = (T)e.value;
                return result;
            }
        }
        //如果是数据为null，则初始化，初始化的结果，TheralLocalMap中存放key值为threadLocal，值为null
        return setInitialValue();
    }
 
private T setInitialValue() {
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
        return value;
    }
</code></pre>
<h3 id="remove">remove()</h3>
<pre><code class="language-java"> public void remove() {
         ThreadLocalMap m = getMap(Thread.currentThread());
         if (m != null)
             m.remove(this);
}
</code></pre>
<p>remove方法，直接将ThrealLocal 对应的值从当前相差Thread中的ThreadLocalMap中删除。为什么要删除，这涉及到内存泄露的问题。</p>
<p>如上所说（<a href="#ThreadLocalMap">Local跳转方式</a>，<a href="">Shimo跳转方式</a>）， ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p>
<p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。这样就造成了内存泄露。</p>
<h2 id="threadlocal与threadthreadlocalmap之间的关系">ThreadLocal与Thread，ThreadLocalMap之间的关系</h2>
<p><img src="https://blogimg.ytte.top//img-jixiang//20220311184831.png" alt=""></p>
<p><img src="https://blogimg.ytte.top//img-jixiang//20220311184917.png" alt=""></p>
<h2 id="threadlocal-常见使用场景">ThreadLocal 常见使用场景</h2>
<p>参考====》<a href="https://www.cnblogs.com/zz-ksw/p/12684877.html#!comments">ThreadLocal的应用场景 - sw_kong - 博客园 (cnblogs.com)</a></p>
<p>场景的需求：</p>
<ul>
<li>每个线程需要有自己单独的实例</li>
<li>实例需要在多个方法中共享，但不希望变量被多线程共享</li>
<li>ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。</li>
</ul>
<h3 id="simpledateformat"><strong>SimpleDateFormat</strong></h3>
<p>（Java8里的 java.time.format.DateTimeFormatter 是线程安全的 ，由于它调用的parseResolved0 方法入参都是final 修饰的，不可变变量是线程安全的。）</p>
<p>当时我们使用SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear（），然后调用Calendar.add()。<a href="https://blog.csdn.net/qq_35190492/article/details/107599875?ops_request_misc=%7B%22request%5Fid%22%3A%22164696626016781683978633%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=164696626016781683978633&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-107599875.pc_search_result_cache&amp;utm_term=ThreadLocal&amp;spm=1018.2226.3001.4187">ThreadLocal_敖丙-CSDN博客</a>。如果一个线程先调用了add()然后另一个线程又调用了clear()，这时候parse()方法解析的时间就不对了。</p>
<p>在这种情况下，每个Thread内都有自己的实例副本，且该副本只能由当前Thread访问到并使用，相当于每个线程内部的本地变量，这也是ThreadLocal命名的含义。因为每个线程独享副本，而不是公用的，所以不存在多线程间共享的问题。</p>
<p>比如有<strong>1000</strong>个线程都要用到SimpleDateFormat</p>
<pre><code class="language-java">public class ThreadLocalDemo011 {
   public static ExecutorService threadPool = Executors.newFixedThreadPool(16);

    public static void main(String[] args) throws InterruptedException {

        for (int i = 0; i &lt; 1000; i++) {
            int finalI = i;
            threadPool.submit(() -&gt; {
                String data = new ThreadLocalDemo011().date(finalI);
                System.out.println(data);
            });
        }
        threadPool.shutdown();
    }
    public static Integer id= 0;
    private String date(int seconds){
        Date date = new Date(1000 * seconds);
        id++;
        System.out.println(id+&quot;=============&quot;);
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;mm:ss&quot;);
        return simpleDateFormat.format(date);
    }
}
</code></pre>
<p>可以看出，我们用了一个16线程的线程池，并且给这个线程池提交了1000次任务。每个任务中它做的事情和之前是一样的，还是去执行date方法，并且在这个方法中创建一个simpleDateFormat 对象。近1000个simpleDateFormat 对象会被创建。</p>
<p>这么多对象的创建是有开销的，并且在使用完之后的销毁同样是有开销的，同时存在在内存中也是一种内存的浪费。</p>
<p>我们可能会想到，要不所有的线程共用一个 simpleDateFormat 对象？但是simpleDateFormat 又不是线程安全的，我们必须做同步，比如使用synchronized加锁。到这里也许就是我们最终的一个解决方法。但是使用synchronized加锁会陷入一种排队的状态，多个线程不能同时工作，这样一来，整体的效率就被大大降低了。</p>
<ul>
<li>使用ThreadLocal</li>
</ul>
<p>对这种场景，ThreadLocal再合适不过了，ThreadLocal给每个线程维护一个自己的simpleDateFormat对象，这个对象在线程之间是独立的，互相没有关系的。这也就避免了线程安全问题。与此同时，simpleDateFormat对象还不会创造过多，线程池一共只有 16 个线程，所以需要16个对象即可。</p>
<pre><code class="language-java">public class ThreadLocalDemo04 {

    public static ExecutorService threadPool = Executors.newFixedThreadPool(16);

    public static void main(String[] args) throws InterruptedException {

        for (int i = 0; i &lt; 1000; i++) {
            int finalI = i;
            threadPool.submit(() -&gt; {
                String data = new ThreadLocalDemo04().date(finalI);
                System.out.println(data);
            });
        }
        threadPool.shutdown();
    }

    private String date(int seconds){
        Date date = new Date(1000 * seconds);
        SimpleDateFormat dateFormat = ThreadSafeFormater.dateFormatThreadLocal.get();
        return dateFormat.format(date);
    }
}

class ThreadSafeFormater{
    public static Integer id= 0;
    public static ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal = ThreadLocal.withInitial(() -&gt; {
        id++;
        System.out.println(id+&quot;=============&quot;);
        return new SimpleDateFormat(&quot;mm:ss&quot;);
    });
}
</code></pre>
<ul>
<li>
<p>结果：</p>
<p>可以看出只创建了16个SimpleDateFormat对象。</p>
</li>
</ul>
<pre><code>1=============
4=============
5=============
6=============
3=============
7=============
2=============
8=============
9=============
10=============
11=============
13=============
12=============
14=============
15=============
16=============
00:09
00:16
00:17
........
........
16:05
16:04
16:03
16:02
</code></pre>
<ul>
<li>问题：
<ul>
<li>这种情况每个线程的SimpleDataFormat的parse()方法，在一个任务执行后其他任务继续使用这个线程执行任务时，会不会造成数据混乱。</li>
</ul>
</li>
<li>答案
<ul>
<li>不会，SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear()清除数据，然后调用Calendar.add()添加数据。</li>
</ul>
</li>
</ul>
<h3 id="用户信息类似线程内的全局变量">用户信息（类似线程内的全局变量）</h3>
<p>每个线程内需要保存类似于全局变量的信息（例如在拦截器中获取的用户信息），可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享（因为不同线程获取到的用户信息不一样）。</p>
<p>例如，用 ThreadLocal 保存一些业务内容（用户权限信息、从用户系统获取到的用户名、用户ID 等），这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。</p>
<p>在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，避免了将这个对象（如 user 对象）作为参数传递的麻烦。</p>
<p>比如说我们是一个用户系统，那么当一个请求进来的时候，一个线程会负责执行这个请求，然后这个请求就会依次调用service-1()、service-2()、service-3()、service-4()，这4个方法可能是分布在不同的类中的。</p>
<p><img src="https://blogimg.ytte.top//img-jixiang//20220312212450.png" alt=""></p>
<pre><code class="language-java">package com.kong.threadlocal;


public class ThreadLocalDemo05 {
    public static void main(String[] args) {
        User user = new User(&quot;jack&quot;);
        new Service1().service1(user);
    }
}

class Service1 {
    public void service1(User user){
        //给ThreadLocal赋值，后续的服务直接通过ThreadLocal获取就行了。
        UserContextHolder.holder.set(user);
        new Service2().service2();
    }
}

class Service2 {
    public void service2(){
        User user = UserContextHolder.holder.get();
        System.out.println(&quot;service2拿到的用户:&quot;+user.name);
        new Service3().service3();
    }
}

class Service3 {
    public void service3(){
        User user = UserContextHolder.holder.get();
        System.out.println(&quot;service3拿到的用户:&quot;+user.name);
        //在整个流程执行完毕后，一定要执行remove
        UserContextHolder.holder.remove();
    }
}

class UserContextHolder {
    //创建ThreadLocal保存User对象
    public static ThreadLocal&lt;User&gt; holder = new ThreadLocal&lt;&gt;();
}

class User {
    String name;
    public User(String name){
        this.name = name;
    }
}
</code></pre>
<h1 id="守护线程">守护线程</h1>
<h1 id="面试题">面试题</h1>
<h2 id="线程池创建的4中方法">线程池创建的4中方法</h2>
<p><a href="#6%E3%80%81%E5%8A%9F%E8%83%BD%E7%BA%BF%E7%A8%8B%E6%B1%A0">Local跳转方式</a>，<a href="">Shimo跳转方式</a></p>
<h2 id="任务加入的线程池的流程">任务加入的线程池的流程</h2>
<p><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">Local跳转方式</a>，<a href="">Shimo跳转方式</a></p>
<h2 id="线程池的7个参数拒绝策略">线程池的7个参数。拒绝策略。</h2>
<p>参数：<a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0">Local跳转方式</a>，<a href="">Shimo跳转方式</a></p>
<p>拒绝策略：<a href="#3.%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%88handler%EF%BC%89">Local跳转方式</a>，<a href="">Shimo跳转方式</a></p>
<h2 id="线程池中如何拿到线程的执行结果">线程池中如何拿到线程的执行结果</h2>
<h2 id="线程池中-submit和-execute方法有什么区别">线程池中 submit()和 execute()方法有什么区别？</h2>
<ul>
<li>
<p>execute()：只能执⾏ Runnable 类型的任务。</p>
</li>
<li>
<p>submit()：可以执⾏ Runnable 和 Callable 类型的任务。</p>
</li>
</ul>
<h2 id="死锁">死锁</h2>
<p>两线程都有各自的锁，并都尝试去获取独占对方的锁，就会发生阻塞的现象。</p>
<h2 id="解释下生产消费模型">解释下生产消费模型</h2>
<p>生产者消费者能够解决的问题如下：</p>
<ul>
<li>生产与消费的速度不匹配</li>
<li>软件开发过程中解耦</li>
</ul>
<p>生产者生产，消费者消费，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架满的时候，消费者可以从货架上拿走商品，生产者此时等待货架的空位，这样不断的循环。那么在这个过程中，生产者和消费者是不直接接触的，所谓的‘货架’其实就是一个==阻塞队列==，生产者生产的产品不直接给消费者消费，而是仍给阻塞队列，这个阻塞队列就是来解决生产者消费者的强耦合的。就是生产者消费者模型。<a href="https://blog.csdn.net/qq_40550018/article/details/87859399?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&amp;utm_relevant_index=9">TP①</a>，<a href="">TP②</a></p>
<h1 id="参考">参考</h1>
<ol>
<li><a href="https://www.cnblogs.com/luxiaoxun/p/8744826.html">ThreadLocal原理分析与使用场景 - 阿凡卢 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://www.cnblogs.com/zz-ksw/p/12684877.html#!comments">ThreadLocal的应用场景 - sw_kong - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/qq_35190492/article/details/107599875?ops_request_misc=%7B%22request%5Fid%22%3A%22164696626016781683978633%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=164696626016781683978633&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-107599875.pc_search_result_cache&amp;utm_term=ThreadLocal&amp;spm=1018.2226.3001.4187">ThreadLocal_敖丙-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_40550018/article/details/87859399?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4.pc_relevant_default&amp;utm_relevant_index=9"> CSDN博客_生产者消费者模型</a></li>
<li><a href="https://www.cnblogs.com/SIHAIloveYAN/p/11288064.html">Java8之Consumer、Supplier、Predicate和Function攻略  博客园</a></li>
</ol>
    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>Permalink: </strong>
      <a href="https://gb.ytte.top/1/01/01/thread/" title="Thread" target="_blank" rel="external">https://gb.ytte.top/1/01/01/thread/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License: </strong>
        <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN</a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/YTTE-jx" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://gb.ytte.top/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/YTTE-jx" target="_blank"><span class="text-dark">YTTE</span><small class="ml-1x">努力奋斗，不负韶华。</small></a></h3>
        <div>Good Good Study, Day Day Up~</div>
      </div>
    </figure>
  </div>
</div>

    </div>
  </article>
</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="https://gb.ytte.top/1/01/01/typora/" title="typora"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;Older</span></a>
            </li>
            <li class="next">
                <a href="https://gb.ytte.top/1/01/01/springcloud-alibaba/"
                    title="SpringCloud alibaba"><span>Newer&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="Catalogue" role="button">
                    <span>[&nbsp;</span><span>Catalogue</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>


</main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://github.com/YTTE-jx" target="_blank" title="github" data-toggle=tooltip data-placement=top >
            <i class="icon icon-github"></i></a></li>
    <li><a href="https://gb.ytte.top/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2022  -
    2022
    <div class="publishby">
        Theme by <a href="https://github.com/xiaoheiAh" target="_blank"> xiaoheiAh </a>base on<a href="https://github.com/xiaoheiAh/hugo-theme-pure" target="_blank"> pure</a>.
    </div>
    
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
    window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/python.min.js" defer></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/javascript.min.js" defer></script><script>
    hljs.configure({
        tabReplace: '    ', 
        classPrefix: ''     
        
    })
    hljs.initHighlightingOnLoad();
</script>
<script src="https://gb.ytte.top/js/application.min.e720b935330b2a176cfb4b8bd9a6cc632caf6b752f94e87c62152a9557ff6d15.js"></script>
<script src="https://gb.ytte.top/js/plugin.min.334875d4d4a72afb866e446df61b5f4bf1f0a516d1303166f52f7804d17ef3ab.js"></script>

<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            ROOT_URL: 'https:\/\/gb.ytte.top\/',
            CONTENT_URL: 'https:\/\/gb.ytte.top\/\/searchindex.json ',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script type="text/javascript" src="https://gb.ytte.top/js/insight.min.759e5002714e12761afcd512f103d39c86573165db51972dd3b24df6eddf238ed3e3e85c1988e96cba09419d1deccdeb68c15284f2c3d03049fad53c11774524.js" defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<script>
    tocbot.init({
        
        tocSelector: '.js-toc',
        
        contentSelector: '.js-toc-content',
        
        headingSelector: 'h1, h2, h3',
        
        hasInnerContainers: true,
    });
</script>


  </body>
</html>
